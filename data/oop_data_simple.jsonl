{"task_id": "OOP/0", "question": "First, write a **WDS** class using the Python language. Then, within the WDS class, create a public function called **without_duplicates** to implement finding the length of the longest substring in a given string **s** that does not contain any duplicate characters.", "test_list": ["assert candidate(\"abcabcbb\")==3", "assert candidate(\"bbbbb\")==1", "assert candidate(\"pwwkew\")==3"], "test_function": "def test_run(content1):\n    return WDS().without_duplicates(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class WDS\", \"def without_duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/1", "question": "First, design a class called **MNS** in Python, which has an instance attribute called **machines**, a private function called **private_Ministeps**, and a public function called **public_Ministeps**. Then, implement the following problem in the private function **private_Ministeps**. Finally, call the private function private_Ministeps in the public function **public_Ministeps** and return the result.\nProblem: There are **n** super washing machines placed in a row, and it is unknown whether there are clothes inside each machine. You can choose any **m** machines and move one piece of clothing from each selected machine to an adjacent machine. Return the minimum number of steps required to make the number of clothes remaining in each machine equal.", "test_list": ["assert candidate([1,0,5])==3", "assert candidate([0,3,0])==2", "assert candidate([0,2,0])==-1"], "test_function": "def test_run(content1):\n    return MNS(content1).public_Minimum_number_steps()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNS\", \"def public_Ministeps\", \"def __private_Ministeps\"],[\"class MNS\", \"def public_Ministeps\", \"def _private_Ministeps\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/2", "question": "First, write a class called **FTM** using the Python language. Then, within the **FTM** class, create a public function called **find_the_median** that returns the median of two sorted arrays, **nums1** and **nums2**.", "test_list": ["assert candidate([1,3], [2])==2.00000", "assert candidate([1,2], [3,4])==2.50000"], "test_function": "def test_run(content1,content2):\n    return FTM().find_the_median(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTM\", \"def find_the_median\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/3", "question": "First, write a **PDSB** class using the Python language. Then, within the **PDSB** class, implement a public **pa_substring** function to find the longest palindrome substring in string **s**.", "test_list": ["assert candidate(\"babad\")==\"bab\"", "assert candidate(\"cbbd\")==\"bb\""], "test_function": "def test_run(content1):\n    return PDSB().pa_substring(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PDSB\", \"def pa_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/4", "question": "First, write a **ZZPTN** class using the Python language, then write a public **Zigzag_pattern** function in the **ZZPTN** class to solve the following problem.\nProblem: Given a string **s** and an integer **numRows**, arrange the string **s** from top to bottom and from left to right in a Z shape according to the given **numRows**.", "test_list": ["assert candidate(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"", "assert candidate(\"PAYPALISHIRING\", 4)==\"PINALSIGYAHRPI\"", "assert candidate(\"A\", 1)==\"A\""], "test_function": "def test_run(content1,content2):\n    return ZZPTN().Zigzag_pattern(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ZZPTN\", \"def Zigzag_pattern\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/5", "question": "First, write an **ITOC** class using the Python language. Then, within the **ITOC** class, create a public function called **Invert_outcome** that takes a 32-bit signed integer **x** as input and returns the result of reversing the numerical part of **x**.", "test_list": ["assert candidate(123)==321", "assert candidate(-123)==-321", "assert candidate(120)==21", "assert candidate(0)==0"], "test_function": "def test_run(content1):\n    return ITOC().Invert_outcome(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ITOC\", \"def Invert_outcome\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/6", "question": "First, write a **PDIT** class using Python language. Then, within the **PDIT** class, write a public function named **Palindromic_integer**. This function should determine whether a given integer **x** is a palindromic integer. If it is, the function should return True; otherwise, it should return False.", "test_list": ["assert candidate(121)==True", "assert candidate(-121)==False", "assert candidate(10)==False"], "test_function": "def test_run(content1):\n    return PDIT().Palindromic_integer(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PDIT\", \"def Palindromic_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/7", "question": "First, write a **RLMH** class using the Python language. Then, within the **RLMH** class, create a public **rule_matching** function that implements a regular expression matching for a given string **s** and a character pattern **p**, using the following rules: 1. '.' matches any single character; 2. '*' matches zero or more occurrences of the preceding element.", "test_list": ["assert candidate(\"aa\", \"a\")==False", "assert candidate(\"aa\", \"a*\")==True", "assert candidate(\"ab\", \".*\")==True"], "test_function": "def test_run(content1,content2):\n    return RLMH().rule_matching(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RLMH\", \"def rule_matching\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/8", "question": "First, write a **LCMP** class using the Python language. Then, within the **LCMP** class, create a public function called **longest_common_prefix** to find the longest common prefix among an array of strings. If no common prefix exists, return an empty string \"\".", "test_list": ["assert candidate([\"flower\",\"flow\",\"flight\"])==\"fl\"", "assert candidate([\"dog\",\"racecar\",\"car\"])==\"\""], "test_function": "def test_run(content1,content2,content3):\n    return LCMP().longest_common_prefix(content1,content2,content3)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LCMP\", \"def longest_common_prefix\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/9", "question": "First, write a **TSOTN** class using the Python language. Then, within the **TSOTN** class, create a public function called **sum_three_numbers**. This function takes in an integer array called **nums** with a length of **n**, and a target value called **target**. The function selects three integers from **nums** in such a way that their sum is closest to the target value. Finally, the function returns the sum of these three numbers.", "test_list": ["assert candidate([-1,2,1,-4], 1)==2", "assert candidate([0,0,0], 1)==0"], "test_function": "def test_run(content1,content2):\n    return TSOTN().sum_three_numbers(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TSOTN\", \"def sum_three_numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/10", "question": "Firstly, write a class **VLD_ST** using the Python language, then write a public function **valid_string** within the **VLD_ST** class to judge whether a given string **s**, which only includes '(',')','{','}','[',']', is valid or not. \nA valid string must meet the following conditions: \n1. The left bracket must be closed by the right bracket of the same type; \n2. The left brackets must be closed in the correct order; \n3. Each right bracket has a corresponding left bracket of the same type.", "test_list": ["assert candidate(\"()\")==True", "assert candidate(\"()[]{}\")==True", "assert candidate(\"(]\")==False"], "test_function": "def test_run(content1):\n    return VLD_ST().valid_string(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VLD_ST\", \"def valid_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/11", "question": "First, write a **VDPT** class using the Python language. Then, within the **VDPT** class, create a public **valid_parentheses** function. This function should take an integer **n** as input, representing the number of pairs of parentheses to generate. The function should then print out all possible and valid combinations of parentheses.", "test_list": ["assert candidate(3)==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]", "assert candidate(1)==[\"()==[\"()\"]", "assert candidate(\"(]\")==False"], "test_function": "def test_run(content1):\n    return VDPT().valid_parentheses(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VDPT\", \"def valid_parentheses\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/12", "question": "First, write a **NLAR** class using the Python language. Then, within the **NLAR** class, create a public function called **new_length_removal**. This function should take an array called **nums** and a value called **val** as input. The function should remove all elements in the array that are equal to **val**, and return the new length of the array after removal.", "test_list": ["assert candidate([3,2,2,3], 3)==2", "assert candidate([0,1,2,2,3,0,4,2], 2)==5"], "test_function": "def test_run(content1,content2):\n    return NLAR().new_length_removal(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VDPT\", \"def new_length_removal\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/13", "question": "First, write a class **FMIS** using the Python language. Then, within the **FMIS** class, write a public function **find_matching_items** that, given two strings **haystack** and **needle**, finds the index of the first matching item of the **needle** string in the **haystack** string (index starts from 0). If the **needle** is not part of the **haystack**, return -1.", "test_list": ["assert candidate(\"sadbutsad\", \"sad\")==0", "assert candidate(\"leetcode\", \"leeto\")==-1"], "test_function": "def test_run(content1,content2):\n    return FMIS().find_matching_items(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FMIS\", \"def find_matching_items\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/14", "question": "First, write an **LVPSS** class using the Python language. Then, within the **LVPSS** class, write a public function named **long_valid_substring**. This function should find the length of the longest valid (correctly formatted and continuous) parenthesis substring in a given string that only contains '(' and ')'.", "test_list": ["assert candidate(\"(()\")==2", "assert candidate(\"\")==0", "assert candidate(\")()())\")==4"], "test_function": "def test_run(content1):\n    return LVPSS().long_valid_substring(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LVPSS\", \"def long_valid_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/15", "question": "First, write a class named **FTGV** using the Python language. Then, within the **FTGV** class, write a public function called **find_target_value** that, given a sorted array and a target value, finds the target value in the array and returns its index. If the target value does not exist in the array, it returns the position where it would be inserted in order.", "test_list": ["assert candidate([1,3,5,6], 5)==2", "assert candidate([1,3,5,6], 2)==1", "assert candidate([1,3,5,6], 7)==4"], "test_function": "def test_run(content1,content2):\n    return FTGV().find_target_value(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTGV\", \"def find_target_value\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/16", "question": "First, write a class **FSAEP** using the Python language, then write a public function **finding_positions** in the **LVPSS** class. Given an integer array **nums** sorted in non-decreasing order and a target value **target**, this function finds the starting and ending positions of the given target value in the array. If the target value **target** does not exist in the array, return [-1, -1].", "test_list": ["assert candidate([5,7,7,8,8,10], 8)==[3,4]", "assert candidate([5,7,7,8,8,10], 6)==[-1,-1]", "assert candidate([], 0)==[-1,-1]"], "test_function": "def test_run(content1,content2):\n    return LVPSS().long_valid_substring(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FSAEP\", \"def finding_positions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/17", "question": "Firstly, write an **NCBT** class using the Python language. Then, within the **NCBT** class, write a public function named **numeric_combination**. Given a set of candidate numbers **candidates** and a target number **target**, this function should find all combinations in **candidates** that can sum up to the **target** and return them in the form of a list.", "test_list": ["assert candidate([10,1,2,7,6,1,5], 8)==[[1,1,6],[1,2,5],[1,7],[2,6]]", "assert candidate([2,5,2,1,2], 5)==[[1,2,2],[5]]"], "test_function": "def test_run(content1,content2):\n    return NCBT().numeric_combination(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NCBT\", \"def numeric_combination\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/18", "question": "First, create a class called **TSPI** using the Python language. Then, within the **TSPI** class, write a public function called **smallest_positive_integer**. This function should take an unsorted array of integers called **nums** as input and find the smallest positive integer that is not present in the array.", "test_list": ["assert candidate([1,2,0])==3", "assert candidate([3,4,-1,1])==2", "assert candidate([7,8,9,11,12])==1"], "test_function": "def test_run(content1):\n    return TSPI().smallest_positive_integer(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TSPI\", \"def smallest_positive_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/19", "question": "First, write an **HTRW** class using the Python language, then write a public function named **harvest_rainwater** within the **HTRW** class to solve the following problem.\nProblem: Given **n** non-negative integers representing the height of each pillar of width 1 in the diagram, calculate how much rainwater can be collected after it rains with the pillars arranged in this way.", "test_list": ["assert candidate([0,1,0,2,1,0,1,3,2,1,2,1])==6", "assert candidate([4,2,0,3,2,5])==9"], "test_function": "def test_run(content1):\n    return HTRW().harvest_rainwater(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class HTRW\", \"def harvest_rainwater\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/20", "question": "First, write a class called **STFM** using the Python language. Then, within the **STFM** class, create a public function called **string_form**. This function should take two non-negative integers, **num1** and **num2**, represented as strings, and return their product as a string.", "test_list": ["assert candidate(\"123\", \"456\")==\"56088\"", "assert candidate(\"2\", \"3\")==\"6\""], "test_function": "def test_run(content1,content2):\n    return HTRW().harvest_rainwater(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STFM\", \"def string_form\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/21", "question": "First, write a **PMTTN** class using the Python language. Then, within the **PMTTN** class, create a public **permutation** function that takes an array **nums** without duplicate numbers as input and returns all possible permutations.", "test_list": ["assert candidate([1,2,3])==[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "assert candidate([0,1])==[[0,1],[1,0]]", "assert candidate([1])==[[1]]"], "test_function": "def test_run(content1):\n    return PMTTN().permutation(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PMTTN\", \"def permutation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/22", "question": "First, write a **UQPTT** class using the Python language, then write a public **unique_permutations** function within the **UQPTT** class to solve the following problem.\nProblem: Given a sequence of **nums** containing duplicate numbers, return all unique permutations.", "test_list": ["assert candidate([1,1,2])==[[1,1,2],[1,2,1],[2,1,1]]", "assert candidate([1,2,3])==[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"], "test_function": "def test_run(content1):\n    return UQPTT().unique_permutations(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class UQPTT\", \"def unique_permutations\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/23", "question": "First, write a class called **RTICW** using the Python language. Then, within the **RTICW** class, create a public function called **rotate_image_clockwise**. This function should take a 2D matrix, represented by the variable matrix, with dimensions n × n, which represents an image. The function should rotate the image clockwise by 90 degrees.", "test_list": ["assert candidate([[1,2,3],[4,5,6],[7,8,9]])==[[7,4,1],[8,5,2],[9,6,3]]", "assert candidate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])==[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"], "test_function": "def test_run(content1):\n    return RTICW().rotate_image_clockwise(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RTICW\", \"def rotate_image_clockwise\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/24", "question": "First, write a class called **AAGM** using the Python language. Then, within the **AAGM** class, create a public function called **anagram** that takes an array of strings as input. This function should group together anagrams and return the result as a list.", "test_list": ["assert candidate([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])==[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]", "assert candidate([\"\"])==[[\"\"]]", "assert candidate([\"a\"])==[[\"a\"]]"], "test_function": "def test_run(content1):\n    return AAGM().anagram(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AAGM\", \"def anagram\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/25", "question": "First, write a **PFTN** class using the Python language. Then, within the **PFTN** class, create a public **power_function** function that calculates the integer power of **x** to the n-th degree.", "test_list": ["assert candidate(2.00000, 10)==1024.00000", "assert candidate(2.10000, 3)==9.26100", "assert candidate(2.00000, -2)==0.25000"], "test_function": "def test_run(content1,content2):\n    return PFTN().power_function(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PFTN\", \"def power_function\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/26", "question": "First, write a class called **FDSB** using the Python language. Then, within the **FDSB** class, write a public function called **find_subarray** that takes an integer array called **nums** as input. This function will find a contiguous subarray within **nums** that has the maximum sum.", "test_list": ["assert candidate([-2,1,-3,4,-1,2,1,-5,4])==6", "assert candidate([1])==1", "assert candidate([5,4,-1,7,8])==23"], "test_function": "def test_run(content1):\n    return FDSB().find_subarray(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FDSB\", \"def find_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/27", "question": "First, write a class called **CWSO** using the Python language. Then, within the **CWSO** class, create a public function called **clockwise_spiral_order**. This function takes a matrix with **m** rows and **n** columns as input and returns all the elements in the matrix in a clockwise spiral order.", "test_list": ["assert candidate([[1,2,3],[4,5,6],[7,8,9]])==[1,2,3,6,9,8,7,4,5]", "assert candidate([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==[1,2,3,4,8,12,11,10,9,5,6,7]"], "test_function": "def test_run(content1):\n    return CWSO().clockwise_spiral_order(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CWSO\", \"def clockwise_spiral_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/28", "question": "First, write a class called **MMJL** using the Python language. Then, within the **MMJL** class, write a public function called **maximum_jump_length**. Given a non-negative integer array called **nums**, this function should determine whether it is possible to reach the last index based on the following rules: 1. Initially, start at the first index of the array. 2. Each element in the array represents the maximum length that can be jumped from that position. If it is possible to reach the last index, the function should return True; otherwise, it should return False.", "test_list": ["assert candidate([2,3,1,1,4])==True", "assert candidate([3,2,1,0,4])==False"], "test_function": "def test_run(content1):\n    return MMJL().maximum_jump_length(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MMJL\", \"def maximum_jump_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/29", "question": "Firstly, write a class named **MOLI** using Python language. Then, in the **MOLI** class, write a public function called **merge_overlapping_intervals** that takes an array **intervals** representing a collection of ranges, where each individual range is represented as intervals[i] = [start_i, end_i]. This function should merge all overlapping ranges and return an array of non-overlapping ranges that exactly cover all the ranges in the input.", "test_list": ["assert candidate([[1,3],[2,6],[8,10],[15,18]])==[[1,6],[8,10],[15,18]]", "assert candidate([[1,4],[4,5]])==[[1,5]]"], "test_function": "def test_run(content1):\n    return MOLI().merge_overlapping_intervals(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MOLI\", \"def merge_overlapping_intervals\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/30", "question": "First, write a **STANOL** class using the Python language. Then, within the **STANOL** class, create a public function called **sorted_non_overlapping** that inserts a new interval into a sorted list of non-overlapping intervals, sorted by the starting points of each interval. This function should ensure that the intervals in the list remain sorted and non-overlapping.", "test_list": ["assert candidate([[1,3],[6,9]], [2,5])==[[1,5],[6,9]]", "assert candidate([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])==[[1,2],[3,10],[12,16]]", "assert candidate([], [5,7])==[[5,7]]", "assert candidate([[1,5]], [2,3])==[[1,5]]", "assert candidate([[1,5]], [2,7])==[[1,7]]"], "test_function": "def test_run(content1,content2):\n    return STANOL().sorted_non_overlapping(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STANOL\", \"def sorted_non_overlapping\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/31", "question": " First, write a **WDLH** class using the Python language, then write a public **word_length** function in the **WDLH** class to solve the following problem.\nProblem: Given a string **s**, the string **s** is composed of several words, separated by some space characters before and after the word, return the length of the last word in the string.", "test_list": ["assert candidate(\"Hello World\")==5", "assert candidate(\"   fly me   to   the moon  \")==4", "assert candidate(\"luffy is still joyboy\")==6"], "test_function": "def test_run(content1):\n    return WDLH().word_length(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class WDLH\", \"def word_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/32", "question": "First, write an **STP** class using the Python language. Then, in the **STP** class, write a public function named **shortest_path**. Given a m x n grid containing non-negative integers, this function should find a path from the top left corner to the bottom right corner that minimizes the sum of the numbers along the path.", "test_list": ["assert candidate([[1,3,1],[1,5,1],[4,2,1]])==7", "assert candidate([[1,2,3],[4,5,6]])==12"], "test_function": "def test_run(content1):\n    return STP().shortest_path(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STP\", \"def shortest_path\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/33", "question": "First, write a **NNTI** class using the Python language, then write a public **non_negative_integer** function in the **NNTI** class to solve the following problem.\nProblem: Given a non-empty array composed of integers representing a non-negative integer, add one to this number, and return the result with the highest digit stored at the beginning of the array.\nNote:Each element in the array only stores a single digit (except for the integer 0, this integer will not start with zero).", "test_list": ["assert candidate([1,2,3])==[1,2,4]", "assert candidate([4,3,2,1])==[4,3,2,2]", "assert candidate([0])==[1]"], "test_function": "def test_run(content1):\n    return NNTI().non_negative_integer(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NNTI\", \"def non_negative_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/34", "question": "First, write a class called **BASTI** using the Python language. Then, within the **BASTI** class, create a public function called **binary_string**. This function should take two binary strings, **a** and **b**, as input and return their sum in the form of a binary string.", "test_list": ["assert candidate(\"11\", \"1\")==\"100\"", "assert candidate(\"1010\", \"1011\")==\"10101\""], "test_function": "def test_run(content1,content2):\n    return BASTI().binary_string(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BASTI\", \"def binary_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/35", "question": "First, write a **CRTP** class using the Python language. Then, within the **CRTP** class, implement a public function called **climb_rooftop** to solve the following problem: Suppose you are climbing a staircase and it takes **n** steps to reach the top. At each step, you can either climb 1 or 2 steps. How many distinct ways are there to climb to the top?", "test_list": ["assert candidate(2)==2", "assert candidate(3)==3"], "test_function": "def test_run(content1):\n    return CRTP().climb_rooftop(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CRTP\", \"def climb_rooftop\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/36", "question": "First, write a **TAFER** class using the Python language. Then, within the **TAFER** class, create a public **trans_fomer** function. This function takes two words, **word1** and **word2**, as input and returns the minimum number of operations required to transform **word1** into **word2**. There are three possible operations that can be performed on a word: 1. Inserting a character, 2. Deleting a character, and 3. Replacing a character.", "test_list": ["assert candidate(\"horse\", \"ros\")==3", "assert candidate(\"intention\", \"execution\")==5"], "test_function": "def test_run(content1,content2):\n    return TAFER().trans_fomer(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TAFER\", \"def trans_fomer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/37", "question": "First, write a class called **STEZ** using the Python language. Then, within the **STEZ** class, create a public function called **element_setting_zero**. This function should take in an m x n matrix as input. If an element in the matrix is 0, it should set all the elements in its corresponding row and column to 0.", "test_list": ["assert candidate([[1,1,1],[1,0,1],[1,1,1]])==[[1,0,1],[0,0,0],[1,0,1]]", "assert candidate([[0,1,2,0],[3,4,5,2],[1,3,1,5]])==[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"], "test_function": "def test_run(content1):\n    return STEZ().element_setting_zero(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STEZ\", \"def element_setting_zero\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/38", "question": "First, implement the **GYHT** class using the Python language. Then, write a public function called **YangHui_Triangle** within the **GYHT** class. This function should take a non-negative integer **numRows** as input and generate the first **numRows** rows of the Yang Hui triangle.", "test_list": ["assert candidate(5)==[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]", "assert candidate(1)==[[1]]"], "test_function": "def test_run(content1):\n    return GYHT().Generate_Yang_Hui_Triangle(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GYHT\", \"def YangHui_Triangle\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/39", "question": "First, implement the **FTMPA** class using the Python language. Then, write a public function called **Minimum_Path** in the **FTMPA** class. This function should aim to find the minimum path sum from top to bottom in a given **triangle**.", "test_list": ["assert candidate([[2],[3,4],[6,5,7],[4,1,8,3]])==11", "assert candidate([[-10]])==-10"], "test_function": "def test_run(content1):\n    return FTMPA().Find_The_Minimum_Path_And(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTMPA\", \"def Minimum_Path\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/40", "question": "First, implement the **CMP** class using the Python language. Then, within the **CMP** class, write a public function called **Calculate_Maximum_Profit**. This function should take an array as input and calculate the maximum profit that can be obtained. Each element in the array represents the price of a given stock on the i-th day. It is allowed to complete a maximum of two transactions.", "test_list": ["assert candidate([3,3,5,0,0,3,1,4])==6", "assert candidate([1,2,3,4,5])==4", "assert candidate([7,6,4,3,1])==0", "assert candidate([1])==0"], "test_function": "def test_run(content1):\n    return CMP().Calculate_Maximum_Profit(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CMP\", \"def Calculate_Maximum_Profit\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/41", "question": "First, implement the **FTLOTLS** class using the Python language. Then, write a public function called **Longest_Sequence** within the **FTLOTLS** class. This function should take an unsorted integer array called **nums** as input and find the length of the longest sequence of consecutive numbers (the sequence elements do not need to be consecutive in the original array).", "test_list": ["assert candidate([100,4,200,1,3,2])==4", "assert candidate([0,3,7,2,5,8,4,6,0,1])==9"], "test_function": "def test_run(content1):\n    return FTLOTLS().Find_The_Length_Of_The_Longest_Sequence(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTLOTLS\", \"def Longest_Sequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/42", "question": "First, implement the **AF** class using the Python language. Then, within the **AF** class, write a public function called **Area_Fill** that takes a given m x n matrix called **board**, which is composed of characters 'X' and 'O'. The function should find all the regions surrounded by 'X' and fill all the 'O' within these regions with 'X'.", "test_list": ["assert candidate([[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]])==[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]", "assert candidate([[\"X\"]])==[[\"X\"]]"], "test_function": "def test_run(content1):\n    return AF().Area_Fill(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AF\", \"def Area_Fill\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/43", "question": "First, implement the **SS** class using the Python language. Then, within the **SS** class, write a public function called **Split_String** that takes a string **s** as input and returns all possible partition schemes of **s**, where each substring in the partition is a palindrome.", "test_list": ["assert candidate(\"aab\")==[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]", "assert candidate(\"a\")==[[\"a\"]]"], "test_function": "def test_run(content1):\n    return SS().Split_String(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SS\", \"def Split_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/44", "question": "First, implement the **MNOD** class using the Python language. Then, within the **MNOD** class, write a public function called **Minimum_Divisions** that takes a string **s** as input. This function should split the string **s** into substrings, where each substring is a palindrome, and return the minimum number of divisions required to satisfy this condition.", "test_list": ["assert candidate(\"aab\")==1", "assert candidate(\"a\")==0", "assert candidate(\"ab\")==1"], "test_function": "def test_run(content1):\n    return MNOD().Minimum_Number_Of_Divisions(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNOD\", \"def Minimum_Divisions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/45", "question": "Firstly, implement the **DSBCD** class using Python language. Then, write a public **distribute_candie** function in the **DSBCD** class to solve the following problem.\nProblem: **n** children are standing in a line, and an integer array **ratings** is given to represent the ratings of each child. Candies need to be distributed to these children according to the following requirements:\n1. Each child should be allocated at least one candy; \n2. The child with a higher rating among two adjacent children will get more candies. \nFor distributing candies to each child, calculate and return the minimum number of candies that need to be prepared.", "test_list": ["assert candidate([1,0,2])==5", "assert candidate([1,2,2])==4"], "test_function": "def test_run(content1):\n    return DSBCD().distribute_candie(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DSBCD\", \"def distribute_candie\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/46", "question": "First, implement the **ITETAO** class using the Python language. Then, write a public function called **Appeared_Once** in the **ITETAO** class. This function should take a non-empty integer array called **nums** as input. The function should find the element that appears only once in the array, while all other elements appear twice.", "test_list": ["assert candidate([2,2,1])==1", "assert candidate([4,1,2,1,2])==4", "assert candidate([1])==1"], "test_function": "def test_run(content1):\n    return ITETAO().Identify_The_Element_That_Appeared_Once(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ITETAO\", \"def Appeared_Once\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/47", "question": "Firstly, implement a **JS** class using Python language. Then, in the **JS** class, write a public function named **Judgment_Splicing**. This function should take a string **s** and a list of strings **wordDict** as a dictionary, and determine whether the string **s** can be spliced together using the words that appear in the dictionary. If it can, return True; otherwise, return False.", "test_list": ["assert candidate(\"leetcode\", [\"leet\", \"code\"])==True", "assert candidate(\"applepenapple\", [\"apple\", \"pen\"])==True", "assert candidate(\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"])==False"], "test_function": "def test_run(content1,content2):\n    return JS().Judgment_Splicing(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JS\", \"def Judgment_Splicing\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/48", "question": "First, implement the **CS** class using the Python language. Then, write a public **Constructing_Sentences** function in the **CS** class to create a sentence by adding spaces in a given string **s**, using words from the wordDict string dictionary. The function should return all possible sentences that can be constructed.", "test_list": ["assert candidate(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])==[\"cats and dog\",\"cat sand dog\"]", "assert candidate(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])==[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]", "assert candidate(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])==[]"], "test_function": "def test_run(content1,content2):\n    return CS().Constructing_Sentences(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CS\", \"def Constructing_Sentences\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/49", "question": "Firstly, implement the **FTMP** class using Python language. Then, in the **FTMP** class, write a public function named **Most_Points**. This function should take an array of **points** as input, where points[i]=[x_i,y_i] represents a point on the X-Y plane. The function should return how many points can be on the same line at most.", "test_list": ["assert candidate([[1,1],[2,2],[3,3]])==3", "assert candidate([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]])==4"], "test_function": "def test_run(content1):\n    return FTMP().Find_The_Most_Points(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTMP\", \"def Most_Points\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/50", "question": "First, implement the **CE** class using the Python language. Then, write a public function called **Calculating_Expressions** in the **CE** class to calculate the arithmetic expression represented by a given string array called **tokens**, which represents the expression in Reverse Polish Notation. The function should calculate the expression and return an integer representing the value of the expression.", "test_list": ["assert candidate([\"2\",\"1\",\"+\",\"3\",\"*\"])==9", "assert candidate([\"4\",\"13\",\"5\",\"/\",\"+\"])==6", "assert candidate([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])==22"], "test_function": "def test_run(content1):\n    return CE().Calculating_Expressions(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CE\", \"def Calculating_Expressions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/51", "question": "First, implement the **RWO** class using the Python language. Then, write a public function called **Reverse_Word_Order** in the **RWO** class to solve the following problem.\nProblem: Given a string **s**, return the order of the words in the reversed string.", "test_list": ["assert candidate(\"the sky is blue\")==\"blue is sky the\"", "assert candidate(\"  hello world  \")==\"world hello\"", "assert candidate(\"a good   example\")==\"example good a\""], "test_function": "def test_run(content1):\n    return RWO().Reverse_Word_Order(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RWO\", \"def Reverse_Word_Order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/52", "question": "First, implement the **NCS** class using the Python language. Then, write a public **non_empty_subarray** function in the **NCS** class to solve the following problem:\nProblem: Given an integer array **nums**, find the contiguous subarray with the maximum product (the subarray must contain at least one number) and return the product of that subarray.", "test_list": ["assert candidate([2,3,-2,4])==6", "assert candidate([-2,0,-1])==0"], "test_function": "def test_run(content1):\n    return NCS().non_empty_contiguous_subarray(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NCS\", \"def non_empty_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/53", "question": "First, implement the **PE** class using the Python language. Then, write a public function called **Peak_elements** in the **PE** class to solve the following problem:\nProblem: Given an integer array **nums**, find a peak element and return its index.\nA peak element is defined as an element that is strictly greater than its adjacent elements on the left and right.", "test_list": ["assert candidate([1,2,3,1])==2", "assert candidate([1,2,1,3,5,6,4])==1", "assert candidate([1,2,1,3,5,6,4])==5"], "test_function": "def test_run(content1):\n    return PE().Peak_elementes(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PE\", \"def Peak_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/54", "question": "First, implement the **TMDBAE** class using the Python language. Then, write a public function called **adjacent_elements** in the **TMDBAE** class to solve the following problem:\nProblem: Given an unordered array **nums**, return the maximum difference between adjacent elements after sorting the array. If the number of elements in the array is less than 2, return 0.", "test_list": ["assert candidate([3,6,9,1])==3", "assert candidate([10])==0"], "test_function": "def test_run(content1):\n    return TMDBAE().The_maximum_difference_between_adjacent_elements(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TMDBAE\", \"def adjacent_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/55", "question": "First, implement the **GME** class using the Python language. Then, write a public function called **get_most_elements** in the **GME** class to solve the following problem:\nProblem: Given an array **nums** of size **n**, return the majority element.\nThe majority element is the element that appears more than ⌊n/2⌋ times in the array.", "test_list": ["assert candidate([3,2,3])==3", "assert candidate([2,2,1,1,1,2,2])==2"], "test_function": "def test_run(content1):\n    return GME().get_most_elements(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GME\", \"def get_most_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/56", "question": "First, implement the **GTNOTZ** class using the Python language. Then, write a public function called **get_trailing** within the **GTNOTZ** class to solve the following problem:\nProblem: Given an integer **n**, return the number of trailing zeros in the result of **n!**.", "test_list": ["assert candidate(3)==3", "assert candidate(5)==1"], "test_function": "def test_run(content1):\n    return GTNOTZ().get_the_number_of_trailing_zeros(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GTNOTZ\", \"def get_trailing\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/57", "question": "First, implement the **NNI** class using the Python language. Then, write a public function called **Non_negative_integers** in the **NNI** class to solve the following problem:\nProblem: Given a set of non-negative integers **nums**, rearrange the order of each number (without splitting any number) to form the largest possible integer.\nNote: The output result may be very large, so you need to return a string instead of an integer.", "test_list": ["assert candidate([10,2])==210", "assert candidate([3,30,34,5,9])==9534330"], "test_function": "def test_run(content1):\n    return NNI().Non_negative_integers(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NNI\", \"def Non_negative_integers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/58", "question": "First, implement the **IRSID** class using the Python language. Then, write a public function named **sequences_DNA** in the **IRSID** class to solve the following problem:\nProblem: DNA sequences are composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. When studying DNA, it is useful to identify repetitive sequences in the DNA.\nGiven a string **s** representing a DNA sequence, return all the 10-letter sequences (substrings) that appear more than once in the DNA molecule.", "test_list": ["assert candidate([\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"])==[\"AAAAACCCCC\",\"CCCCCAAAAA\"]", "assert candidate(\"AAAAAAAAAAAAA\")==[\"AAAAAAAAAA\"]"], "test_function": "def test_run(content1):\n    return IRSID().Identify_repetitive_sequences_in_DNA(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IRSID\", \"def sequences_DNA\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/59", "question": "First, implement the **ERTTR** class using the Python language. Then, write a public function called **element_rotates** in the **ERTTR** class to solve the following problem:\nProblem: Given an integer array **nums**, rotate the elements in the array to the right by **k** positions and return the result.", "test_list": ["assert candidate([1,2,3,4,5,6,7],3)==[5,6,7,1,2,3,4]", "assert candidate([-1,-100,3,99],2)==[3,99,-1,-100]"], "test_function": "def test_run(content1,content2):\n    return ERTTR().element_rotates_to_the_right(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ERTTR\", \"def element_rotates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/60", "question": "First, implement the **ITBB** class using the Python language. Then, write a public function called **Invert_the_binary_bits** in the **ITBB** class to solve the following problem:\nProblem: Reverse the binary bits of a given 32-bit unsigned integer and return the unsigned integer result.", "test_list": ["assert candidate(00000010100101000001111010011100)==964176192", "assert candidate(11111111111111111111111111111101)==3221225471"], "test_function": "def test_run(content1):\n    return ITBB().Invert_the_binary_bits(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ITBB\", \"def Invert_the_binary_bits\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/61", "question": "First, implement the **RTN** class using the Python language. Then, write a public function called **Hamming_weight** in the **RTN** class to solve the following problem:\nProblem: Write a function that takes an unsigned integer as input (in the form of a binary string) and returns the number of '1' digits in its binary representation (also known as the Hamming weight).", "test_list": ["assert candidate(00000000000000000000000000001011)==3", "assert candidate(00000000000000000000000010000000)==1", "assert candidate(11111111111111111111111111111101)==31"], "test_function": "def test_run(content1):\n    return RTN().Returns_the_number(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RTN\", \"def Hamming_weight\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/62", "question": "First, implement the **CTNOI** class using the Python language. Then, write a public function called **number_islands** in the **CTNOI** class to solve the following problem:\nProblem: Given a 2D grid consisting of '1' (land) and '0' (water), calculate the number of islands in the grid.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally and/or vertically.", "test_list": ["assert candidate([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]])==1", "assert candidate([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]])==3"], "test_function": "def test_run(content1):\n    return CTNOI().Calculate_the_number_of_islands(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CTNOI\", \"def number_islands\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/63", "question": "First, implement the **DABA** class using the Python language. Then, write a public function called **Digits_bitwise** in the **DABA** class to solve the following problem:\nProblem: Given two integers, **left** and **right**, representing the range [left, right], return the bitwise AND of all numbers in this range (including the endpoints **left** and **right**).", "test_list": ["assert candidate(5,7)==4", "assert candidate(0,0)==0", "assert candidate(1,2147483647)==0"], "test_function": "def test_run(content1,content2):\n    return DABA().Digits_are_bitwise_and(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DABA\", \"def Digits_bitwise\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/64", "question": "First, implement the **RV** class using the Python language. Then, write a public **Return_value** function in the **RV** class to solve the following problem:\nProblem: Given an integer **n**, return the count of prime numbers less than the non-negative integer **n**.", "test_list": ["assert candidate(10)==4", "assert candidate(0)==0", "assert candidate(1)==0"], "test_function": "def test_run(content1):\n    return RV().Return_value(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RV\", \"def Return_value\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/65", "question": "First, implement the **DIIII** class using Python language, then write a public function called **isomorphic** in the **DIIII** class to solve the following problem.\nProblem: Given two strings **s** and **t**, determine whether they are isomorphic. If the characters in **s** can be replaced by some mapping relationship to get **t**, then these two strings are isomorphic.", "test_list": ["assert candidate(\"egg\",\"add\")==True", "assert candidate(\"foo\", \"bar\")==False", "assert candidate(\"paper\",\"title\")==True"], "test_function": "def test_run(content1,content2):\n    return DIIII().Determine_if_it_is_isomorphic(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DIIII\", \"def isomorphic\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/66", "question": "First, implement the **FTA** class using the Python language. Then, write a public function called **Find_the_array** in the **FTA** class to solve the following problem:\nProblem: Given an array of **n** positive integers and a positive integer **target**, find the length of the smallest contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] whose sum is greater than or equal to the target. If no such subarray exists, return 0.", "test_list": ["assert candidate(7, [2,3,1,2,4,3])==2", "assert candidate(4, [1,4,4])==1", "assert candidate(11, [1,1,1,1,1,1,1,1])==0"], "test_function": "def test_run(content1,content2):\n    return FTA().Find_the_array(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTA\", \"def Find_the_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/67", "question": "First, implement the **STPD** class using the Python language. Then, write a public function called **Shortest_Palindrome** in the **STPD** class to solve the following problem:\n\nProblem: Given a string **s**, convert it into a palindrome by adding characters at the beginning of the string. Find and return the shortest palindrome that can be obtained using this method.", "test_list": ["assert candidate(\"aacecaaa\")==\"aaacecaaa\"", "assert candidate(\"abcd\")==\"dcbabcd\""], "test_function": "def test_run(content1):\n    return STPD().Shortest_Palindrome(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STPD\", \"def Shortest_Palindrome\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/68", "question": "First, implement the **RTLE** class using the Python language. Then, write a public function **largest_element** in the **RTLE** class to solve the following problem:\nProblem: Given an integer array **nums** and an integer **k**, return the k-th largest element in the array.", "test_list": ["assert candidate([3,2,1,5,6,4],2)==5", "assert candidate([3,2,3,1,2,4,5,5,6],4)==4"], "test_function": "def test_run(content1,content2):\n    return RTLE().Returns_the_largest_element(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RTLE\", \"def largest_element\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/69", "question": "First, implement the **GTAC** class using the Python language. Then, write a public function called **additive_combination** in the **GTAC** class to solve the following problem:\n\nProblem: Find all combinations of **k** numbers that add up to **n**, satisfying the following conditions:\n1. Only use numbers from 1 to 9.\n2. Each number can only be used once.\nReturn a list of all possible valid combinations.", "test_list": ["assert candidate(3,7)==[[1,2,4]]", "assert candidate(3,9)==[[1,2,6], [1,3,5], [2,3,4]]", "assert candidate(4,1)==[]"], "test_function": "def test_run(content1,content2):\n    return GTAC().Get_the_additive_combination(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GTAC\", \"def additive_combination\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/70", "question": "First, implement the **JTA** class using the Python language. Then, write a public function called **judging_the_array** in the **JTA** class to solve the following problem:\nProblem: Given an integer array **nums**, return True if any value appears at least twice in the array, and False if every element in the array is distinct.", "test_list": ["assert candidate([1,2,3,1])==True", "assert candidate([1,2,3,4])==False", "assert candidate([1,1,1,3,3,4,3,2,4,2])==True"], "test_function": "def test_run(content1):\n    return JTA().Judging_the_array(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JTA\", \"def Judging_the_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/71", "question": "First, implement the **JI** class using the Python language. Then, write a public function called **Judgment_Index** in the **JI** class to solve the following problem:\nProblem: Given an integer array **nums** and an integer **k**, determine if there are two distinct indices **i** and **j** in the array such that nums[i] == nums[j] and abs(i - j) <= k. If such indices exist, return True; otherwise, return False.", "test_list": ["assert candidate([1,2,3,1])==3", "assert candidate([1,0,1,1])==1", "assert candidate([1,2,3,1,2,3])==2"], "test_function": "def test_run(content1):\n    return JI().Judgment_Index(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JI\", \"def Judgment_Index\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/72", "question": "First, implement the **AC** class using the Python language. Then, write a public function called **Array_conditions** in the **AC** class to solve the following problem:\nProblem: Given an integer array **nums** and two integers **indexDiff** and **valueDiff**, find the index pair (i, j) that satisfies the following conditions:\n1. i != j;\n2. abs(i - j) <= indexDiff;\n3. abs(nums[i] - nums[j]) <= valueDiff.\n\nIf such a pair exists, return True; otherwise, return False.", "test_list": ["assert candidate([1,2,3,1],3,0)==True", "assert candidate([1,5,9,1,5,9],2,3)==False"], "test_function": "def test_run(content1,content2,content3):\n    return AC().Array_conditions(content1,content2,content3)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AC\", \"def Array_conditions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/73", "question": "First, implement the **FTLS** class using the Python language. Then, write a public function called **largest_square** in the **FTLS** class to solve the following problem:\nProblem: Given a 2D matrix consisting of '0' and '1', find the largest square that contains only '1' and return its area.", "test_list": ["assert candidate([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])==4", "assert candidate([[\"0\",\"1\"],[\"1\",\"0\"]])==1", "assert candidate([[\"0\"]])==0"], "test_function": "def test_run(content1):\n    return FTLS().Find_the_largest_square(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTLS\", \"def largest_square\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/74", "question": "First, implement the **CTMA** class using the Python language. Then, write a public function called **matrix_area** in the **CTMA** class to solve the following problem:\nProblem: Given two rectangles on a two-dimensional plane, each formed by lines parallel/vertical to the coordinate axes, calculate and return the total area covered by the two rectangles. Each rectangle is defined by the coordinates of its bottom-left vertex and top-right vertex:\n1. The first rectangle is defined by its bottom-left vertex (ax1, ay1) and top-right vertex (ax2, ay2).\n2. The second rectangle is defined by its bottom-left vertex (bx1, by1) and top-right vertex (bx2, by2).", "test_list": ["assert candidate(-3,0,3,4,0,-1,9,2)==45", "assert candidate(-2,-2,2,2,-2,-2,2,2)==16"], "test_function": "def test_run(content1,content2,content3,content4,content5,content6,content7,content8):\n    return CTMA().Calculate_the_matrix_area(content1,content2,content3,content4,content5,content6,content7,content8)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CTMA\", \"def matrix_area\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/75", "question": "First, implement the **TAC** class using the Python language. Then, write a public function named **The_array_contains** in the **TAC** class to solve the following problem:\nProblem: Given a sorted integer array **nums** with no duplicate elements, return a list of the smallest sorted range intervals that exactly cover all the numbers in the array. In other words, each element in **nums** should be covered by exactly one range interval, and there should be no number **x** that belongs to a range interval but not to **nums**. Each range interval [a, b] in the list should be output in the following format:\n1. **a->b** if a != b;\n2. **a** if a == b.", "test_list": ["assert candidate([0,1,2,4,5,7])==[\"0->2\",\"4->5\",\"7\"]", "assert candidate([0,2,3,4,6,8,9])==[\"0\",\"2->4\",\"6\",\"8->9\"]"], "test_function": "def test_run(content1):\n    return TAC().The_array_contains(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TAC\", \"def The_array_contains\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/76", "question": "First, implement the **GTAC** class using the Python language. Then, write a public function called **array_count** in the **GTAC** class to solve the following problem:\nProblem: Given an integer array of size **n**, find all elements that appear more than ⌊n/3⌋ times.", "test_list": ["assert candidate([3,2,3])==[3]", "assert candidate([1])==[1]", "assert candidate([1,2])==[1,2]"], "test_function": "def test_run(content1):\n    return GTAC().Get_the_array_count(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GTAC\", \"def array_count\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
