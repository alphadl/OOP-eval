{"task_id": "OOP/0", "question": "Question: Given an integer **n**, please find and return the n-th ugly number.\nPlease design a **ULYNB** class in Python language based on the above question. The class should have an instance attribute **n**, a private function **private_ugly_number**, and a public function **public_ugly_number**. In the private function **private_ugly_number**, find the n-th ugly number based on the instance attribute **n**. Finally, in the public function **public_ugly_number**, call the private function **private_ugly_number** and return the result.", "test_list": ["assert candidate(10)==12", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return ULYNB(content1).public_ugly_number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ULYNB\", \"def __init__(self, n)\", \"def _private_ugly_number\", \"def public_ugly_number\"], [\"class ULYNB\", \"def __init__(self, n)\", \"def __private_ugly_number\", \"def public_ugly_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/1", "question": "First, design a **NAR** class using Python language, which has instance attributes **nums**, a private function **private_Number_array**, and a public function **public_Number_array**. Then, in the private function **private_Number_array**, return the numbers in the range [0, n] that do not appear in the array **nums**. Finally, in the public function **public_Number_array**, call the private function **private_Number_array** to return the result.", "test_list": ["assert candidate([3,0,1])==2", "assert candidate([0,1])==2", "assert candidate([9,6,4,2,3,5,7,0,1])==8", "assert candidate([0])==1"], "test_function": "def test_run(content1):\n    return NAR(content1).public_Number_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NAR\", \"def __init__(self, nums)\", \"def _private_Number_array\",\"def public_Number_array\"], [\"class NAR\", \"def __init__(self, nums)\", \"def __private_Number_array\",\"def public_Number_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/2", "question": "First, design an **ERS** class using the Python language. The class should have an instance attribute called **num**, a private function called **private_rep**, and a public function called **public_rep**. In the private function **private_rep**, convert the non-negative integer **num** into its corresponding English representation. Finally, in the public function **public_rep**, call the private function **private_rep** and return the result.", "test_list": ["assert candidate(123)==\"One Hundred Twenty Three\"", "assert candidate(12345)==\"Twelve Thousand Three Hundred Forty Five\"", "assert candidate(1234567)==\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\""], "test_function": "def test_run(content1):\n    return ERS(content1).public_English_representation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ERS\", \"def __init__(self, num)\", \"def _private_rep\",\"def public_rep\"], [\"class ERS\", \"def __init__(self, num)\", \"def __private_rep\",\"def public_rep\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/3", "question": "First, design a **PCT** class using the Python language. The class should have instance attribute **citations**, a private function **private_Paper_cited**, and a public function **public_Paper_cited**. In the private function **private_Paper_cited**, which takes an integer array **citations** representing the number of times the researcher's i-th paper has been cited, return the researcher's h-index. Finally, in the public function **public_Paper_cited**, call the private function **private_Paper_cited** and return the result.", "test_list": ["assert candidate([3,0,6,1,5])==3", "assert candidate([1,3,1])==1"], "test_function": "def test_run(content1):\n    return PCT(content1).public_Paper_cited()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PCT\", \"def __init__(self, citations)\", \"def _private_Paper_cited\",\"def public_Paper_cited\"], [\"class PCT\", \"def __init__(self, citations)\", \"def __private_Paper_cited\",\"def public_Paper_cited\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/4", "question": "Question: Given an integer array **citations**, where citations[i] represents the number of times the i-th paper of a researcher has been cited, and **citations** are already sorted in ascending order. Calculate and return the researcher's h-index.\nPlease design an **AOD** class using Python language, which has an instance attribute **citations**, a private function **private_Paper_cited**, and a public function **public_ascend_order**. In the private function **private_Paper_cited**, return the researcher's h-index. Finally, in the public function **public_ascend_order**, call the private function **private_Paper_cited** and return the result.", "test_list": ["assert candidate([0,1,3,5,6])==3", "assert candidate([1,2,100])==2"], "test_function": "def test_run(content1):\n    return AOD(content1).public_ascend_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AOD\", \"def __init__(self, citations)\", \"def _private_ascend_order\",\"def public_ascend_order\"], [\"class AOD\", \"def __init__(self, citations)\", \"def __private_ascend_order\",\"def public_ascend_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/5", "question": "First, design a class named **MQT** using the Python language. The class should have an instance attribute **n**, a private function named **private_Minimum_quantity**, and a public function named **public_Minimum_quantity**. In the private function **private_Minimum_quantity**, return the minimum number of perfect squares that add up to the integer **n**. Finally, in the public function **public_Minimum_quantity**, call the private function **private_Minimum_quantity** and return the result.", "test_list": ["assert candidate(12)==3", "assert candidate(13)==2"], "test_function": "def test_run(content1):\n    return MQT(content1).public_Minimum_quantity()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MQT\", \"def __init__(self, n)\", \"def _private_Minimum_quantity\",\"def public_Minimum_quantity\"], [\"class MQT\", \"def __init__(self, n)\", \"def __private_Minimum_quantity\",\"def public_Minimum_quantity\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/6", "question": "Question: Given a string **num** that only contains digits 0-9, add binary operators (+, -, *) between the digits to form expressions. Return all the expressions that evaluate to the target integer **target**. \nPlease design a **BOT** class in Python, which has instance attributes **num** and **target**, a private function **private_Binary_operator**, and a public function **public_Binary_operator**. The private function **private_Binary_operator** should return all the expressions that evaluate to the target integer. Finally, the public function **public_Binary_operator** should call the private function **private_Binary_operator** and return the result.", "test_list": ["assert candidate(\"123\",6)==[\"1+2+3\", \"1*2*3\"]", "assert candidate(\"232\",8)==[\"2*3+2\", \"2+3*2\"]", "assert candidate(\"3456237490\",9191)==[]"], "test_function": "def test_run(content1,content2):\n    return BOT(content1,content2).public_Binary_operator()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BOT\", \"def __init__(self, num, target)\", \"def _private_Binary_operator\",\"def public_Binary_operator\"], [\"class BOT\", \"def __init__(self, num, target)\", \"def __private_Binary_operator\",\"def public_Binary_operator\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/7", "question": "First, design a **ROE** class using the Python language. The class should have an instance attribute called **nums**, a private function called **private_relative_order**, and a public function called **public_relative_order**. In the private function **private_relative_order**, move all the zeros in the array **nums** to the end while maintaining the relative order of the non-zero elements. Finally, in the public function **public_relative_order**, call the private function **private_relative_order** and return the result.", "test_list": ["assert candidate([0,1,0,3,12])==[1,3,12,0,0]", "assert candidate([0])==[0]"], "test_function": "def test_run(content1):\n    return ROE(content1).public_relative_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ROE\", \"def __init__(self, nums)\", \"def _private_relative_order\",\"def public_relative_order\"], [\"class ROE\", \"def __init__(self, nums)\", \"def _private_relative_order\",\"def public_relative_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/8", "question": "Question: Given an array **nums** containing n + 1 integers, where the numbers are within the range [1, n] (including 1 and n), it is known that at least one integer is duplicated. Assuming that **nums** only has one duplicated integer, return this duplicated number.\nPlease use Python to first design a class **NDC**, with an instance attribute **nums**, a private function **private_Number_duplicates**, and a public function **public_Number_duplicates**. Then, in the private function **private_Number_duplicates**, return this duplicated number. Finally, in the public function **public_Number_duplicates**, call the private function **private_Number_duplicates** to return the result.", "test_list": ["assert candidate([1,3,4,2,2])==2", "assert candidate([3,1,3,4,2])==3"], "test_function": "def test_run(content1):\n    return NDC(content1).public_Number_duplicates()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NDC\", \"def __init__(self, nums)\", \"def _private_Number_duplicates\",\"def public_Number_duplicates\"], [\"class NDC\", \"def __init__(self, nums)\", \"def __private_Number_duplicates\",\"def public_Number_duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/9", "question": "Firstly, design an **LSQ** class using Python language, which has an instance attribute **nums**, a private function **private_Longest_subsequence**, and a public function **public_Longest_subsequence**. Then, in the private function **private_Longest_subsequence**, return the length of the longest strictly increasing subsequence in the instance attribute integer array **nums**. Finally, in the public function **public_Longest_subsequence**, call the private function **private_Longest_subsequence** to return the result.", "test_list": ["assert candidate([10,9,2,5,3,7,101,18])==4", "assert candidate([0,1,0,3,2,3])==4", "assert candidate([7,7,7,7,7,7,7])==1"], "test_function": "def test_run(content1):\n    return LSQ(content1).public_Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LSQ\", \"def __init__(self, nums)\", \"def _private_Longest_subsequence\",\"def public_Longest_subsequence\"], [\"class LSQ\", \"def __init__(self, nums)\", \"def __private_Longest_subsequence\",\"def public_Longest_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/10", "question": "Question: Given a string 's' composed of several brackets and letters, delete the minimum number of invalid brackets to make the input string valid, and return all possible results.\nPlease use Python language to first design a 'VSR' class, with an instance attribute 's', a private function 'private_Valid_string', and a public function 'public_Valid_string'. Then, in the private function 'private_Valid_string', return all possible results of the above problem. Finally, call the private function 'private_Valid_string' in the public function 'public_Valid_string' to return the results.", "test_list": ["assert candidate(\"()())()\")==[\"(())()\",\"()()()\"]", "assert candidate(\"(a)())()\")==[\"(a())()\",\"(a)()()\"]", "assert candidate(\")(\")==[\"\"]"], "test_function": "def test_run(content1):\n    return VSR(content1).public_Valid_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VSR\", \"def __init__(self, s)\", \"def _private_Valid_string\",\"def public_Valid_string\"], [\"class VSR\", \"def __init__(self, s)\", \"def __private_Valid_string\",\"def public_Valid_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/11", "question": "Question: An accumulative number is a string, the numbers that make up it can form an accumulative sequence. A valid accumulative sequence must contain at least 3 numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of its previous two numbers. Given a string **s** that only contains digits '0'-'9', write an algorithm to determine whether the given input is an accumulative number. If it is, return True; otherwise, return False.\nPlease use Python language to first design an **ANB** class, which has an instance attribute **s**, a private function **private_Accumulated_number**, and a public function **public_Accumulated_number**; then in the private function **private_Accumulated_number**, determine whether the instance attribute **s** is an accumulative number, if it is, return True; otherwise, return False; finally, in the public function **public_Accumulated_number**, call the private function **private_Accumulated_number** to return the result.", "test_list": ["assert candidate(\"112358\")==True", "assert candidate(\"199100199\")==True"], "test_function": "def test_run(content1):\n    return ANB(content1).public_Accumulated_number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ANB\", \"def __init__(self, s)\", \"def _private_Accumulated_number\",\"def public_Accumulated_number\"], [\"class ANB\", \"def __init__(self, s)\", \"def __private_Accumulated_number\",\"def public_Accumulated_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/12", "question": "Firstly, design an **MCS** class using the Python language, which has an instance attribute **nums**, a private function **private_Maximum_coins**, and a public function **public_Maximum_coins**. Then, implement the following problem in the private function **private_Maximum_coins**. Finally, call the private function **private_Maximum_coins** in the public function **public_Maximum_coins** to return the result.\nProblem: Given **n** balloons each marked with a number from 0 to n-1, these numbers are stored in the array **nums**. You need to burst all the balloons. If you burst the i-th balloon, you can get nums[i-1]*nums[i]*nums[i+1] coins. Return the maximum number of coins that can be obtained.", "test_list": ["assert candidate([3,1,5,8])==167", "assert candidate([1,5])==10"], "test_function": "def test_run(content1):\n    return MCS(content1).public_Maximum_coins()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MCS\", \"def __init__(self, nums)\", \"def _private_Maximum_coins\",\"def public_Maximum_coins\"], [\"class MCS\", \"def __init__(self, nums)\", \"def __private_Maximum_coins\",\"def public_Maximum_coins\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/13", "question": "Firstly, design a **SNE** class using Python language, which has instance attributes **n** and **primes**, a private function **private_Super_Number**, and a public function **public_Super_Number**. Then, return the nth super ugly number in the private function **private_Super_Number**. Finally, call the private function **private_Super_Number** in the public function **public_Super_Number** to return the result.", "test_list": ["assert candidate(12,[2,7,13,19])==32", "assert candidate(1,[2,3,5])==1"], "test_function": "def test_run(content1,content2):\n    return SNE(content1,content2).public_Super_Number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SNE\", \"def __init__(self, n, primes)\", \"def _private_Super_Number\",\"def public_Super_Number\"], [\"class SNE\", \"def __init__(self, n, primes)\", \"def __private_Super_Number\",\"def public_Super_Number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/14", "question": "Firstly, design an **IAA** class using the Python language, which has an instance attribute **nums**, a private function **private_Integer_array**, and a public function **public_Integer_array**. Then, in the private function **private_Integer_array**, return a new array **counts** with the requirement that the value of counts[i] is the number of elements to the right of nums[i] that are less than nums[i]. Finally, call the private function **private_Integer_array** in the public function **public_Integer_array** to return the result.", "test_list": ["assert candidate([5,2,6,1])==[2,1,1,0]", "assert candidate([-1])==[0]", "assert candidate([-1,-1])==[0,0]"], "test_function": "def test_run(content1):\n    return IAA(content1).public_Integer_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IAA\", \"def __init__(self, nums)\", \"def _private_Integer_array\",\"def public_Integer_array\"], [\"class IAA\", \"def __init__(self, nums)\", \"def __private_Integer_array\",\"def public_Integer_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/15", "question": "Firstly, design a **DMM** class using Python language, which has an instance attribute **s**, a private function **private_Dictionary_minimum**, and a public function **public_Dictionary_minimum**. Then, in the private function **private_Dictionary_minimum**, remove the duplicate letters in the string **s** so that each letter only appears once, and return the result with the smallest lexicographic order. Finally, in the public function **public_Dictionary_minimum**, call the private function **private_Dictionary_minimum** to return the result.", "test_list": ["assert candidate(\"bcabc\")==\"abc\"", "assert candidate(\"cbacdcbc\")==\"acdb\""], "test_function": "def test_run(content1):\n    return DMM(content1).public_Dictionary_minimum()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DMM\", \"def __init__(self, s)\", \"def _private_Dictionary_minimum\",\"def public_Dictionary_minimum\"], [\"class DMM\", \"def __init__(self, s)\", \"def __private_Dictionary_minimum\",\"def public_Dictionary_minimum\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/16", "question": "Firstly, design a **CLS** class using the Python language, which has an instance attribute **words**, a private function **private_Common_letters**, and a public function **public_Common_letters**. Then, in the private function **private_Common_letters**, return the maximum value of length(words[i])*length(words[j]). Finally, in the public function **public_Common_letters**, call the private function **private_Common_letters** to return the result.", "test_list": ["assert candidate([\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"])==16", "assert candidate([\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"])==4", "assert candidate([\"a\",\"aa\",\"aaa\",\"aaaa\"])==0"], "test_function": "def test_run(content1):\n    return CLS(content1).public_Common_letters()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CLS\", \"def __init__(self, words)\", \"def _private_Common_letters\",\"def public_Common_letters\"], [\"class CLS\", \"def __init__(self, words)\", \"def __private_Common_letters\",\"def public_Common_letters\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/17", "question": "Firstly, design a class named **ROD** using Python language, which has instance attributes **nums1**, **nums2**, and **k**, a private function **private_relative_order**, and a public function **public_relative_order**. Then, implement the following problem in the private function **private_relative_order**. Finally, call the private function **private_relative_order** in the public function **public_relative_order** to return the result.\nProblem: Select **k** (k<=m+n) numbers from two given arrays of length **m** and **n** respectively to form a new number. The numbers taken from the same array should maintain their relative order in the original array. Return an array of length **k** representing the maximum number.", "test_list": ["assert candidate([3, 4, 6, 5],[9, 1, 2, 5, 8, 3],5)==[9, 8, 6, 5, 3]", "assert candidate([6, 7],[6, 0, 4],5)==[6, 7, 6, 0, 4]", "assert candidate([3, 9],[8, 9],3)==[9, 8, 9]"], "test_function": "def test_run(content1,content2,content3):\n    return ROD(content1,content2,content3).public_relative_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ROD\", \"def __init__(self, nums1, nums2, k)\", \"def _private_relative_order\",\"def public_relative_order\"], [\"class ROD\", \"def __init__(self, nums1, nums2, k)\", \"def __private_relative_order\",\"def public_relative_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/18", "question": "Firstly, design a **TAU** class using Python language, which has instance attributes **coins** and **amount**, a private function **private_Total_amount**, and a public function **public_Total_amount**. Then, in the private function **private_Total_amount**, provide an integer array **coins** representing different denominations of coins and an integer **amount** representing the total amount, and return the minimum number of coins required to make up the total amount. Finally, call the private function **private_Total_amount** in the public function **public_Total_amount** to return the result.", "test_list": ["assert candidate([1, 2, 5],11)==3", "assert candidate([2],3)==-1", "assert candidate([1],0)==0"], "test_function": "def test_run(content1,content2):\n    return TAU(content1,content2).public_Total_amount()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TAU\", \"def __init__(self, coins, amount)\", \"def _private_Total_amount\",\"def public_Total_amount\"], [\"class TAU\", \"def __init__(self, coins, amount)\", \"def __private_Total_amount\",\"def public_Total_amount\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/19", "question": "Firstly, design a **ROR** class using Python language, which has an instance attribute **nums**, a private function **private_Rearranged_order**, and a public function **public_Rearranged_order**. Then, in the private function **private_Rearranged_order**, rearrange the integer array **nums** into the order of nums[0]<nums[1]>nums[2]<nums[3]... Finally, call the private function **private_Rearranged_order** in the public function **public_Rearranged_order** to return the result.", "test_list": ["assert candidate([1,5,1,1,6,4])==[1,6,1,5,1,4]", "assert candidate([1,3,2,2,3,1])==[2,3,1,3,1,2]"], "test_function": "def test_run(content1):\n    return ROR(content1).public_Rearranged_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ROR\", \"def __init__(self, nums)\", \"def _private_Rearranged_order\",\"def public_Rearranged_order\"], [\"class ROR\", \"def __init__(self, nums)\", \"def __private_Rearranged_order\",\"def public_Rearranged_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/20", "question": "Firstly, design an **IAN** class using the Python language, which has instance attributes **nums**, **lower**, and **upper**, a private function **private_Interval_and**, and a public function **public_Interval_and**. Then, in the private function **private_Interval_and**, return the count of interval sums within the range [lower, upper] (inclusive of **lower** and **upper**) from the integer array **nums**. Finally, in the public function **public_Interval_and**, call the private function **private_Interval_and** to return the result.", "test_list": ["assert candidate([-2,5,-1],-2,2)==3", "assert candidate([0],0,0)==1"], "test_function": "def test_run(content1,content2,content3):\n    return IAN(content1,content2,content3).public_Interval_and()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IAN\", \"def __init__(self, nums, lower, upper)\", \"def _private_Interval_and\",\"def public_Interval_and\"], [\"class IAN\", \"def __init__(self, nums, lower, upper)\", \"def __private_Interval_and\",\"def public_Interval_and\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/21", "question": "Firstly, design a class named **LIM** using Python language, which has an instance attribute **matrix**, a private function **private_Longest_Incremental**, and a public function **public_Longest_Incremental**. Then, in the private function **private_Longest_Incremental**, return the length of the longest incremental path in the given m x n integer **matrix**. Finally, call the private function **private_Longest_Incremental** in the public function **public_Longest_Incremental** to return the result.", "test_list": ["assert candidate([[9,9,4],[6,6,8],[2,1,1]])==4", "assert candidate([[3,4,5],[3,2,6],[2,2,1]])==4", "assert candidate([[1]])==1"], "test_function": "def test_run(content1):\n    return LIM(content1).public_Longest_Incremental()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LIM\", \"def __init__(self, matrix)\", \"def _private_Longest_Incremental\",\"def public_Longest_Incremental\"], [\"class LIM\", \"def __init__(self, matrix)\", \"def __private_Longest_Incremental\",\"def public_Longest_Incremental\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/22", "question": "Question: Given a sorted array of positive integers **nums**, and a positive integer **n**. Select any number from the interval [1, n] to supplement to **nums**, so that any number in the interval [1, n] can be represented by the sum of several numbers in **nums**. Please return the minimum number of numbers that need to be supplemented to meet the above requirements.\nPlease use Python language to design an **NDT** class first, with instance attributes **nums** and **n**, a private function **private_Number_digits**, and a public function **public_Number_digits**; then return the minimum number of numbers that need to be supplemented in the private function **private_Number_digits**; finally, call the private function **private_Number_digits** in the public function **public_Number_digits** to return the result.", "test_list": ["assert candidate([1,3],6)==1", "assert candidate([1,5,10],20)==2", "assert candidate([1,2,2],5)==0"], "test_function": "def test_run(content1,content2):\n    return NDT(content1,content2).public_Number_digits()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NDT\", \"def __init__(self, nums, n)\", \"def _private_Number_digits\",\"def public_Number_digits\"], [\"class NDT\", \"def __init__(self, nums, n)\", \"def __private_Number_digits\",\"def public_Number_digits\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/23", "question": "Question: Given an integer array **nums**, determine whether there exists a length-3 increasing subsequence in this array. If there exists such a triplet index (i, j, k) and satisfies i < j < k, such that nums[i] < nums[j] < nums[k], return True; otherwise, return False.\nPlease use Python language to first design a **LSU** class, with instance attribute **nums**, private function **private_Longest_subsequence** and public function **public_Longest_subsequence**; then in the private function **private_Longest_subsequence**, determine whether there exists a length-3 increasing subsequence in the integer array **nums**, if it exists, return True; otherwise, return False; finally, in the public function **public_Longest_subsequence**, call the private function **private_Longest_subsequence** to return the result.", "test_list": ["assert candidate([1,2,3,4,5])==True", "assert candidate([5,4,3,2,1])==False", "assert candidate([2,1,5,0,4,6])==True"], "test_function": "def test_run(content1):\n    return LSU(content1).public_Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LSU\", \"def __init__(self, nums)\", \"def _private_Longest_subsequence\",\"def public_Longest_subsequence\"], [\"class LSU\", \"def __init__(self, nums)\", \"def __private_Longest_subsequence\",\"def public_Longest_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/24", "question": "Firstly, design a class **CVA** using the Python language, which has an instance attribute **distance**, a private function **private_Counterclockwise_variation**, and a public function **public_Counterclockwise_variation**. Then, implement the following problem in the private function **private_Counterclockwise_variation**. Finally, call the private function **private_Counterclockwise_variation** in the public function **public_Counterclockwise_variation** to return the result.\n\nProblem: Given an integer array **distance**. Starting from the point (0,0) on the X-Y plane, each time a move is made with a counterclockwise change in direction, determine whether the path crossed. If it intersects, return True; otherwise, return False.", "test_list": ["assert candidate([2,1,1,2])==True", "assert candidate([1,2,3,4])==False", "assert candidate([1,1,1,1])==True"], "test_function": "def test_run(content1):\n    return CVA(content1).public_Counterclockwise_variation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CVA\", \"def __init__(self, distance)\", \"def _private_Counterclockwise_variation\",\"def public_Counterclockwise_variation\"], [\"class CVA\", \"def __init__(self, distance)\", \"def __private_Counterclockwise_variation\",\"def public_Counterclockwise_variation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/25", "question": "Firstly, design a **USI** class using Python language, which has an instance attribute **words**, a private function **private_Unique_String**, and a public function **public_Unique_String**. Then, in the private function **private_Unique_String**, return an array of strings from **words** that satisfy the palindrome pair condition, which is composed of unique strings in a 0-indexed array. Finally, call the private function **private_Unique_String** in the public function **public_Unique_String** to return the result.", "test_list": ["assert candidate([\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"])==[[0,1],[1,0],[3,2],[2,4]]", "assert candidate([\"bat\",\"tab\",\"cat\"])==[[0,1],[1,0]]", "assert candidate([\"a\",\"\"])==[[0,1],[1,0]]"], "test_function": "def test_run(content1):\n    return USI(content1).public_Unique_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class USI\", \"def __init__(self, words)\", \"def _private_Unique_String\",\"def public_Unique_String\"], [\"class USI\", \"def __init__(self, words)\", \"def __private_Unique_String\",\"def public_Unique_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/26", "question": "Firstly, design a **PMM** class using Python language, which has an instance attribute **n**, a private function **private_Product_maximization**, and a public function **public_Product_maximization**. Then, in the private function **private_Product_maximization**, decompose the positive integer **n** into the sum of **k** positive integers (k>=2), and maximize the product of these integers, returning the maximum product that can be obtained. Finally, call the private function **private_Product_maximization** in the public function **public_Product_maximization** to return the result.", "test_list": ["assert candidate(2)==1", "assert candidate(10)==36"], "test_function": "def test_run(content1):\n    return PMM(content1).public_Product_maximization()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PMM\", \"def __init__(self, n)\", \"def _private_Product_maximization\",\"def public_Product_maximization\"], [\"class PMM\", \"def __init__(self, n)\", \"def __private_Product_maximization\",\"def public_Product_maximization\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/27", "question": "Firstly, design an **RSI** class using Python language, which has an instance attribute **s**, a private function **private_Result_String**, and a public function **public_Result_String**. Then, in the private function **private_Result_String**, reverse all the vowel letters in the string **s** and return the result string. Finally, in the public function **public_Result_String**, call the private function **private_Result_String** to return the result.", "test_list": ["assert candidate(\"hello\")==\"holle\"", "assert candidate(\"leetcode\")==\"leotcede\""], "test_function": "def test_run(content1):\n    return RSI(content1).public_Result_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RSI\", \"def __init__(self, s)\", \"def _private_Result_String\",\"def public_Result_String\"], [\"class RSI\", \"def __init__(self, s)\", \"def __private_Result_String\",\"def public_Result_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/28", "question": "Firstly, design an **AOER** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Any_order**, and a public function **public_Any_order**. Then, in the private function **private_Any_order**, return the top k most frequent elements in the integer array **nums**. Finally, in the public function **public_Any_order**, call the private function **private_Any_order** to return the result.", "test_list": ["assert candidate([1,1,1,2,2,3],2)==[1,2]", "assert candidate([1],1)==[1]"], "test_function": "def test_run(content1,content2):\n    return AOER(content1,content2).public_Any_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AOER\", \"def __init__(self, nums, k)\", \"def _private_Any_order\",\"def public_Any_order\"], [\"class AOER\", \"def __init__(self, nums, k)\", \"def __private_Any_order\",\"def public_Any_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/29", "question": "First, design a **TIE** class using the Python language, which has instance attributes **nums1** and **nums2**, a private function **private_Their_intersection**, and a public function **public_Their_intersection**. Then, in the private function **private_Their_intersection**, return the intersection between the arrays **nums1** and **nums2**. Finally, in the public function **public_Their_intersection**, call the private function **private_Their_intersection** to return the result.", "test_list": ["assert candidate([1,2,2,1],[2,2])==[2]", "assert candidate([4,9,5],[9,4,9,8,4])==[9,4]"], "test_function": "def test_run(content1,content2):\n    return TIE(content1,content2).public_Their_intersection()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TIE\", \"def __init__(self, nums1, nums2)\", \"def _private_Their_intersection\",\"def public_Their_intersection\"], [\"class TIE\", \"def __init__(self, nums1, nums2)\", \"def __private_Their_intersection\",\"def public_Their_intersection\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/30", "question": "Question: Given two integer arrays **nums1** and **nums2**, please return the intersection of the two arrays in the form of an array. The number of times each element appears in the return result should be consistent with the number of times the element appears in both arrays (if the number of appearances is inconsistent, consider taking the smaller value).\nUsing Python language, first design an **ORU** class, which has instance attributes **nums1** and **nums2**, a private function **private_Order_results**, and a public function **public_Order_results**. Then, implement the above problem in the private function **private_Order_results**. Finally, call the private function **private_Order_results** in the public function **public_Order_results** to return the result.", "test_list": ["assert candidate([1,2,2,1],[2,2])==[2,2]", "assert candidate([4,9,5],[9,4,9,8,4])==[4,9]"], "test_function": "def test_run(content1,content2):\n    return ORU(content1,content2).public_Order_results()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ORU\", \"def __init__(self, nums1, nums2)\", \"def _private_Order_results\",\"def public_Order_results\"], [\"class ORU\", \"def __init__(self, nums1, nums2)\", \"def __private_Order_results\",\"def public_Order_results\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/31", "question": "Firstly, design an **RDL** class using the Python language, which has an instance attribute **envelopes**, a private function **private_Russian_dolls**, and a public function **public_Russian_dolls**. Then, implement the following problem in the private function **private_Russian_dolls**. Finally, call the private function **private_Russian_dolls** in the public function **public_Russian_dolls** to return the result.\nProblem: Given a two-dimensional integer array envelopes[i]=[w_i,h_i] representing the width and height of the i-th envelope, return the maximum number of envelopes that can form a set of **Russian nesting dolls**.", "test_list": ["assert candidate([[5,4],[6,4],[6,7],[2,3]])==3", "assert candidate([[1,1],[1,1],[1,1]])==1"], "test_function": "def test_run(content1):\n    return RDL(content1).public_Russian_dolls()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RDL\", \"def __init__(self, envelopes)\", \"def _private_Russian_dolls\",\"def public_Russian_dolls\"], [\"class RDL\", \"def __init__(self, envelopes)\", \"def __private_Russian_dolls\",\"def public_Russian_dolls\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/32", "question": "Firstly, design an **NDE** class using Python language, which has an instance attribute **n**, a private function **private_Numbers_different**, and a public function **public_Numbers_different**. Then, implement the following problem in the private function **private_Numbers_different**. Finally, call the private function **private_Numbers_different** in the public function **public_Numbers_different** to return the result.\nProblem: Given an integer **n**, you need to return the count of numbers **x** where all digits are different, and 0<=x<10^n.", "test_list": ["assert candidate(2)==91", "assert candidate(0)==1"], "test_function": "def test_run(content1):\n    return NDE(content1).public_Numbers_different()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NDE\", \"def __init__(self, n)\", \"def _private_Numbers_different\",\"def public_Numbers_different\"], [\"class NDE\", \"def __init__(self, n)\", \"def __private_Numbers_different\",\"def public_Numbers_different\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/33", "question": "Firstly, design a class named **MVL** using Python language, which has instance attributes **matrix** and **k**, a private function **private_Maximum_value**, and a public function **public_Maximum_value**. Then, in the private function **private_Maximum_value**, return the maximum sum of values within the rectangular area of the m x n **matrix** that does not exceed **k**. Finally, in the public function **public_Maximum_value**, call the private function **private_Maximum_value** to return the result.", "test_list": ["assert candidate([[1,0,1],[0,-2,3]],2)==2", "assert candidate([[2,2,-1]],3)==3"], "test_function": "def test_run(content1,content2):\n    return MVL(content1,content2).public_Maximum_value()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MVL\", \"def __init__(self, matrix, k)\", \"def _private_Maximum_value\",\"def public_Maximum_value\"], [\"class MVL\", \"def __init__(self, matrix, k)\", \"def __private_Maximum_value\",\"def public_Maximum_value\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/34", "question": "Firstly, design a **DSS** class using Python language, which has an instance attribute **nums**, a private function **private_Divisible_subset**, and a public function **public_Divisible_subset**. Then, in the private function **private_Divisible_subset**, given a set **nums** composed of non-repetitive positive integers, return the largest divisible subset **answer**. Finally, in the public function **public_Divisible_subset**, call the private function **private_Divisible_subset** to return the result.", "test_list": ["assert candidate([1,2,3])==[1,2]", "assert candidate([1,2,4,8])==[1,2,4,8]"], "test_function": "def test_run(content1):\n    return DSS(content1).public_Divisible_subset()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DSS\", \"def __init__(self, nums)\", \"def _private_Divisible_subset\",\"def public_Divisible_subset\"], [\"class DSS\", \"def __init__(self, nums)\", \"def __private_Divisible_subset\",\"def public_Divisible_subset\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/35", "question": "Question: Calculate **a^b mod 1337**, where **a** is a positive integer and **b** is a very large positive integer given in the form of an array.\nUse Python language to first design a **PIT** class, with instance attributes **a** and **b**, a private function **private_positive_integer**, and a public function **public_positive_integer**. Then, calculate the above problem in the private function **private_positive_integer**. Finally, call the private function **private_positive_integer** in the public function **public_positive_integer** to return the result.", "test_list": ["assert candidate(2,[3])==8", "assert candidate(2,[1,0])==1024", "assert candidate(1,[4,3,3,8,5,2])==1", "assert candidate(2147483647,[2,0,0])==1198"], "test_function": "def test_run(content1,content2):\n    return PIT(content1,content2).public_positive_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PIT\", \"def __init__(self, a, b)\", \"def _private_positive_integer\",\"def public_positive_integer\"], [\"class PIT\", \"def __init__(self, a, b)\", \"def __private_positive_integer\",\"def public_positive_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/36", "question": "Question: Given two integer arrays **nums1** and **nums2** sorted in non-decreasing order, and an integer **k**. Define a pair of values (u, v), where the first element comes from **nums1** and the second element comes from **nums2**. Please find the pairs with the smallest sum (u1, v1), (u2, v2)...(uk, vk) for the first **k** pairs.\nPlease use Python to first design a **DAG** class, with instance attributes **nums1**, **nums2** and **k**, a private function **private_decreasing_arrangement**, and a public function **public_decreasing_arrangement**. Then, implement the above problem in the private function **private_decreasing_arrangement**. Finally, call the private function **private_decreasing_arrangement** in the public function **public_decreasing_arrangement** to return the result.", "test_list": ["assert candidate([1,7,11],[2,4,6],3)==[1,2],[1,4],[1,6]", "assert candidate([1,1,2],[1,2,3],2)==[1,1],[1,1]", "assert candidate([1,2],[3],3)==[1,3],[2,3]"], "test_function": "def test_run(content1,content2,content3):\n    return DAG(content1,content2,content3).public_decreasing_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DAG\", \"def __init__(self, nums1, nums2, k)\", \"def _private_decreasing_arrangement\",\"def public_decreasing_arrangement\"], [\"class DAG\", \"def __init__(self, nums1, nums2, k)\", \"def __private_decreasing_arrangement\",\"def public_decreasing_arrangement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/37", "question": "First, design an **NBGG** class using the Python language, which has an instance attribute **n**, a private function **private_Guessing_Game**, and a public function **public_Guessing_Game**. Then, call the private function **private_ugly_number** in the public function **public_Guessing_Game** to return the result. The following problem is implemented in the private function **private_Guessing_Game**.\nProblem: Choose a number between 1 and **n** for a guessing game. If you guess the correct number, you win the game; otherwise, you will be told that the current number I chose is larger or smaller, and you continue to guess. When you guess the number **x** and get it wrong, you need to pay cash equal to **x**. If you run out of money, you lose the game. Given a specific number **n**, return the minimum amount of cash that can ensure victory.", "test_list": ["assert candidate(10)==16", "assert candidate(1)==0", "assert candidate(2)==1"], "test_function": "def test_run(content1):\n    return NBGG(content1).public_Guessing_Game()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NBGG\", \"def __init__(self, n)\", \"def _private_Guessing_Game\",\"def public_Guessing_Game\"], [\"class NBGG\", \"def __init__(self, n)\", \"def __private_Guessing_Game\",\"def public_Guessing_Game\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/38", "question": "Firstly, design an **LSS** class using Python language, which has an instance attribute **nums**, a private function **private_Longest_subsequence**, and a public function **public_Longest_subsequence**. Then, in the private function **private_Longest_subsequence**, return the length of the longest subsequence in the integer array **nums** that serves as a wiggle sequence. Finally, in the public function **public_Longest_subsequence**, call the private function **private_Longest_subsequence** to return the result.", "test_list": ["assert candidate([1,7,4,9,2,5])==6", "assert candidate([1,17,5,10,13,15,10,5,16,8])==7", "assert candidate([1,2,3,4,5,6,7,8,9])==2"], "test_function": "def test_run(content1):\n    return LSS(content1).public_Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LSS\", \"def __init__(self, nums)\", \"def _private_Longest_subsequence\",\"def public_Longest_subsequence\"], [\"class LSS\", \"def __init__(self, nums)\", \"def __private_Longest_subsequence\",\"def public_Longest_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/39", "question": "Question: Given an array **nums** composed of distinct integers and a target integer **target**, please find and return the number of combinations in **nums** that sum up to **target**. \nPlease use Python language to first design an **EAC** class, with instance attributes **nums** and **target**, a private function **private_element_association**, and a public function **public_element_association**. Then, implement the above problem in the private function **private_element_association**. Finally, call the private function **private_element_association** in the public function **public_element_association** to return the result.", "test_list": ["assert candidate([1,2,3],4)==7", "assert candidate([9],3)==0"], "test_function": "def test_run(content1,content2):\n    return EAC(content1,content2).public_element_association()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EAC\", \"def __init__(self, nums, target)\", \"def _private_element_association\",\"def public_element_association\"], [\"class EAC\", \"def __init__(self, nums, target)\", \"def __private_element_association\",\"def public_element_association\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/40", "question": "Question: Given an n x n matrix **matrix**, where each row and column elements are sorted in ascending order, find the k-th smallest element in the matrix.\nPlease use Python to first design a **SAS** class, with instance attributes **matrix** and **k**, a private function **private_Sort_ascending**, and a public function **public_Sort_ascending**. Then, implement the above problem in the private function **private_Sort_ascending**. Finally, call the private function **private_Sort_ascending** in the public function **public_Sort_ascending** to return the result.", "test_list": ["assert candidate([[1,5,9],[10,11,13],[12,13,15]],8)==13", "assert candidate([[-5]],1)==-5"], "test_function": "def test_run(content1,content2):\n    return SAS(content1,content2).public_Sort_ascending()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SAS\", \"def __init__(self, matrix, k)\", \"def _private_Sort_ascending\",\"def public_Sort_ascending\"], [\"class SAS\", \"def __init__(self, matrix, k)\", \"def __private_Sort_ascending\",\"def public_Sort_ascending\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/41", "question": "Question: Given a string **s** representing a **NestedInteger** of integers, implement a parser to parse it and return the parsed result as **NestedInteger**. \nPlease use Python to first design an **INT** class, which has an instance attribute **s**, a private function **private_Integer_nesting**, and a public function **public_Integer_nesting**. Then, implement the above problem in the private function **private_Integer_nesting**. Finally, call the private function **private_Integer_nesting** in the public function **public_Integer_nesting** to return the result.", "test_list": ["assert candidate(\"324\")==324", "assert candidate(\"[123,[456,[789]]]\")==[123,[456,[789]]]"], "test_function": "def test_run(content1):\n    return INT(content1).public_Integer_nesting()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class INT\", \"def __init__(self, s)\", \"def _private_Integer_nesting\",\"def public_Integer_nesting\"], [\"class INT\", \"def __init__(self, s)\", \"def _private_Integer_nesting\",\"def public_Integer_nesting\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/42", "question": "Firstly, design a class named **DOD** using Python language, which has an instance attribute **n**, a private function **private_Dictionary_order**, and a public function **public_Dictionary_order**. Then, in the private function **private_Dictionary_order**, return all integers within the range [1, n] in dictionary order. Finally, in the public function **public_Dictionary_order**, call the private function **private_Dictionary_order** to return the result.", "test_list": ["assert candidate(13)==[1,10,11,12,13,2,3,4,5,6,7,8,9]", "assert candidate(2)==[1,2]"], "test_function": "def test_run(content1):\n    return DOD(content1).public_Dictionary_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DOD\", \"def __init__(self, n)\", \"def _private_Dictionary_order\",\"def public_Dictionary_order\"], [\"class DOD\", \"def __init__(self, n)\", \"def __private_Dictionary_order\",\"def public_Dictionary_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/43", "question": "Question: Given two strings **s** and **t**, they only contain lowercase letters. String **t** is randomly rearranged from string **s**, and then a letter is added at a random position. Please find the letter added in **t**.\nPlease use Python language to first design a **RAI** class, with instance attributes **s** and **t**, a private function **private_Random_addition**, and a public function **public_Random_addition**; then implement the above problem in the private function **private_Random_addition**; finally, call the private function **private_Random_addition** in the public function **public_Random_addition** to return the result.", "test_list": ["assert candidate(\"abcd\",\"abcde\")==\"e\"", "assert candidate(\"\",\"y\")==\"y\""], "test_function": "def test_run(content1,content2):\n    return RAI(content1,content2).public_Random_addition()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RAI\", \"def __init__(self, s, t)\", \"def _private_Random_addition\",\"def public_Random_addition\"], [\"class RAI\", \"def __init__(self, s, t)\", \"def __private_Random_addition\",\"def public_Random_addition\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/44", "question": "Firstly, design an **RNE** class using Python language, which has an instance attribute **n**, a private function **private_remaining_numbers**, and a public function **public_remaining_numbers**. Then, implement the following problem in the private function **private_remaining_numbers**. Finally, call the private function **private_remaining_numbers** in the public function **public_remaining_numbers** to return the result.\nProblem: The given list **arr** consists of all integers in the range [1, n] and is strictly sorted in ascending order. You need to delete the first number of **arr** from left to right, then delete a number every other number until you reach the end of the list, then repeat the above steps from right to left. Keep repeating these two steps until only one number is left. Given an integer **n**, you are required to return the last remaining number in **arr**.", "test_list": ["assert candidate(9)==6", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return RNE(content1).public_remaining_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RNE\", \"def __init__(self, n)\", \"def _private_remaining_numbers\",\"def public_remaining_numbers\"], [\"class RNE\", \"def __init__(self, n)\", \"def __private_remaining_numbers\",\"def public_remaining_numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/45", "question": "Firstly, design a **PCN** class using Python language, which has an instance attribute **rectangles**, a private function **private_Parallel_coordinate**, and a public function **public_Parallel_coordinate**. Then, implement the following problem in the private function **private_Parallel_coordinate**. Finally, call the private function **private_Parallel_coordinate** in the public function **public_Parallel_coordinate** to return the result.\nProblem: Given an array rectangles[i] = [x_i, y_i, a_i, b_i] representing a rectangle parallel to the coordinate axis, where the lower left vertex is (x_i, y_i) and the upper right vertex is (a_i, b_i), determine whether all rectangles together exactly cover a certain rectangular area. If so, return **True**; otherwise, return **False**.", "test_list": ["assert candidate([[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]])==True", "assert candidate([[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]])==False", "assert candidate([[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]])==False"], "test_function": "def test_run(content1):\n    return PCN(content1).public_Parallel_coordinate()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PCN\", \"def __init__(self, rectangles)\", \"def _private_Parallel_coordinate\",\"def public_Parallel_coordinate\"], [\"class PCN\", \"def __init__(self, rectangles)\", \"def __private_Parallel_coordinate\",\"def public_Parallel_coordinate\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/46", "question": "Firstly, design a **VED** class using Python language, which has an instance attribute **data**, a private function **private_Valid_encoding**, and a public function **public_Valid_encoding**. Then, implement the following problem in the private function **private_Valid_encoding**. Finally, call the private function **private_Valid_encoding** in the public function **public_Valid_encoding** to return the result.\nProblem: Given an integer array **data** representing data, return whether it is a valid UTF-8 encoding. Characters in UTF-8 need to follow the following rules: For a 1-byte character, the first bit of the byte is set to 0, and the following 7 bits are the unicode code of this symbol. For an n-byte character (n>1), the first n bits of the first byte are all set to 1, the n+1 bit is set to 0, and the first two bits of the following bytes are all set to 10. The remaining unmentioned binary bits are all the unicode code of this symbol.", "test_list": ["assert candidate([197,130,1])==True", "assert candidate([235,140,4])==False"], "test_function": "def test_run(content1):\n    return VED(content1).public_Valid_encoding()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VED\", \"def __init__(self, data)\", \"def _private_Valid_encoding\",\"def public_Valid_encoding\"], [\"class VED\", \"def __init__(self, data)\", \"def __private_Valid_encoding\",\"def public_Valid_encoding\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/47", "question": "Firstly, design a class **LST** using the Python language, which has instance attributes **s** and **k**, a private function **private_Longest_substring**, and a public function **public_Longest_substring**. Then, in the private function **private_Longest_substring**, return the length of the longest substring in the string **s** where each character appears no less than **k** times. Finally, in the public function **public_Longest_substring**, call the private function **private_Longest_substring** to return the result.", "test_list": ["assert candidate(\"aaabb\",3)==3", "assert candidate(\"ababbc\",2)==5"], "test_function": "def test_run(content1,content2):\n    return LST(content1,content2).public_Longest_substring()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LST\", \"def __init__(self, s, k)\", \"def _private_Longest_substring\",\"def public_Longest_substring\"], [\"class LST\", \"def __init__(self, s, k)\", \"def __private_Longest_substring\",\"def public_Longest_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/48", "question": "Firstly, design a **CRT** class using Python language, which has an instance attribute **nums**, a private function **private_clockwise_rotation**, and a public function **public_clockwise_rotation**. Then, implement the following problem in the private function **private_clockwise_rotation**. Finally, call the private function **private_clockwise_rotation** in the public function **public_clockwise_rotation** to return the result.\nProblem: Suppose **arrk** is the array after the integer array **nums** of length **n** is rotated **k** positions clockwise, we define the rotation function **F** of **nums** as: F(k)=0*arrk[0]+1*arrk[1]+...+(n-1)*arrk[n-1]. You need to return the maximum value among F(0), F(1), ..., F(n-1).", "test_list": ["assert candidate([4,3,2,6])==26", "assert candidate([100])==0"], "test_function": "def test_run(content1):\n    return CRT(content1).public_clockwise_rotation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CRT\", \"def __init__(self, nums)\", \"def _private_clockwise_rotation\",\"def public_clockwise_rotation\"], [\"class CRT\", \"def __init__(self, nums)\", \"def __private_clockwise_rotation\",\"def public_clockwise_rotation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/49", "question": "Firstly, design an **MRC** class using Python language, which has an instance attribute **n**, a private function **private_Minimum_replacements**, and a public function **public_Minimum_replacements**. Then, in the private function **private_Minimum_replacements**, given a positive integer **n**, if **n** is even, replace **n** with **n/2**. If **n** is odd, replace **n** with **n+1** or **n-1**. Return the minimum number of replacements required for **n** to become 1. Finally, in the public function **public_Minimum_replacements**, call the private function **private_Minimum_replacements** to return the result.", "test_list": ["assert candidate(8)==3", "assert candidate(7)==4", "assert candidate(4)==2"], "test_function": "def test_run(content1):\n    return MRC(content1).public_Minimum_replacements()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MRC\", \"def __init__(self, n)\", \"def _private_Minimum_replacements\",\"def public_Minimum_replacements\"], [\"class MRC\", \"def __init__(self, n)\", \"def __private_Minimum_replacements\",\"def public_Minimum_replacements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/50", "question": "Firstly, design an **IIG** class using Python language, which has an instance attribute **n**, a private function **private_Infinite_integers**, and a public function **public_Infinite_integers**. Then, in the private function **private_Infinite_integers**, return the number at the n-th position in the infinite integer sequence [1,2,3,4,5,6,7,8,9,10,11,...]. Finally, call the private function **private_Infinite_integers** in the public function **public_Infinite_integers** to return the result.", "test_list": ["assert candidate(3)==3", "assert candidate(11)==0"], "test_function": "def test_run(content1):\n    return IIG(content1).public_Infinite_integers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IIG\", \"def __init__(self, n)\", \"def _private_Infinite_integers\",\"def public_Infinite_integers\"], [\"class IIG\", \"def __init__(self, n)\", \"def __private_Infinite_integers\",\"def public_Infinite_integers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/51", "question": "Question: Given a non-negative integer **num** represented as a string and an integer **k**, remove **k** digits from the number so that the remaining number is the smallest. Please return this smallest number in string form.\nUsing Python, first design a **SNU** class, which has instance attributes **num** and **k**, a private function **private_smallest_number**, and a public function **public_smallest_number**. Then implement the above problem in the private function **private_smallest_number**. Finally, call the private function **private_smallest_number** in the public function **public_smallest_number** to return the result.", "test_list": ["assert candidate(\"1432219\",3)==\"1219\"", "assert candidate(\"10200\",1)==\"200\"", "assert candidate(\"10\",2)==\"0\""], "test_function": "def test_run(content1,content2):\n    return SNU(content1,content2).public_smallest_number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SNU\", \"def __init__(self, num, k)\", \"def _private_smallest_number\",\"def public_smallest_number\"], [\"class SNU\", \"def __init__(self, num, k)\", \"def __private_smallest_number\",\"def public_smallest_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/52", "question": "First, design an **RQU** class using the Python language, which has an instance attribute **people**, a private function **private_Rank_queue**, and a public function **public_Rank_queue**. Then, implement the following problem in the private function **private_Rank_queue**. Finally, call the private function **private_Rank_queue** in the public function **public_Rank_queue** to return the result.\nProblem: Assume there is a group of people standing in a queue in a disordered order. The array **people[i]=[h_i,k_i]** indicates that the height of the i-th person is **h_i**, and there are exactly **k_i** people in front of him who are taller or equal to **h_i**. The requirement is to return the queue represented by the input array **people**.", "test_list": ["assert candidate([[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]])==[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]", "assert candidate([[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]])==[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]"], "test_function": "def test_run(content1):\n    return RQU(content1).public_Rank_queue()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RQU\", \"def __init__(self, people)\", \"def _private_Rank_queue\",\"def public_Rank_queue\"], [\"class RQU\", \"def __init__(self, people)\", \"def __private_Rank_queue\",\"def public_Rank_queue\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/53", "question": "Question: Given a non-negative integer array **nums** and an integer **m**, you need to divide this array into **m** non-empty continuous subarrays. Design an algorithm to make the maximum value of the sum of these **m** subarrays the smallest.\nPlease use Python language to first design a **CSR** class, with instance attributes **nums** and **m**, a private function **private_Continuous_subarray**, and a public function **public_Continuous_subarray**; then implement the above problem in the private function **private_Continuous_subarray**; finally, call the private function **private_Continuous_subarray** in the public function **public_Continuous_subarray** to return the result.", "test_list": ["assert candidate([7,2,5,10,8],2)==18", "assert candidate([1,2,3,4,5],2)==9", "assert candidate([1,4,4],3)==4"], "test_function": "def test_run(content1,content2):\n    return CSR(content1,content2).public_Continuous_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CSR\", \"def __init__(self, nums, m)\", \"def _private_Continuous_subarray\",\"def public_Continuous_subarray\"], [\"class CSR\", \"def __init__(self, nums, m)\", \"def __private_Continuous_subarray\",\"def public_Continuous_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/54", "question": "Firstly, design an **EAY** class using the Python language, which has an instance attribute **nums**, a private function **private_Equidistant_array**, and a public function **public_Equidistant_array**. Then, in the private function **private_Equidistant_array**, provide an integer array **nums** and return the number of sub-arrays in **nums** that are arithmetic arrays. Finally, in the public function **public_Equidistant_array**, call the private function **private_Equidistant_array** to return the result.", "test_list": ["assert candidate([1,2,3,4])==3", "assert candidate([1])==0"], "test_function": "def test_run(content1):\n    return EAY(content1).public_Equidistant_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EAY\", \"def __init__(self, nums)\", \"def _private_Equidistant_array\",\"def public_Equidistant_array\"], [\"class EAY\", \"def __init__(self, nums)\", \"def __private_Equidistant_array\",\"def public_Equidistant_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/55", "question": "Firstly, design an **SSB** class using the Python language, which has an instance attribute **nums**, a private function **private_split_subset**, and a public function **public_split_subset**. Then, in the private function **private_split_subset**, determine whether the non-empty array **nums**, which only contains positive integers, can be split into two subsets so that the sum of the elements in the two subsets is equal. Finally, in the public function **public_split_subset**, call the private function **private_split_subset** to return the result.", "test_list": ["assert candidate([1,5,11,5])==True", "assert candidate([1,2,3,5])==False"], "test_function": "def test_run(content1):\n    return SSB(content1).public_split_subset()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSB\", \"def __init__(self, nums)\", \"def _private_split_subset\",\"def public_split_subset\"], [\"class SSB\", \"def __init__(self, nums)\", \"def __private_split_subset\",\"def public_split_subset\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/56", "question": "Question: Given a m x n matrix **board** representing a deck, where each cell can be a battleship 'X' or an empty spot '.', return the number of battleships placed on the board.\nPlease use Python to first design a **PBI** class, with an instance attribute **board**, a private function **private_Placed_battleships**, and a public function **public_Placed_battleships**. Then implement the above problem in the private function **private_Placed_battleships**. Finally, call the private function **private_Placed_battleships** in the public function **public_Placed_battleships** to return the result.", "test_list": ["assert candidate([[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]])==2", "assert candidate([[\".\"]])==0"], "test_function": "def test_run(content1):\n    return PBI(content1).\",\"()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PBI\", \"def __init__(self, board)\", \"def _private_Placed_battleships\",\"def public_Placed_battleships\"], [\"class PBI\", \"def __init__(self, board)\", \"def __private_Placed_battleships\",\"def public_Placed_battleships\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/57", "question": "First, design an **MRU** class using the Python language, which has an instance attribute **nums**, a private function **private_Maximum_result**, and a public function **public_Maximum_result**. Then, in the private function **private_Maximum_result**, return the maximum operation result of nums[i] XOR nums[j], where 0≤i≤j<n. Finally, in the public function **public_Maximum_result**, call the private function **private_Maximum_result** to return the result.", "test_list": ["assert candidate([3,10,5,25,2,8])==28", "assert candidate([14,70,53,83,49,91,36,80,92,51,66,70])==127"], "test_function": "def test_run(content1):\n    return MRU(content1).public_Maximum_result()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MRU\", \"def __init__(self, nums)\", \"def _private_Maximum_result\",\"def public_Maximum_result\"], [\"class MRU\", \"def __init__(self, nums)\", \"def __private_Maximum_result\",\"def public_Maximum_result\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/58", "question": "Question: Given a string **s**, which contains several numbers (0-9) represented by scrambled English words, return the original numbers in ascending order.\nUsing Python language, first design a **DOR** class, with instance attribute **s**, private function **private_Disordered_order** and public function **public_Disordered_order**; then implement the above problem in the private function **private_Disordered_order**; finally, call the private function **private_Disordered_order** in the public function **public_Disordered_order** to return the result.", "test_list": ["assert candidate(\"owoztneoer\")==\"012\"", "assert candidate(\"fviefuro\")==\"45\""], "test_function": "def test_run(content1):\n    return DOR(content1).public_Disordered_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DOR\", \"def __init__(self, s)\", \"def _private_Disordered_order\",\"def public_Disordered_order\"], [\"class DOR\", \"def __init__(self, s)\", \"def __private_Disordered_order\",\"def public_Disordered_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/59", "question": "Firstly, design an **LSR** class using Python language, which has instance attributes **s** and **k**, a private function **private_Longest_substring**, and a public function **public_Longest_substring**. Then, in the private function **private_Longest_substring**, change any character in the string **s** to any other uppercase English character up to **k** times, and return the length of the longest substring containing the same letter. Finally, in the public function **public_Longest_substring**, call the private function **private_Longest_substring** to return the result.", "test_list": ["assert candidate(\"ABAB\",2)==4", "assert candidate(\"AABABBA\",1)==4"], "test_function": "def test_run(content1,content2):\n    return LSR(content1,content2).public_Longest_substring()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LSR\", \"def __init__(self, s, k)\", \"def _private_Longest_substring\",\"def public_Longest_substring\"], [\"class LSR\", \"def __init__(self, s, k)\", \"def _private_Longest_substring\",\"def public_Longest_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/60", "question": "Firstly, design a class **GS** using Python language, which has instance attributes **start**, **end**, and **bank**, a private function **private_gene_sequence**, and a public function **public_gene_sequence**. Then, implement the following problem in the private function **private_gene_sequence**. Finally, call the private function **private_gene_sequence** in the public function **public_gene_sequence** to return the result.\nProblem: A gene sequence is represented by a string composed of 8 characters, each of which is one of 'A', 'C', 'G', and 'T'. Suppose we need to investigate the gene changes that occur when the gene sequence **start** changes to **end**. Gene changes mean that the characters have changed. Given a gene bank **bank** that records all valid gene changes, return the minimum number of changes required to change **start** to **end**. If this gene change cannot be completed, return -1.", "test_list": ["assert candidate(\"AACCGGTT\", \"AACCGGTA\", [\"AACCGGTA\"])==1", "assert candidate(\"AACCGGTT\", \"AAACGGTA\", [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"])==2", "assert candidate(\"AAAAACCC\", \"AACCCCCC\", [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"])==3"], "test_function": "def test_run(content1,content2,content3):\n    return GS(content1,content2,content3).public_gene_sequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GS\", \"def __init__(self, start, end, bank)\", \"def _private_gene_sequence\",\"def public_gene_sequence\"], [\"class GS\", \"def __init__(self, start, end, bank)\", \"def __private_gene_sequence\",\"def public_gene_sequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/61", "question": "Question: Given a collection of **intervals** where intervals[i] = [start_i, end_i]. Return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nPlease use Python to first design a **SIL** class, with instance attribute **intervals**, a private function **private_Set_intervals**, and a public function **public_Set_intervals**. Then, implement the above problem in the private function **private_Set_intervals**. Finally, call the private function **private_Set_intervals** in the public function **public_Set_intervals** to return the result.", "test_list": ["assert candidate([[1,2],[2,3],[3,4],[1,3]])==1", "assert candidate([[1,2], [1,2], [1,2]])==2", "assert candidate([[1,2], [2,3]])==0"], "test_function": "def test_run(content1):\n    return SIL(content1).public_Set_intervals()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SIL\", \"def __init__(self, intervals)\", \"def _private_Set_intervals\",\"def public_Set_intervals\"], [\"class SIL\", \"def __init__(self, intervals)\", \"def __private_Set_intervals\",\"def public_Set_intervals\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/62", "question": "Firstly, design an **RSC** class using Python language, which has an instance attribute **intervals**, a private function **private_Right_section**, and a public function **public_Right_section**. Then, implement the following problem in the private function **private_Right_section**. Finally, call the private function **private_Right_section** in the public function **public_Right_section** to return the result.\nProblem: Given an interval array **intervals**, where intervals[i] = [start_i, end_i], and each **start_i** is different. The right section of interval **i** can be denoted as interval **j**, satisfying **start_j >= end_i**, and **start_j** is minimized. Return an array composed of the indices of the right section of each interval **i** in **intervals**. If there is no corresponding right section for a certain interval **i**, the value at index **i** is set to -1.", "test_list": ["assert candidate([[1,2]])==[-1]", "assert candidate([[3,4],[2,3],[1,2]])==[-1,0,1]", "assert candidate([[1,4],[2,3],[3,4]])==[-1,2,-1]"], "test_function": "def test_run(content1):\n    return RSC(content1).public_Right_section()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RSC\", \"def __init__(self, intervals)\", \"def _private_Right_section\",\"def public_Right_section\"], [\"class RSC\", \"def __init__(self, intervals)\", \"def __private_Right_section\",\"def public_Right_section\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/63", "question": "Question: Given two strings **s** and **p**, find all the anagrams of **p** in **s**, and return the starting indices of these substrings. An anagram is a string formed by rearranging the same letters (including the same string).\nPlease use Python to first design a **SIN** class, with instance attributes **s** and **p**, a private function **private_start_index**, and a public function **public_start_index**; then implement the above problem in the private function **private_start_index**; finally, call the private function **private_start_index** in the public function **public_start_index** to return the result.", "test_list": ["assert candidate(\"cbaebabacd\",\"abc\")==[0,6]", "assert candidate(\"abab\",\"ab\")==[0,1,2]"], "test_function": "def test_run(content1,content2):\n    return SIN(content1,content2).public_start_index()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SIN\", \"def __init__(self, s, p)\", \"def _private_start_index\",\"def public_start_index\"], [\"class SIN\", \"def __init__(self, s, p)\", \"def __private_start_index\",\"def public_start_index\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/64", "question": "Firstly, design a **DOE** class using Python language, which has instance attributes **n** and **k**, a private function **private_Dictionary_order**, and a public function **public_Dictionary_order**. Then, return the **k-th** smallest number in the dictionary order of [1, n] in the private function **private_Dictionary_order**. Finally, call the private function **private_Dictionary_order** in the public function **public_Dictionary_order** to return the result.", "test_list": ["assert candidate(13,2)==10", "assert candidate(1,1)==1"], "test_function": "def test_run(content1,content2):\n    return DOE(content1,content2).public_Dictionary_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DOE\", \"def __init__(self, n, k)\", \"def _private_Dictionary_order\",\"def public_Dictionary_order\"], [\"class DOE\", \"def __init__(self, n, k)\", \"def __private_Dictionary_order\",\"def public_Dictionary_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/65", "question": "Question: There are a total of **n** coins, and the plan is to arrange them in a staircase shape. For a staircase composed of **k** rows, the i-th row must have exactly **i** coins. The last row of the staircase may be incomplete. Given a number **n**, calculate and return the total number of rows that can form a complete staircase.\nPlease use the Python language to first design a **CLA** class, with an instance attribute **n**, a private function **private_Complete_ladder**, and a public function **public_Complete_ladder**; then implement the above problem in the private function **private_Complete_ladder**; finally, call the private function **private_Complete_ladder** in the public function **public_Complete_ladder** to return the result.", "test_list": ["assert candidate(5)==2", "assert candidate(8)==3"], "test_function": "def test_run(content1):\n    return CLA(content1).public_Complete_ladder()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CLA\", \"def __init__(self, n)\", \"def _private_Complete_ladder\",\"def public_Complete_ladder\"], [\"class CLA\", \"def __init__(self, n)\", \"def __private_Complete_ladder\",\"def public_Complete_ladder\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/66", "question": "Question: Given an integer array **nums** of length **n**, where all integers in **nums** are within the range [1, n] and each integer appears once or twice. Please find all integers that appear twice and return them in the form of an array.\nPlease use Python to first design a class **AFO** with instance attribute **nums**, private function **private_Array_form** and public function **public_Array_form**; then implement the above problem in the private function **private_Array_form**; finally, call the private function **private_Array_form** in the public function **public_Array_form** to return the result.", "test_list": ["assert candidate([4,3,2,7,8,2,3,1])==[2,3]", "assert candidate([1,1,2])==[1]", "assert candidate([1])==[]"], "test_function": "def test_run(content1):\n    return AFO(content1).public_Array_form()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AFO\", \"def __init__(self, nums)\", \"def _private_Array_form\",\"def public_Array_form\"], [\"class AFO\", \"def __init__(self, nums)\", \"def __private_Array_form\",\"def public_Array_form\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/67", "question": "Firstly, design an **ISAR** class using the Python language, which has instance attributes **chars**, a private function **private_Input_sarray**, and a public function **public_Input_sarray**. Then, implement the following problem in the private function **private_Input_sarray**. Finally, call the private function **private_Input_sarray** in the public function **public_Input_sarray** to return the result.\nProblem: Given a character array **chars**, compress the array according to the following requirements: Starting from an empty string **s**, for each group of consecutive repeating characters in **chars**, if the length of the group is 1, append the character to **s**. Otherwise, append the character to **s**, followed by the length of the group. The requirement is to return the new length of the array after modifying the input array.", "test_list": ["assert candidate([\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"])==[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]", "assert candidate([\"a\"])==[\"a\"]", "assert candidate([\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"])==[\"a\",\"b\",\"1\",\"2\"]"], "test_function": "def test_run(content1):\n    return ISAR(content1).public_Input_sarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ISAR\", \"def __init__(self, chars)\", \"def _private_Input_sarray\",\"def public_Input_sarray\"], [\"class ISAR\", \"def __init__(self, chars)\", \"def __private_Input_sarray\",\"def public_Input_sarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/68", "question": "Firstly, design an **ESQ** class using Python language, which has an instance attribute **nums**, a private function **private_Equidistant_subsequence**, and a public function **public_Equidistant_subsequence**. Then, in the private function **private_Equidistant_subsequence**, return the number of all equidistant subsequences in the integer array **nums**. Finally, in the public function **public_Equidistant_subsequence**, call the private function **private_Equidistant_subsequence** to return the result.", "test_list": ["assert candidate([2,4,6,8,10])==7", "assert candidate([7,7,7,7,7])==16"], "test_function": "def test_run(content1):\n    return ESQ(content1).public_Equidistant_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ESQ\", \"def __init__(self, nums)\", \"def _private_Equidistant_subsequence\",\"def public_Equidistant_subsequence\"], [\"class ESQ\", \"def __init__(self, nums)\", \"def __private_Equidistant_subsequence\",\"def public_Equidistant_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/69", "question": "Firstly, design an **EDA** class using Python language, which has an instance attribute **points**, a private function **private_Euclidean_distance**, and a public function **public_Euclidean_distance**. Then, implement the following problem in the private function **private_Euclidean_distance**. Finally, call the private function **private_Euclidean_distance** in the public function **public_Euclidean_distance** to return the result.\nProblem: Given **n** pairs of distinct points on the plane points[i]=[x_i,y_i], a point (i,j,k) represents a boomerang, where the distance between **i** and **j** is equal to the Euclidean distance between **i** and **k** (considering the order of the tuple), return the number of all boomerangs on the plane.", "test_list": ["assert candidate([[0,0],[1,0],[2,0]])==2", "assert candidate([[1,1],[2,2],[3,3]])==2", "assert candidate([[1,1]])==0"], "test_function": "def test_run(content1):\n    return EDA(content1).public_Euclidean_distance()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EDA\", \"def __init__(self, points)\", \"def _private_Euclidean_distance\",\"def public_Euclidean_distance\"], [\"class EDA\", \"def __init__(self, points)\", \"def __private_Euclidean_distance\",\"def public_Euclidean_distance\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/70", "question": "Question: Given a string **s**, sort it in decreasing order based on the frequency of characters. The frequency of a character is the number of times it appears in the string. Return the sorted string.\nPlease use Python to first design a **DODE** class, with an instance attribute **s**, a private function **private_descending_order**, and a public function **public_descending_order**; then implement the above problem in the private function **private_descending_order**; finally, call the private function **private_descending_order** in the public function **public_descending_order** to return the result.", "test_list": ["assert candidate(\"tree\")==\"eert\"", "assert candidate(\"cccaaa\")==\"cccaaa\"", "assert candidate(\"Aabb\")==\"bbAa\""], "test_function": "def test_run(content1):\n    return DODE(content1).public_descending_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DODE\", \"def __init__(self, s)\", \"def _private_descending_order\",\"def public_descending_order\"], [\"class DODE\", \"def __init__(self, s)\", \"def __private_descending_order\",\"def public_descending_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/71", "question": "Question: Given an integer array of length n, each operation will increase n - 1 elements by 1. Return the minimum number of operations to make all elements in the array equal.\nPlease design an **EEL** class in Python first, with instance attribute **nums**, a private function **private_Element_equality**, and a public function **public_Element_equality**. Then, implement the above problem in the private function **private_Element_equality**. Finally, call the private function **private_Element_equality** in the public function **public_Element_equality** to return the result.", "test_list": ["assert candidate([1,2,3])==3", "assert candidate([1,1,1])==0"], "test_function": "def test_run(content1):\n    return EEL(content1).public_Element_equality()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EEL\", \"def __init__(self, nums)\", \"def _private_Element_equality\",\"def public_Element_equality\"], [\"class EEL\", \"def __init__(self, nums)\", \"def __private_Element_equality\",\"def public_Element_equality\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/72", "question": "Question: Given four integer arrays **nums1**, **nums2**, **nums3**, and **nums4**, all of the same length **n**, calculate how many tuples (i, j, k, l) can satisfy: 0 <= i, j, k, l < n and nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0.\nPlease use Python to first design an **AST** class, with instance attributes **nums1**, **nums2**, **nums3**, and **nums4**, a private function **private_Array_stlength**, and a public function **public_Array_stlength**. Then, implement the above problem in the private function **private_Array_stlength**. Finally, call the private function **private_Array_stlength** in the public function **public_Array_stlength** to return the result.", "test_list": ["assert candidate([1,2],[-2,-1],[-1,2],[0,2])==2", "assert candidate([0],[0],[0],[0])==1"], "test_function": "def test_run(content1,content2,content3,content4):\n    return AST(content1,content2,content3,content4).public_Array_stlength()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AST\", \"def __init__(self, nums1, nums2, nums3, nums4)\", \"def _private_Array_stlength\",\"def public_Array_stlength\"], [\"class AST\", \"def __init__(self, nums1, nums2, nums3, nums4)\", \"def __private_Array_stlength\",\"def public_Array_stlength\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/73", "question": "Question: Given an integer array **nums** with **n** integers. A 132 pattern subsequence is a three-element sequence nums[i], nums[j], and nums[k] that satisfies: i<j<k and nums[i]<nums[k]<nums[j]. If there is a 132 pattern subsequence in **nums**, return True; otherwise, return False.\nPlease design a **SPAR** class in Python first, with an instance attribute **nums**, a private function **private_Subsequences_patterns**, and a public function **public_Subsequences_patterns**; then implement the above problem in the private function **private_Subsequences_patterns**; finally, call the private function **private_Subsequences_patterns** in the public function **public_Subsequences_patterns** to return the result.", "test_list": ["assert candidate([1,2,3,4])==False", "assert candidate([3,1,4,2])==True", "assert candidate([-1,3,2,0])==True"], "test_function": "def test_run(content1):\n    return SPAR(content1).public_Subsequences_patterns()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SPAR\", \"def __init__(self, nums)\", \"def _private_Subsequences_patterns\",\"def public_Subsequences_patterns\"], [\"class SPAR\", \"def __init__(self, nums)\", \"def __private_Subsequences_patterns\",\"def public_Subsequences_patterns\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/74", "question": "Firstly, design an **SPR** class using Python language, which has an instance attribute **nums**, a private function **private_Suences_patterns**, and a public function **public_Suences_patterns**. Then, implement the following problem in the private function **private_Suences_patterns**. Finally, call the private function **private_Suences_patterns** in the public function **public_Suences_patterns** to return the result.\nProblem: Given a circular array nums[i] without 0, which represents the number of indices that the character at index **i** should move forward or backward. If it is a positive number, move forward (in the direction of index increment) by |nums[i]| steps, otherwise, move backward (in the direction of index decrement) by |nums[i]| steps. Because the array is circular, it can be assumed that moving one step forward from the last element will reach the first element, and moving one step backward from the first element will reach the last element. The cycle in the array is identified by an index sequence **seq** of length k: following the above movement rules will lead to a group of repeated index sequences seq[0]->seq[1]->...->seq[k-1]->seq[0]->...; all nums[seq[j]] should be either all positive or all negative. Determine whether there is a cycle in **nums**, if it exists, return True; otherwise, return False.", "test_list": ["assert candidate([2,-1,1,2,2])==True", "assert candidate([-1,2])==False", "assert candidate([-2,1,-1,-2,-2])==False"], "test_function": "def test_run(content1):\n    return SPR(content1).public_Suences_patterns()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SPR\", \"def __init__(self, nums)\", \"def _private_Suences_patterns\",\"def public_Suences_patterns\"], [\"class SPR\", \"def __init__(self, nums)\", \"def __private_Suences_patterns\",\"def public_Suences_patterns\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/75", "question": "Question: Given an integer array **nums** of length **n**, return the minimum number of operations required to make all elements of the array equal. In one operation, you can increase or decrease an element of the array by one.\nPlease use Python to first design an **OOA** class, with instance attribute **nums**, a private function **private_One_operation**, and a public function **public_One_operation**. Then, implement the above problem in the private function **private_One_operation**. Finally, call the private function **private_One_operation** in the public function **public_One_operation** to return the result.", "test_list": ["assert candidate([1,2,3])==2", "assert candidate([1,10,2,9])==16"], "test_function": "def test_run(content1):\n    return OOA(content1).public_One_operation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class OOA\", \"def __init__(self, nums)\", \"def _private_One_operation\",\"def public_One_operation\"], [\"class OOA\", \"def __init__(self, nums)\", \"def __private_One_operation\",\"def public_One_operation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/76", "question": "Firstly, design a class **PIGE** using Python language, which has instance attributes **maxChoosableInteger** and **desiredTotal**, a private function **private_Public_integer**, and a public function **public_Public_integer**. Then, implement the following problem in the private function **private_Public_integer**. Finally, call the private function **private_Public_integer** in the public function **public_Public_integer** to return the result.\nProblem: Now, we are playing the **100game**. Two players take turns to choose any integer from 1 to 10, accumulate the sum of integers. The player who first reaches or exceeds 100 and cannot reuse integers is the winner. Given two integers, **maxChoosableInteger** (the maximum number that can be chosen from the integer pool) and **desiredTotal** (the accumulated sum), determine whether the first player can win stably. If so, return True, otherwise return False.", "test_list": ["assert candidate(10,11)==False", "assert candidate(10,0)==True", "assert candidate(10,1)==True"], "test_function": "def test_run(content1,content2):\n    return PIGE(content1,content2).public_Public_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PIGE\", \"def __init__(self, maxChoosableInteger, desiredTotal)\", \"def _private_Public_integer\",\"def public_Public_integer\"], [\"class PIGE\", \"def __init__(self, maxChoosableInteger, desiredTotal)\", \"def __private_Public_integer\",\"def public_Public_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/77", "question": "Firstly, design an **IIFI** class using Python language, which has instance attributes **s1**, **n1**, **s2**, and **n2**, a private function **private_Italic_tion**, and a public function **public_Italic_tion**. Then, implement the following problem in the private function **private_Italic_tion**. Finally, call the private function **private_Italic_tion** in the public function **public_Italic_tion** to return the result.\nProblem: Given str=[s,n] indicates that **str** is composed of **n** strings **s** concatenated together. If some characters can be deleted from **s2** to become **s1**, then it is said that the string **s1** can be obtained from the string **s2**. You need to construct two strings **s1** and **s2** and two integers **n1** and **n2** to get two strings str1=[s1,n1] and str2=[s2,n2]. The requirement is to return a maximum integer **m**, to satisfy that str=[str2,m] can be obtained from **str1**.", "test_list": ["assert candidate(\"acb\",4,\"ab\",2)==2", "assert candidate(\"acb\",1,\"acb\",1)==1"], "test_function": "def test_run(content1,content2,content3,content4):\n    return IIFI(content1,content2,content3,content4).public_Italic_tion()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IIFI\", \"def __init__(self, s1, n1, s2, n2)\", \"def _private_Italic_tion\",\"def public_Italic_tion\"], [\"class IIFI\", \"def __init__(self, s1, n1, s2, n2)\", \"def __private_Italic_tion\",\"def public_Italic_tion\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/78", "question": "Question: Define a string base as an infinitely wrapped \"abcdefghijklmnopqrstuvwxyz\", so the base looks like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\". Given a string s, please count and return how many different non-empty substrings appear in the base.\nPlease use Python to first design an **IZOE** class, with instance attribute **s**, private function **private_Infinity_Zone**, and public function **public_Infinity_Zone**; then implement the above problem in the private function **private_Infinity_Zone**; finally, call the private function **private_Infinity_Zone** in the public function **public_Infinity_Zone** to return the result.", "test_list": ["assert candidate(\"a\")==1", "assert candidate(\"cac\")==2", "assert candidate(\"zab\")==6"], "test_function": "def test_run(content1):\n    return IZOE(content1).public_Infinity_Zone()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IZOE\", \"def __init__(self, s)\", \"def _private_Infinity_Zone\",\"def public_Infinity_Zone\"], [\"class IZOE\", \"def __init__(self, s)\", \"def __private_Infinity_Zone\",\"def public_Infinity_Zone\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/79", "question": "Firstly, design an **EDC** class using Python language, which has an instance attribute **words**, a private function **private_Excluding_Duplicates**, and a public function **public_Excluding_Duplicates**. Then, in the private function **private_Excluding_Duplicates**, provide a string array **words** that does not contain duplicate words, and it is required to return all the conjunctions in **words**. Finally, call the private function **private_Excluding_Duplicates** in the public function **public_Excluding_Duplicates** to return the result.", "test_list": ["assert candidate([\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"])==[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]", "assert candidate([\"cat\",\"dog\",\"catdog\"])==[\"catdog\"]"], "test_function": "def test_run(content1):\n    return EDC(content1).public_Excluding_Duplicates()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EDC\", \"def __init__(self, words)\", \"def _private_Excluding_Duplicates\",\"def public_Excluding_Duplicates\"], [\"class EDC\", \"def __init__(self, words)\", \"def __private_Excluding_Duplicates\",\"def public_Excluding_Duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/80", "question": "Firstly, design an **EMSP** class using Python language, which has an instance attribute **matchsticks**, a private function **private_Each_matchstick**, and a public function **public_Each_matchstick**. Then, implement the following problem in the private function **private_Each_matchstick**. Finally, call the private function **private_Each_matchstick** in the public function **public_Each_matchstick** to return the result.\nProblem: Given an integer array, matchsticks[i] is the length of the i-th matchstick. The requirement is to form a square with all the matchsticks (they can be connected together), but no matchstick can be broken and each matchstick must be used once. Determine whether it is possible to form this square. If it is possible, return True, otherwise return False.", "test_list": ["assert candidate([1,1,2,2,2])==True", "assert candidate([3,3,3,3,4])==False"], "test_function": "def test_run(content1):\n    return EMSP(content1).public_Each_matchstick()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EMSP\", \"def __init__(self, matchsticks)\", \"def _private_Each_matchstick\",\"def public_Each_matchstick\"], [\"class EMSP\", \"def __init__(self, matchsticks)\", \"def __private_Each_matchstick\",\"def public_Each_matchstick\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/81", "question": "Question: Given a binary string array **strs** and two integers **m** and **n**. Please find and return the length of the maximum subset of **strs**, which has at most **m** zeros and **n** ones. If all elements of **x** are also elements of **y**, set **x** is a subset of set **y**.\nPlease use Python language to first design a **MSBS** class, with instance attributes **strs**, **m** and **n**, a private function **private_Maximum_subset** and a public function **public_Maximum_subset**; then implement the above problem in the private function **private_Maximum_subset**; finally, call the private function **private_Maximum_subset** in the public function **public_Maximum_subset** to return the result.", "test_list": ["assert candidate([\"10\", \"0001\", \"111001\", \"1\", \"0\"],5,3)==4", "assert candidate([\"10\", \"0\", \"1\"],1,1)==2"], "test_function": "def test_run(content1,content2,content3):\n    return MSBS(content1,content2,content3).public_Maximum_subset()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSBS\", \"def __init__(self, strs, m, n)\", \"def _private_Maximum_subset\",\"def public_Maximum_subset\"], [\"class MSBS\", \"def __init__(self, strs, m, n)\", \"def __private_Maximum_subset\",\"def public_Maximum_subset\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/82", "question": "Firstly, design a class named **ANUB** using Python language, which has an instance attribute **nums**, a private function **private_Any_numbers**, and a public function **public_Any_numbers**. Then, in the private function **private_Any_numbers**, return the total Hamming distance between any two numbers in the integer array **nums**. Finally, in the public function **public_Any_numbers**, call the private function **private_Any_numbers** to return the result.", "test_list": ["assert candidate([4,14,2])==6", "assert candidate([4,14,4])==4"], "test_function": "def test_run(content1):\n    return ANUB(content1).public_Any_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ANUB\", \"def __init__(self, nums)\", \"def _private_Any_numbers\",\"def public_Any_numbers\"], [\"class ANUB\", \"def __init__(self, nums)\", \"def __private_Any_numbers\",\"def public_Any_numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/83", "question": "Firstly, design an **MPRD** class using the Python language, which has an instance attribute **n**, a private function **private_Maximum_palindrome**, and a public function **public_Maximum_palindrome**. Then, in the private function **private_Maximum_palindrome**, return the maximum palindrome integer that can be represented as the product of two n-digit integers. Finally, in the public function **public_Maximum_palindrome**, call the private function **private_Maximum_palindrome** to return the result.", "test_list": ["assert candidate(2)==987", "assert candidate(1)==9"], "test_function": "def test_run(content1):\n    return MPRD(content1).public_Maximum_palindrome()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MPRD\", \"def __init__(self, n)\", \"def _private_Maximum_palindrome\",\"def public_Maximum_palindrome\"], [\"class MPRD\", \"def __init__(self, n)\", \"def __private_Maximum_palindrome\",\"def public_Maximum_palindrome\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/84", "question": "Firstly, design an **MSRI** class using the Python language, which has an instance attribute **n**, a private function **private_Magic_String**, and a public function **public_Magic_String**. Then, implement the following problem in the private function **private_Magic_String**. Finally, call the private function **private_Magic_String** in the public function **public_Magic_String** to return the result.\n\nProblem: The magical string **s** is composed only of '1' and '2', and the consecutive occurrences of '1' and '2' can generate this string. The first few elements of **s** are s = '1221121221221121122……'. If you group consecutive 1s and 2s in **s**, you can get \"1221121221221121122......\". The number of times 1 or 2 appears in each group is \"122112122122......\". The above occurrence times are exactly **s** itself. Given an integer **n**, return the number of 1s in the first **n** digits of the magical string **s**.", "test_list": ["assert candidate(6)==3", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return MSRI(content1).public_Magic_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSRI\", \"def __init__(self, n)\", \"def _private_Magic_String\",\"def public_Magic_String\"], [\"class MSRI\", \"def __init__(self, n)\", \"def __private_Magic_String\",\"def public_Magic_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/85", "question": "Firstly, design an **MBS** class using the Python language, which has an instance attribute **n**, a private function **private_Minimum_base**, and a public function **public_Minimum_base**. Then, in the private function **private_Minimum_base**, it is required to return the minimum good base of **n** in the form of a string. The definition of the minimum good base is as follows: if all digits of the **k** (k>=2) base number of **n** are 1, then **k** (k>=2) is considered a good base for **n**. Finally, the private function **private_Minimum_base** is called in the public function **public_Minimum_base** to return the result.", "test_list": ["assert candidate(\"13\")==\"3\"", "assert candidate(\"4681\")==\"8\"", "assert candidate(\"1000000000000000000\")==\"999999999999999999\""], "test_function": "def test_run(content1):\n    return MBS(content1).public_Minimum_base()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MBS\", \"def __init__(self, n)\", \"def _private_Minimum_base\",\"def public_Minimum_base\"], [\"class MBS\", \"def __init__(self, n)\", \"def __private_Minimum_base\",\"def public_Minimum_base\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/86", "question": "Question: Given an integer array **nums**, find and return all the distinct increasing sub-sequences in this array, where each sub-sequence must contain at least two elements.\nPlease design an **ISQE** class in Python, which has an instance attribute **nums**, a private function **private_increasing_subsequence**, and a public function **public_increasing_subsequence**. Then, implement the above problem in the private function **private_increasing_subsequence**. Finally, call the private function **private_increasing_subsequence** in the public function **public_increasing_subsequence** to return the result.", "test_list": ["assert candidate([4,6,7,7])==[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]", "assert candidate([4,4,3,2,1])==[[4,4]]"], "test_function": "def test_run(content1):\n    return ISQE(content1).public_increasing_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ISQE\", \"def __init__(self, nums)\", \"def _private_increasing_subsequence\",\"def public_increasing_subsequence\"], [\"class ISQE\", \"def __init__(self, nums)\", \"def __private_increasing_subsequence\",\"def public_increasing_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/87", "question": "Question: Given an array **nums**, if i<j and nums[i]>2*nums[j], we call (i, j) an important reverse pair. You need to return the number of **important reverse pairs** in the given array.\nPlease use Python to first design an **IFIP** class, with instance attribute **nums**, private function **private_Important_flipping** and public function **public_Important_flipping**; then implement the above problem in the private function **private_Important_flipping**; finally, call the private function **private_Important_flipping** in the public function **public_Important_flipping** to return the result.", "test_list": ["assert candidate([1,3,2,3,1])==2", "assert candidate([2,4,3,5,1])==3"], "test_function": "def test_run(content1):\n    return IFIP(content1).public_Important_flipping()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IFIP\", \"def __init__(self, nums)\", \"def _private_Important_flipping\",\"def public_Important_flipping\"], [\"class IFIP\", \"def __init__(self, nums)\", \"def __private_Important_flipping\",\"def public_Important_flipping\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/88", "question": "Question: Given a non-negative integer array **nums** and an integer **target**. By adding '+' or '-' in front of each integer in the array and then concatenating all the integers, an expression can be constructed. Return the number of different expressions that can be constructed in the above way and the calculation result is equal to **target**.\nPlease use Python language to first design a **DESI** class, with instance attributes **nums** and **target**, a private function **private_Different_expressions**, and a public function **public_Different_expressions**; then implement the above problem in the private function **private_Different_expressions**; finally, call the private function **private_Different_expressions** in the public function **public_Different_expressions** to return the result.", "test_list": ["assert candidate([1,1,1,1,1],3)==5", "assert candidate([1],1)==1"], "test_function": "def test_run(content1,content2):\n    return DESI(content1,content2).public_Different_expressions()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DESI\", \"def __init__(self, nums, target)\", \"def _private_Different_expressions\",\"def public_Different_expressions\"], [\"class DESI\", \"def __init__(self, nums, target)\", \"def __private_Different_expressions\",\"def public_Different_expressions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/89", "question": "Firstly, design a **DTVL** class using Python language, which has an instance attribute **mat**, a private function **private_Diagonal_traversal**, and a public function **public_Diagonal_traversal**. Then, in the private function **private_Diagonal_traversal**, return all the elements in the m x n matrix **mat** in the order of diagonal traversal using an array. Finally, in the public function **public_Diagonal_traversal**, call the private function **private_Diagonal_traversal** to return the result.", "test_list": ["assert candidate([[1,2,3],[4,5,6],[7,8,9]])==[1,2,4,7,5,3,6,8,9]", "assert candidate([[1,2],[3,4]])==[1,2,3,4]"], "test_function": "def test_run(content1):\n    return DTVL(content1).public_Diagonal_traversal()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DTVL\", \"def __init__(self, mat)\", \"def _private_Diagonal_traversal\",\"def public_Diagonal_traversal\"], [\"class DTVL\", \"def __init__(self, mat)\", \"def __private_Diagonal_traversal\",\"def public_Diagonal_traversal\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/90", "question": "Question: Given a circular array **nums** (the next element of nums[nums.length-1] is nums[0]), return the next greater element for each element in **nums**. The next greater element of a number **x** is the first number that is larger than it following the array traversal order, which means you should search for its next greater number in a circular manner. If it does not exist, output -1.\nPlease use Python to first design an **ATSA** class, with an instance attribute **nums**, a private function **private_Array_traversal**, and a public function **public_Array_traversal**; then implement the above problem in the private function **private_Array_traversal**; finally, call the private function **private_Array_traversal** in the public function **public_Array_traversal** to return the result.", "test_list": ["assert candidate([1,2,1])==[2,-1,2]", "assert candidate([1,2,3,4,3])==[2,3,4,-1,4]"], "test_function": "def test_run(content1):\n    return ATSA(content1).public_Array_traversal()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ATSA\", \"def __init__(self, nums)\", \"def _private_Array_traversal\",\"def public_Array_traversal\"], [\"class ATSA\", \"def __init__(self, nums)\", \"def __private_Array_traversal\",\"def public_Array_traversal\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/91", "question": "Firstly, design an **RL** class using the Python language, which has an instance attribute **s**, a private function **private_Return_length**, and a public function **public_Return_length**. Then, in the private function **private_Return_length**, return the length of the longest palindromic subsequence in the string **s**. Finally, in the public function **public_Return_length**, call the private function **private_Return_length** to return the result.", "test_list": ["assert candidate(\"bbbab\")==4", "assert candidate(\"cbbd\")==2"], "test_function": "def test_run(content1):\n    return RL(content1).public_Return_length()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RL\", \"def __init__(self, s)\", \"def _private_Return_length\",\"def public_Return_length\"], [\"class RL\", \"def __init__(self, s)\", \"def __private_Return_length\",\"def public_Return_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/92", "question": "First, design an **NCC** class using the Python language, which has instance attributes **amount** and **coins**, a private function **coin_combinations**, and a public function **public_combinations**. Then, in the private function **coin_combinations**, return the number of coin combinations that can make up the total amount. Finally, in the public function **public_combinations**, call the private function **coin_combinations** to return the result.", "test_list": ["assert candidate([1, 2, 5])==4", "assert candidate([2])==0", "assert candidate([10])==1"], "test_function": "def test_run(content1):\n    return NCC(content1).public_combinations()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NCC\", \"def __init__(self, amount, coins)\", \"def _coin_combinations\",\"def public_combinations\"], [\"class NCC\", \"def __init__(self, amount, coins)\", \"def __coin_combinations\",\"def public_combinations\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/93", "question": "Firstly, design an **ML** class using Python language, which has an instance attribute **strs**, a private function **private_Maximum_length**, and a public function **public_Maximum_length**. Then, in the private function **private_Maximum_length**, return the length of the longest special sequence in the string list **strs**. If the longest special sequence does not exist, return -1. Finally, in the public function **public_Maximum_length**, call the private function **private_Maximum_length** to return the result.", "test_list": ["assert candidate([\"aba\",\"cdc\",\"eae\"])==3", "assert candidate([\"aaa\",\"aaa\",\"aa\"])==-1"], "test_function": "def test_run(content1):\n    return ML(content1).public_Maximum_length()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ML\", \"def __init__(self, strs)\", \"def _private_Maximum_length\",\"def public_Maximum_length\"], [\"class ML\", \"def __init__(self, strs)\", \"def __private_Maximum_length\",\"def public_Maximum_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/94", "question": "First, design an **LS** class using the Python language, which has instance attributes **s** and **dictionary**, a private function **private_Longest_string**, and a public function **public_Longest_string**. Then, in the private function **private_Longest_string**, return the longest string in the **dictionary**, which can be obtained by deleting some characters in **s**. If there is more than one answer, return the string with the longest length and the smallest lexicographical order. If there is no answer, return an empty string. Finally, in the public function **public_Longest_string**, call the private function **private_Longest_string** to return the result.", "test_list": ["assert candidate(\"abpcplea\",[\"ale\",\"apple\",\"monkey\",\"plea\"])==\"apple\"", "assert candidate(\"abpcplea\",[\"a\",\"b\",\"c\"])==\"a\""], "test_function": "def test_run(content1,content2):\n    return LS(content1,content2).public_Longest_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LS\", \"def __init__(self, s, dictionary)\", \"def _private_Longest_string\",\"def public_Longest_string\"], [\"class LS\", \"def __init__(self, s, dictionary)\", \"def __private_Longest_string\",\"def public_Longest_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/95", "question": "Firstly, design an **AL** class using Python language, which has an instance attribute **nums**, a private function **private_Array_length**, and a public function **public_Array_length**. Then, find the longest consecutive subarray with the same number of 0 and 1 in the private function **private_Array_length**, and return the length of this subarray. Finally, call the private function **private_Array_length** in the public function **public_Array_length** to return the result.", "test_list": ["assert candidate([0,1])==2", "assert candidate([0,1,0])==2"], "test_function": "def test_run(content1):\n    return AL(content1).public_Array_length()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AL\", \"def __init__(self, nums)\", \"def _private_Array_length\",\"def public_Array_length\"], [\"class AL\", \"def __init__(self, nums)\", \"def __private_Array_length\",\"def public_Array_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/96", "question": "Firstly, design a class **CQ** using the Python language, which has an instance attribute **n**, a private function **private_Construction_quantity**, and a public function **public_Construction_quantity**. Then, in the private function **private_Construction_quantity**, return the number of beautiful arrangements that can be constructed. Finally, in the public function **public_Construction_quantity**, call the private function **private_Construction_quantity** to return the result.\n\nThe condition for a beautiful arrangement is: suppose there are **n** integers from 1 to **n**. Construct an array **perm** (index starts from 1) with these integers. As long as one of the following conditions is met, the array is a beautiful arrangement: 1. perm[i] can be divided by **i**; 2. **i** can be divided by perm[i].", "test_list": ["assert candidate(2)==2", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return CQ(content1).public_Construction_quantity()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CQ\", \"def __init__(self, n)\", \"def _private_Construction_quantity\",\"def public_Construction_quantity\"], [\"class CQ\", \"def __init__(self, n)\", \"def __private_Construction_quantity\",\"def public_Construction_quantity\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/97", "question": "Firstly, design an **RS** class using the Python language, which has an instance attribute **w**, a private function **private_Return_Subscript**, and a public function **public_Return_Subscript**. Then, in the private function **private_Return_Subscript**, randomly select and return a subscript from the range [0, w.length-1] (including 0 and w.length-1), with the probability of selecting subscript **i** being w[i]/sum(w). Finally, in the public function **public_Return_Subscript**, call the private function **private_Return_Subscript** to return the result.", "test_list": ["assert candidate([\"Solution\",\"pickIndex\"],[[[1]],[]])==[null,0]", "assert candidate([\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"],[[[1,3]],[],[],[],[],[]])==[null,1,1,1,1,0]"], "test_function": "def test_run(content1,content2):\n    return RS(content1,content2).public_Return_Subscript()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RS\", \"def __init__(self, w)\", \"def _private_Return_Subscript\",\"def public_Return_Subscript\"], [\"class RS\", \"def __init__(self, w)\", \"def __private_Return_Subscript\",\"def public_Return_Subscript\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/98", "question": "Firstly, design a class named **MG** using Python language, which has instance attributes **board** and **click**, a private function **private_Minesweeping_game**, and a public function **public_Minesweeping_game**. Then, implement the following problem in the private function **private_Minesweeping_game**. Finally, call the private function **private_Minesweeping_game** in the public function **public_Minesweeping_game** to return the result.\nProblem: Please design a minesweeper game represented by an m x n two-dimensional character matrix **board**. 'M', 'E', 'B', and 'X' respectively represent unexcavated mines, empty blocks, excavated blank blocks, and excavated mines. The specific rules are as follows: If a mine ('M') is excavated, the game ends, and it is changed to 'X'. If an empty block ('E') with no adjacent mines is excavated, change it to 'B', and all its adjacent unexcavated blocks should be recursively revealed. If an empty block ('E') adjacent to at least one mine is excavated, change it to a number ('1' to '8'), representing the number of adjacent mines. The requirement is to return the corresponding game board after the corresponding position is clicked.", "test_list": ["assert candidate([[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]],[3,0])==[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]", "assert candidate([[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]],[1,2])==[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]"], "test_function": "def test_run(content1,content2):\n    return MG(content1,content2).public_Minesweeping_game()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MG\", \"def __init__(self, board, click)\", \"def _private_Minesweeping_game\",\"def public_Minesweeping_game\"], [\"class MG\", \"def __init__(self, board, click)\", \"def __private_Minesweeping_game\",\"def public_Minesweeping_game\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/99", "question": "Firstly, design a class **NP** using the Python language, which has instance attributes **nums** and **k**, a private function **private_Number_Pairs**, and a public function **public_Number_Pairs**. Then, return the number of different **k-diff** number pairs in the private function **private_Number_Pairs**. Finally, call the private function **private_Number_Pairs** in the public function **public_Number_Pairs** to return the result.", "test_list": ["assert candidate([3, 1, 4, 1, 5],2)==2", "assert candidate([1, 2, 3, 4, 5],1)==4", "assert candidate([1, 3, 1, 5, 4],0)==1"], "test_function": "def test_run(content1,content2):\n    return NP(content1,content2).public_Number_Pairs()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NP\", \"def __init__(self, nums, k)\", \"def _private_Number_Pairs\",\"def public_Number_Pairs\"], [\"class NP\", \"def __init__(self, nums, k)\", \"def __private_Number_Pairs\",\"def public_Number_Pairs\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/100", "question": "Firstly, design a **SOP** class using the Python language, which has instance attributes **num1** and **num2**, a private function **String_product**, and a public function **public_String_product**. Then, in the private function **String_product**, follow the complex number representation format, and return a string representing the product of complex numbers **num1** and **num2**. Finally, in the public function **public_String_product**, call the private function **String_product** to return the result.", "test_list": ["assert candidate(\"1+1i\",\"1+1i\")==\"0+2i\"", "assert candidate(\"1+-1i\",\"1+-1i\")==\"0+-2i\""], "test_function": "def test_run(content1,content2):\n    return SOP(content1,content2).public_String_product()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SOP\", \"def __init__(self, num1, num2)\", \"def _String_product\",\"def public_String_product\"], [\"class SOP\", \"def __init__(self, num1, num2)\", \"def __String_product\",\"def public_String_product\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/101", "question": "Firstly, design an **MTD** class using the Python language, which has an instance attribute **timePoints**, a private function **Minimum_difference**, and a public function **public_Minimum_difference**. Then, in the private function **Minimum_difference**, return the minimum time difference between any two times in the list, represented in minutes. Finally, in the public function **public_Minimum_difference**, call the private function **Minimum_difference** to return the result.", "test_list": ["assert candidate([\"23:59\",\"00:00\"])==1", "assert candidate([\"00:00\",\"23:59\",\"00:00\"])==0"], "test_function": "def test_run(content1):\n    return MTD(content1).public_Number_occurrences()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MTD\", \"def __init__(self, timePoints)\", \"def _Minimum_difference\",\"def public_Minimum_difference\"], [\"class MTD\", \"def __init__(self, timePoints)\", \"def __Minimum_difference\",\"def public_Minimum_difference\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/102", "question": "Firstly, design a class named **NOO** using Python language, which has an instance attribute **nums**, a private function **Number_occurrences**, and a public function **public_Number_occurrences**. Then, implement the following problem in the private function **Number_occurrences**. Finally, call the private function **Number_occurrences** in the public function **public_Number_occurrences** to return the result.\nProblem: Given a sorted array composed only of integers, where each element appears twice except for one that appears only once. Please find and return that single number.", "test_list": ["assert candidate([1,1,2,3,3,4,4,8,8])==2", "assert candidate([3,3,7,7,10,11,11])==10"], "test_function": "def test_run(content1):\n    return NOO(content1).public_Number_of_occurrences()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NOO\", \"def __init__(self, nums)\", \"def _Number_occurrences\",\"def public_Number_occurrences\"], [\"class NOO\", \"def __init__(self, nums)\", \"def __Number_occurrences\",\"def public_Number_occurrences\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/103", "question": "Firstly, design a class named **MS** using Python language, which has an instance attribute **mat**, a private function **private_Matrices_size**, and a public function **public_Matrices_size**. Then, implement the following problem in the private function **private_Matrices_size**. Finally, call the private function **private_Matrices_size** in the public function **public_Matrices_size** to return the result.\nProblem: Given a matrix **mat** composed of 0 and 1, output a matrix of the same size, where each cell is the distance from the corresponding element in **mat** to the nearest 0. The distance between two adjacent elements is 1.", "test_list": ["assert candidate([[0,0,0],[0,1,0],[0,0,0]])==[[0,0,0],[0,1,0],[0,0,0]]", "assert candidate([[0,0,0],[0,1,0],[1,1,1]])==[[0,0,0],[0,1,0],[1,2,1]]"], "test_function": "def test_run(content1):\n    return MS(content1).public_Matrices_size()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MS\", \"def __init__(self, mat)\", \"def _private_Matrices_size\",\"def public_Matrices_size\"], [\"class MS\", \"def __init__(self, mat)\", \"def __private_Matrices_size\",\"def public_Matrices_size\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/104", "question": "Firstly, design an **RB** class using Python language, which has an instance attribute **boxes**, a private function **private_Remove_Box**, and a public function **public_Remove_Box**. Then, implement the following problem in the private function **private_Remove_Box**. Finally, call the private function **private_Remove_Box** in the public function **public_Remove_Box** to return the result.\nProblem: Given some **boxes** of different colors, the color of the box is represented by different positive numbers. After several rounds of operations to remove the boxes until all the boxes are removed. In each round, you can remove **k** consecutive boxes of the same color (k >= 1), and you will get **k * k** points after such a round. Return the maximum sum of points that can be obtained.", "test_list": ["assert candidate([1,3,2,2,2,3,4,3,1])==23", "assert candidate([1,1,1])==9", "assert candidate([1])==1"], "test_function": "def test_run(content1):\n    return RB(content1).public_Remove_Box()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RB\", \"def __init__(self, boxes)\", \"def _private_Remove_Box\",\"def public_Remove_Box\"], [\"class RB\", \"def __init__(self, boxes)\", \"def __private_Remove_Box\",\"def public_Remove_Box\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/105", "question": "Firstly, design an **AP** class using the Python language, which has an instance attribute **nums**, a private function **private_Add_parentheses**, and a public function **public_Add_parentheses**. Then, implement the following problem in the private function **private_Add_parentheses**. Finally, call the private function **private_Add_parentheses** in the public function **public_Add_parentheses** to return the result.\nProblem: Please perform floating-point division on a positive integer array **nums**. You can add any number of parentheses at any position to change the priority of arithmetic. Return the corresponding expression in string format with the maximum value.", "test_list": ["assert candidate([1000,100,10,2])==\"1000/(100/10/2)\"", "assert candidate([2,3,4])==\"2/(3/4)\""], "test_function": "def test_run(content1):\n    return AP(content1).public_Add_parentheses()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AP\", \"def __init__(self, nums)\", \"def _private_Add_parentheses\",\"def public_Add_parentheses\"], [\"class AP\", \"def __init__(self, nums)\", \"def __private_Add_parentheses\",\"def public_Add_parentheses\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/106", "question": "Firstly, design an **MI** class using Python language, which has an instance attribute **n**, a private function **private_Minimum_integer**, and a public function **public_Minimum_integer**. Then, implement the following problem in the private function **private_Minimum_integer**. Finally, call the private function **private_Minimum_integer** in the public function **public_Minimum_integer** to return the result.\nProblem: Given a positive integer **n**, find the smallest integer that meets the conditions, which is composed of each digit existing in **n** rearranged, and its value is greater than **n**. If there is no such positive integer, return -1.", "test_list": ["assert candidate(12)==21", "assert candidate(21)==-1"], "test_function": "def test_run(content1):\n    return MI(content1).public_Minimum_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MI\", \"def __init__(self, n)\", \"def _private_Minimum_integer\",\"def public_Minimum_integer\"], [\"class MI\", \"def __init__(self, n)\", \"def __private_Minimum_integer\",\"def public_Minimum_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/107", "question": "Firstly, design an **IS** class using the Python language, which has an instance attribute **s**, a private function **private_Invert_String**, and a public function **public_Invert_String**. Then, in the private function **private_Invert_String**, output the string after reversing the character order of each word in the string, while still retaining the spaces and the initial order of the words. Finally, call the private function **private_Invert_String** in the public function **public_Invert_String** to return the result.", "test_list": ["assert candidate(\"Let's take LeetCode contest\")==\"s'teL ekat edoCteeL tsetnoc\"", "assert candidate(\"God Ding\")==\"doG gniD\""], "test_function": "def test_run(content1):\n    return IS(content1).public_Invert_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IS\", \"def __init__(self, s)\", \"def _private_Invert_String\",\"def public_Invert_String\"], [\"class IS\", \"def __init__(self, s)\", \"def __private_Invert_String\",\"def public_Invert_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/108", "question": "Firstly, design a **CS** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Continuous_subarray**, and a public function **public_Continuous_subarray**. Then, in the private function **private_Continuous_subarray**, count and return the number of continuous subarrays in the array whose sum is **k**. Finally, call the private function **private_Continuous_subarray** in the public function **public_Continuous_subarray** to return the result.", "test_list": ["assert candidate([1,1,1],2)==2", "assert candidate([1,2,3],3)==2"], "test_function": "def test_run(content1,content2):\n    return CS(content1,content2).public_Continuous_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IS\", \"def __init__(self, s)\", \"def _private_Invert_String\",\"def public_Invert_String\"], [\"class IS\", \"def __init__(self, s)\", \"def __private_Invert_String\",\"def public_Invert_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/109", "question": "Firstly, design a class **PI** using the Python language, which has an instance attribute **n**, a private function **private_Palindrome_integer**, and a public function **public_Palindrome_integer**. Then, in the private function **private_Palindrome_integer**, return the palindrome integer closest to the string **n** (excluding itself). If there is more than one, return the smaller one. **Closest** is defined as the smallest absolute difference between two integers. Finally, in the public function **public_Palindrome_integer**, call the private function **private_Palindrome_integer** to return the result.", "test_list": ["assert candidate(\"123\")==\"121\"", "assert candidate(\"1\")==\"0\""], "test_function": "def test_run(content1):\n    return PI(content1).public_Palindrome_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PI\", \"def __init__(self, n)\", \"def _private_Palindrome_integer\",\"def public_Palindrome_integer\"], [\"class PI\", \"def __init__(self, n)\", \"def __private_Palindrome_integer\",\"def public_Palindrome_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/110", "question": "Firstly, design a class **JA** using the Python language, which has instance attributes **s1** and **s2**, a private function **private_Judgment_arrangement**, and a public function **public_Judgment_arrangement**. Then, in the private function **private_Judgment_arrangement**, determine whether **s2** contains the arrangement of **s1**. If it does, return **True**; otherwise, return **False**. Finally, call the private function **private_Judgment_arrangement** in the public function **public_Judgment_arrangement** to return the result.", "test_list": ["assert candidate(\"ab\",\"eidbaooo\")==True", "assert candidate(\"ab\",\"eidboaoo\")==False"], "test_function": "def test_run(content1,content2):\n    return JA(content1,content2).public_Judgment_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JA\", \"def __init__(self, s1, s2)\", \"def _private_Judgment_arrangement\",\"def public_Judgment_arrangement\"], [\"class JA\", \"def __init__(self, s1, s2)\", \"def __private_Judgment_arrangement\",\"def public_Judgment_arrangement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/111", "question": "Firstly, design a class named **SS** using the Python language, which includes an instance attribute **nums**, a private function **private_Shortest_subarray**, and a public function **public_Shortest_subarray**. Then, implement the following problem in the private function **private_Shortest_subarray**. Finally, call the private function **private_Shortest_subarray** in the public function **public_Shortest_subarray** to return the result.\nProblem: Given an integer array **nums**, you need to find a continuous subarray. If this subarray is sorted in ascending order, then the entire array will become sorted in ascending order. Please find the shortest subarray that meets this requirement and output its length.", "test_list": ["assert candidate([2,6,4,8,10,9,15])==5", "assert candidate([1,2,3,4])==0", "assert candidate([1])==0"], "test_function": "def test_run(content1):\n    return SS(content1).public_Shortest_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SS\", \"def __init__(self, nums)\", \"def _private_Shortest_subarray\",\"def public_Shortest_subarray\"], [\"class SS\", \"def __init__(self, nums)\", \"def __private_Shortest_subarray\",\"def public_Shortest_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/112", "question": "Firstly, design a class named **MS** using the Python language, which has instance attributes **word1** and **word2**, a private function **private_Minimum_Steps**, and a public function **public_Minimum_Steps**. Then, in the private function **private_Minimum_Steps**, return the minimum number of steps required to make **word1** and **word2** identical. Finally, in the public function **public_Minimum_Steps**, call the private function **private_Minimum_Steps** to return the result.", "test_list": ["assert candidate(\"sea\",\"eat\")==2", "assert candidate(\"leetcode\",\"etco\")==4"], "test_function": "def test_run(content1,content2):\n    return MS(content1,content2).public_Minimum_Steps()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MS\", \"def __init__(self, word1, word2)\", \"def _private_Minimum_Steps\",\"def public_Minimum_Steps\"], [\"class MS\", \"def __init__(self, word1, word2)\", \"def __private_Minimum_Steps\",\"def public_Minimum_Steps\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/113", "question": "Firstly, design an **RC** class using the Python language, which has an instance attribute **trees**, a private function **private_Return_Coordinates**, and a public function **public_Return_Coordinates**. Then, implement the following problem in the private function **private_Return_Coordinates**. Finally, call the private function **private_Return_Coordinates** in the public function **public_Return_Coordinates** to return the result.\nProblem: Given an array **trees**, where trees[i]=[x_i, y_i] represents the location of the tree in the garden. You are required to enclose the entire garden with the shortest length of rope because the rope is expensive. The garden is well enclosed only when all the trees are enclosed. Return the coordinates of the trees that are exactly on the perimeter of the fence.", "test_list": ["assert candidate([[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]])==[[1,1],[2,0],[3,3],[2,4],[4,2]]", "assert candidate([[1,2],[2,2],[4,2]])==[[4,2],[2,2],[1,2]]"], "test_function": "def test_run(content1):\n    return RC(content1).public_Return_Coordinates()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RC\", \"def __init__(self, trees)\", \"def _private_Return_Coordinates\",\"def public_Return_Coordinates\"], [\"class RC\", \"def __init__(self, trees)\", \"def __private_Return_Coordinates\",\"def public_Return_Coordinates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/114", "question": "First, design a class named **MS** using Python language, which has an instance attribute **expression**, a private function **private_Minimal_Score**, and a public function **public_Minimal_Score**. Then, implement the following problem in the private function **private_Minimal_Score**. Finally, call the private function **private_Minimal_Score** in the public function **public_Minimal_Score** to return the result.\nProblem: Given a string **expression** representing addition and subtraction of scores, you need to return a string form of the calculated result. This result should be an irreducible fraction, that is, the simplest fraction. If the final result is an integer, for example, an integer 2, you need to convert it into a fraction form with a denominator of 1. So in the above example, 2 should be converted to 2/1.", "test_list": ["assert candidate(\"-1/2+1/2\")==\"0/1\"", "assert candidate(\"-1/2+1/2\")==\"0/1\"", "assert candidate(\"1/3-1/2\")==\"-1/6\""], "test_function": "def test_run(content1):\n    return MS(content1).public_Minimal_Score()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MS\", \"def __init__(self, expression)\", \"def _private_Minimal_Score\",\"def public_Minimal_Score\"], [\"class MS\", \"def __init__(self, expression)\", \"def __private_Minimal_Score\",\"def public_Minimal_Score\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/115", "question": "Firstly, design a **FAS** class using the Python language, which has instance attributes **p1**, **p2**, **p3**, and **p4**, a private function **Form_square**, and a public function **public_Form_square**. Then, in the private function **Form_square**, determine whether the four points form a square. If they do, return True; otherwise, return False. Finally, in the public function **public_Form_square**, call the private function **Form_square** to return the result.", "test_list": ["assert candidate([0,0],[1,1],[1,0],[0,1])==True", "assert candidate([0,0],[1,1],[1,0],[0,12])==False", "assert candidate([1,0],[-1,0],[0,1],[0,-1])==False"], "test_function": "def test_run(content1,content2,content3,content4):\n    return FAS(content1,content2,content3,content4).public_Form_square()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FAS\", \"def __init__(self, p1, p2, p3, p4)\", \"def _Form_square\",\"def public_Form_a_square\"], [\"class FAS\", \"def __init__(self, p1, p2, p3, p4)\", \"def __Form_square\",\"def public_Form_a_square\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/116", "question": "Firstly, design a **TC** class using Python language, which has an instance attribute **n**, a private function **private_There_continuity**, and a public function **public_There_continuity**. Then, in the private function **private_There_continuity**, count how many non-negative integers in the range of [0, n] do not have consecutive 1 in their binary representation. Finally, call the private function **private_There_continuity** in the public function **public_There_continuity** to return the result.", "test_list": ["assert candidate(5)==5", "assert candidate(1)==2", "assert candidate(2)==3"], "test_function": "def test_run(content1):\n    return TC(content1).public_There_continuity()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TC\", \"def __init__(self, n)\", \"def _private_There_continuity\",\"def public_There_continuity\"], [\"class TC\", \"def __init__(self, n)\", \"def __private_There_continuity\",\"def public_There_continuity\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/117", "question": "Firstly, design a **NOT** class using Python language, which has an instance attribute **nums**, a private function **private_Number_of_triples**, and a public function **public_Number_of_triples**. Then, in the private function **private_Number_of_triples**, return the number of triples that **nums** can form the three sides of a triangle. Finally, in the public function **public_Number_of_triples**, call the private function **private_Number_of_triples** to return the result.", "test_list": ["assert candidate([2,2,3,4])==3", "assert candidate([4,2,3,4])==4"], "test_function": "def test_run(content1):\n    return NOT(content1).public_Number_of_triples()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NOT\", \"def __init__(self, nums)\", \"def _private_Number_of_triples\",\"def public_Number_of_triples\"], [\"class NOT\", \"def __init__(self, nums)\", \"def __private_Number_of_triples\",\"def public_Number_of_triples\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/118", "question": "Firstly, design an **MT** class using Python language, which has instance attributes **tasks** and **n**, a private function **private_Minimum_time**, and a public function **public_Minimum_time**. Then, implement the following problem in the private function **private_Minimum_time**. Finally, call the private function **private_Minimum_time** in the public function **public_Minimum_time** to return the result.\nProblem: Given a list of tasks that the CPU needs to execute, represented by a character array **tasks**. Each letter represents a different type of task. Tasks can be executed in any order, and each task can be completed within 1 unit of time. In any unit of time, the CPU can complete a task or be in standby mode. However, there must be a cooling time of integer **n** between two tasks of the same type, so the CPU must be executing different tasks or in standby mode for at least continuous **n** units of time. Calculate the shortest time required to complete all tasks.", "test_list": ["assert candidate([\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"],2)==8", "assert candidate([\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"],0)==6", "assert candidate([\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"],2)==16"], "test_function": "def test_run(content1,content2):\n    return MT(content1,content2).public_Minimum_time()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MT\", \"def __init__(self, tasks, n)\", \"def _private_Minimum_time\",\"def public_Minimum_time\"], [\"class MT\", \"def __init__(self, tasks, n)\", \"def __private_Minimum_time\",\"def public_Minimum_time\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/119", "question": "Firstly, design a class named **ROP** using the Python language, which has instance attributes **n** and **k**, a private function **private_Reverse_order_pair**, and a public function **public_Reverse_order_pair**. Then, implement the following problem in the private function **private_Reverse_order_pair**. Finally, call the private function **private_Reverse_order_pair** in the public function **public_Reverse_order_pair** to return the result.\nProblem: Please find out the number of different arrays that contain numbers from 1 to **n** and exactly have **k** reverse order pairs. Definition of reverse order pair: For the i-th and j-th elements of the array **nums**, if it satisfies 0<=i<j<nums.length and nums[i]>nums[j], it is a reverse order pair; otherwise, it is not.", "test_list": ["assert candidate(3,0)==1", "assert candidate(3,1)==2"], "test_function": "def test_run(content1,content2):\n    return ROP(content1,content2).public_Reverse_order_pair()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ROP\", \"def __init__(self, n, k)\", \"def _private_Reverse_order_pair\",\"def public_Reverse_order_pair\"], [\"class ROP\", \"def __init__(self, n, k)\", \"def __private_Reverse_order_pair\",\"def public_Reverse_order_pair\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/120", "question": "Firstly, design an **NCT** class using Python language, which has an instance attribute **courses**, a private function **private_Number_courses_taken**, and a public function **public_Number_courses_taken**. Then, implement the following problem in the private function **private_Number_courses_taken**. Finally, call the private function **private_Number_courses_taken** in the public function **public_Number_courses_taken** to return the result.\nProblem: Here are **n** different online courses, numbered from 1 to **n**. Given an array **courses**, where courses[i] = [duration_i, lastDay_i] indicates that the i-th course will last for **duration_i** days, and must be completed no later than **lastDay_i**. Your semester starts from the first day and you cannot take two or more courses at the same time. Return the maximum number of courses you can take.", "test_list": ["assert candidate([[100,200],[200,1300],[1000,1250],[2000,3200]])==3", "assert candidate([[1,2]])==1", "assert candidate([[3,2],[4,3]])==0"], "test_function": "def test_run(content1):\n    return NCT(content1).public_Number_courses_taken()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NCT\", \"def __init__(self, courses)\", \"def _private_Number_courses_taken\",\"def public_Number_courses_taken\"], [\"class NCT\", \"def __init__(self, courses)\", \"def __private_Number_courses_taken\",\"def public_Number_courses_taken\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/121", "question": "Firstly, design a class **JI** using the Python language, which has an instance attribute **c**, a private function **private_Judging_integers**, and a public function **public_Judging_integers**. Then, in the private function **private_Judging_integers**, determine whether there exist two integers **a** and **b** such that a^2 + b^2 = c. If they exist, return True, otherwise, return False. Finally, call the private function **private_Judging_integers** in the public function **public_Judging_integers** to return the result.", "test_list": ["assert candidate(5)==True", "assert candidate(3)==False"], "test_function": "def test_run(content1):\n    return JI(content1).public_Judging_integers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JI\", \"def __init__(self, c)\", \"def _private_Judging_integers\",\"def public_Judging_integers\"], [\"class JI\", \"def __init__(self, c)\", \"def __private_Judging_integers\",\"def public_Judging_integers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/122", "question": "First, design a class **SE** using the Python language, which has an instance attribute **equation**, a private function **private_solve_equation**, and a public function **public_solve_equation**. Then, implement the following problem in the private function **private_solve_equation**. Finally, call the private function **private_solve_equation** in the public function **public_solve_equation** to return the result.\nProblem: Solve a given equation and return **x** in the form of a string **x=#value**. The equation only contains '+' and '-' operations, the variable **x** and its corresponding coefficient. If the equation has no solution or the existing solution is not an integer, please return **No solution**. If the equation has infinite solutions, return **Infinite solutions**.", "test_list": ["assert candidate(\"x+5-3+x=6+x-2\")==\"x=2\"", "assert candidate(\"x=x\")==\"Infinite solutions\"", "assert candidate(\"2x=x\")==\"x=0\""], "test_function": "def test_run(content1):\n    return SE(content1).public_solve_equation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SE\", \"def __init__(self, equation)\", \"def _private_solve_equation\",\"def public_solve_equation\"], [\"class SE\", \"def __init__(self, equation)\", \"def __private_solve_equation\",\"def public_solve_equation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/123", "question": "Firstly, design an **LPC** class using Python language, which has an instance attribute **pairs**, a private function **private_Longest_pair_chain**, and a public function **public_Longest_pair_chain**. Then, implement the following problem in the private function **private_Longest_pair_chain**. Finally, call the private function **private_Longest_pair_chain** in the public function **public_Longest_pair_chain** to return the result.\nProblem: Given an array of pairs **pairs** composed of n pairs, where pairs[i] = [left_i, right_i] and left_i < right_i. Now, define a following relationship, where pair p2 = [c, d] can only follow p1 = [a, b] if and only if b < c. Use this form to construct a pair chain, find and return the length of the longest pair chain that can be formed.", "test_list": ["assert candidate([[1,2], [2,3], [3,4]])==2", "assert candidate([[1,2],[7,8],[4,5]])==3"], "test_function": "def test_run(content1):\n    return LPC(content1).public_Longest_pair_chain()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LPC\", \"def __init__(self, pairs)\", \"def _private_Longest_pair_chain\",\"def public_Longest_pair_chain\"], [\"class LPC\", \"def __init__(self, pairs)\", \"def __private_Longest_pair_chain\",\"def public_Longest_pair_chain\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/124", "question": "Firstly, design a **PS** class using Python language, which has an instance attribute **s**, a private function **private_Palindrome_substring**, and a public function **public_Palindrome_substring**. Then, return the number of palindrome substrings in the string **s** within the private function **private_Palindrome_substring**. Finally, call the private function **private_Palindrome_substring** to return the result within the public function **public_Palindrome_substring**.", "test_list": ["assert candidate(\"abc\")==3", "assert candidate(\"aaa\")==6"], "test_function": "def test_run(content1):\n    return PS(content1).public_Palindrome_substring()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PS\", \"def __init__(self, s)\", \"def _private_Palindrome_substring\",\"def public_Palindrome_substring\"], [\"class PS\", \"def __init__(self, s)\", \"def __private_Palindrome_substring\",\"def public_Palindrome_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/125", "question": "Firstly, design an **RS** class using the Python language, which has instance attributes **dictionary** and **sentence**, a private function **private_Root_substitution**, and a public function **public_Root_substitution**. Then, implement the following problem in the private function **private_Root_substitution**. Finally, call the private function **private_Root_substitution** in the public function **public_Root_substitution** to return the result.\n\nProblem: In English, there is a concept called **root**, where you can add other words after the root to form a longer word, which is called a **successor** word. For example, the root **an**, followed by the word **other**, can form a new word **another**. Now, given a **dictionary** composed of many roots and a **sentence** formed by words separated by spaces. You need to replace all the successor words in the sentence with the root. If there are many roots that can form the successor word, replace it with the shortest root. You need to output the sentence after the replacement.", "test_list": ["assert candidate([\"cat\",\"bat\",\"rat\"],\"the cattle was rattled by the battery\")==\"the cat was rat by the bat\"", "assert candidate([\"a\",\"b\",\"c\"],\"aadsfasf absbs bbab cadsfafs\")==\"a a b c\""], "test_function": "def test_run(content1,content2):\n    return RS(content1,content2).public_Root_substitution()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RS\", \"def __init__(self, dictionary, sentence)\", \"def _private_Root_substitution\",\"def public_Root_substitution\"], [\"class RS\", \"def __init__(self, dictionary, sentence)\", \"def __private_Root_substitution\",\"def public_Root_substitution\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/126", "question": "Firstly, design an **MNO** class using Python language, which has an instance attribute **n**, a private function **Minimum_operations**, and a public function **public_Minimum_operations**. Then, implement the following problem in the private function **Minimum_operations**. Finally, call the private function **Minimum_operations** in the public function **public_Minimum_operations** to return the result.\nProblem: Initially, there is only one character 'A' on the notepad. You can perform two types of operations on this notepad each time: 1. Copy All: Copy all characters in this notepad (partial copying is not allowed); 2. Paste: Paste the characters copied last time. Given a number **n**, you need to use the minimum number of operations to output exactly **n** 'A's on the notepad. Return the minimum number of operations that can print out **n** 'A's.", "test_list": ["assert candidate(3)==3", "assert candidate(1)==0"], "test_function": "def test_run(content1):\n    return MNO(content1).public_Minimum_operations()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNO\", \"def __init__(self, n)\", \"def _Minimum_operations\",\"def public_Minimum_operations\"], [\"class MNO\", \"def __init__(self, n)\", \"def __Minimum_operations\",\"def public_Minimum_operations\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/127", "question": "Firstly, design an **FPV** class using Python language, which has instance attributes **arr**, **k**, and **x**, a private function **private_Find_Proximity_Values**, and a public function **public_Find_Proximity_Values**. Then, implement the following problem in the private function **private_Find_Proximity_Values**. Finally, call the private function **private_Find_Proximity_Values** in the public function **public_Find_Proximity_Values** to return the result.\nProblem: Given a sorted array **arr**, two integers **k** and **x**, find the **k** numbers closest to **x** (the difference between the two numbers is the smallest) from the array. The returned result must be sorted in ascending order. An integer **a** is closer to **x** than an integer **b** if: |a-x| < |b-x| or |a-x| == |b-x| and a < b.", "test_list": ["assert candidate([1,2,3,4,5],4,3)==[1,2,3,4]", "assert candidate([1,2,3,4,5],4,-1)==[1,2,3,4]"], "test_function": "def test_run(content1,content2,content3):\n    return FPV(content1,content2,content3).public_Find_Proximity_Values()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FPV\", \"def __init__(self, arr, k, x)\", \"def _private_Find_Proximity_Values\",\"def public_Find_Proximity_Values\"], [\"class FPV\", \"def __init__(self, arr, k, x)\", \"def __private_Find_Proximity_Values\",\"def public_Find_Proximity_Values\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/128", "question": "Firstly, design a **JS** class using the Python language, which has an instance attribute **nums**, a private function **private_Judgment_segmentation**, and a public function **public_Judgment_segmentation**. Then, implement the following problem in the private function **private_Judgment_segmentation**. Finally, call the private function **private_Judgment_segmentation** in the public function **public_Judgment_segmentation** to return the result.\nProblem: Given an integer array **nums** sorted in non-decreasing order. Please judge whether it is possible to satisfy the following two conditions while dividing **nums** into one or more sub-sequences: each sub-sequence is a continuous increasing sequence (that is, each integer is exactly one larger than the previous one); the length of all sub-sequences is at least 3. If **nums** can be divided and meet the above conditions, return True; otherwise, return False.", "test_list": ["assert candidate([1,2,3,3,4,5])==True", "assert candidate([1,2,3,3,4,4,5,5])==True", "assert candidate([1,2,3,4,4,5])==False"], "test_function": "def test_run(content1):\n    return JS(content1).public_Judgment_segmentation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JS\", \"def __init__(self, nums)\", \"def _private_Judgment_segmentation\",\"def public_Judgment_segmentation\"], [\"class JS\", \"def __init__(self, nums)\", \"def _private_Judgment_segmentation\",\"def public_Judgment_segmentation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/129", "question": "Firstly, design an **MPT** class using Python language, which has an instance attribute **s**, a private function **Minimum_Times**, and a public function **public_Minimum_Times**. Then, implement the following problem in the private function **Minimum_Times**. Finally, call the private function **Minimum_Times** in the public function **public_Minimum_Times** to return the result.\nProblem: There is a strange printer with the following two special requirements: 1. The printer can only print a sequence composed of the same character each time; 2. It can print a new character at any position from the beginning to the end each time, and it will overwrite the original characters. Given a string **s**, your task is to calculate the minimum number of times this printer needs to print it.", "test_list": ["assert candidate(\"aaabbb\")==2", "assert candidate(\"aba\")==2"], "test_function": "def test_run(content1):\n    return MPT(content1).public_Minimum_Times()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MPT\", \"def __init__(self, s)\", \"def _Minimum_Times\",\"def public_Minimum_Times\"], [\"class MPT\", \"def __init__(self, s)\", \"def __Minimum_Times\",\"def public_Minimum_Times\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/130", "question": "Firstly, design an **NDC** class using Python language, which has an instance attribute **nums**, a private function **private_Non_decreasing_column**, and a public function **public_Non_decreasing_column**. Then, implement the following problem in the private function **private_Non_decreasing_column**. Finally, call the private function **private_Non_decreasing_column** in the public function **public_Non_decreasing_column** to return the result.\nProblem: Given an integer array **nums** of length **n**, please determine whether this array can become a non-decreasing sequence by changing at most one element. Definition of non-decreasing sequence: For any **i** (0 <= i <= n-2) in the array, it always satisfies that nums[i]<= nums[i + 1].", "test_list": ["assert candidate([4,2,3])==True", "assert candidate([4,2,1])==False"], "test_function": "def test_run(content1):\n    return NDC(content1).public_Non_decreasing_column()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NDC\", \"def __init__(self, nums)\", \"def _private_Non_decreasing_column\",\"def public_Non_decreasing_column\"], [\"class NDC\", \"def __init__(self, nums)\", \"def __private_Non_decreasing_column\",\"def public_Non_decreasing_column\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/131", "question": "Firstly, design an **AL** class using Python language, which has instance attributes **n** and **k**, a private function **private_Answer_List**, and a public function **public_Answer_List**. Then, return the constructed answer list **answer** in the private function **private_Answer_List**. Finally, call the private function **private_Answer_List** in the public function **public_Answer_List** to return the result.\nProblem: Given two integers **n** and **k**, please construct an answer list **answer**. This list should contain **n** different positive integers from 1 to **n**, and at the same time meet the following condition: Assuming the list is answer=[a1, a2, a3, ... , an], then the list [|a1 - a2|,|a2 - a3|,|a3 - a4|,...,|an-1 - an|] should have exactly **k** different integers. Return the list **answer**.", "test_list": ["assert candidate(3,1)==[1, 2, 3]", "assert candidate(3,2)==[1, 3, 2]"], "test_function": "def test_run(content1,content2):\n    return AL(content1,content2).public_Answer_List()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AL\", \"def __init__(self, n, k)\", \"def _private_Answer_List\",\"def public_Answer_List\"], [\"class AL\", \"def __init__(self, n, k)\", \"def _private_Answer_List\",\"def public_Answer_List\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/132", "question": "Firstly, design a class named **LIS** using Python language, which has instance attribute **nums**, a private function **lo_in_sub**, and a public function **public_lo_in_sub**. Then, in the private function **lo_in_sub**, return the count of the longest increasing subsequence from the unsorted integer array **nums**. Finally, in the public function **public_lo_in_sub**, call the private function **lo_in_sub** to return the result.", "test_list": ["assert candidate([1,3,5,4,7])==2", "assert candidate([2,2,2,2,2])==5"], "test_function": "def test_run(content1):\n    return LIS(content1).public_lo_in_sub()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LIS\", \"def __init__(self, nums)\", \"def _lo_in_sub\",\"def public_lo_in_sub\"], [\"class LIS\", \"def __init__(self, nums)\", \"def __lo_in_sub\",\"def public_lo_in_sub\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/133", "question": "Firstly, design a **CDT** class using Python language, which has an instance attribute **forest**, a private function **private_Chop_down_trees**, and a public function **public_Chop_down_trees**. Then, implement the following problem in the private function **private_Chop_down_trees**. Finally, call the private function **private_Chop_down_trees** in the public function **public_Chop_down_trees** to return the result.\nProblem: The forest is represented by an m x n matrix. In this matrix, 0 represents an obstacle that cannot be touched; 1 represents the ground where you can walk. Numbers larger than 1 represent cells with trees, which can be walked on, and the number represents the height of the tree. At each step, you can move one unit in one of the four directions: up, down, left, or right. If there is a tree where you stand, you can decide whether to cut it down. You need to cut down all the trees from low to high according to the height of the trees. After cutting down a tree, the value of the cell becomes **1** (i.e., it becomes the ground). You will start working from the point (0, 0), and return the minimum number of steps you need to take to cut down all the trees. If you cannot cut down all the trees, return -1.", "test_list": ["assert candidate([[1,2,3],[0,0,4],[7,6,5]])==6", "assert candidate([[1,2,3],[0,0,0],[7,6,5]])==-1", "assert candidate([[2,3,4],[0,0,5],[8,7,6]])==6"], "test_function": "def test_run(content1):\n    return CDT(content1).public_Chop_down_trees()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CDT\", \"def __init__(self, forest)\", \"def _private_Chop_down_trees\",\"def public_Chop_down_trees\"], [\"class CDT\", \"def __init__(self, forest)\", \"def __private_Chop_down_trees\",\"def public_Chop_down_trees\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/134", "question": "Firstly, design a **VS** class using Python language, which has an instance attribute **s**, a private function **private_Valid_String**, and a public function **public_Valid_String**. Then, implement the following problem in the private function **private_Valid_String**. Finally, call the private function **private_Valid_String** in the public function **public_Valid_String** and return the result.\nProblem: Given a string that only contains three types of characters, the supported character types are '(', ')', and '*'. Please check whether this string is a valid string. If it is a valid string, return True; otherwise, return False.", "test_list": ["assert candidate(\"()\")==True", "assert candidate(\"(*)\")==True", "assert candidate(\"(*))\")==True"], "test_function": "def test_run(content1):\n    return VS(content1).public_Valid_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VS\", \"def __init__(self, s)\", \"def _private_Valid_String\",\"def public_Valid_String\"], [\"class VS\", \"def __init__(self, s)\", \"def __private_Valid_String\",\"def public_Valid_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/135", "question": "Firstly, design a class **ME** using the Python language, which has an instance attribute **cards**, a private function **private_mathematical_expression**, and a public function **public_mathematical_expression**. Then, implement the following problem in the private function **private_mathematical_expression**. Finally, call the private function **private_mathematical_expression** in the public function **public_mathematical_expression** to return the result.\nProblem: Given an integer array **cards** of length 4. Assume there are 4 cards, each containing a number ranging from [1,9]. You should arrange the numbers on these cards into a mathematical expression using the operators ['+', '-', '*', '/'] and parentheses '(' and ')' to achieve the value 24. You must follow these rules: 1. The division operator '/' represents real number division, not integer division; 2. Each operation is between two numbers. Specifically, you cannot use \"-\" as a unary operator. For example, if cards = [1,1,1,1], the expression \"-1 -1 -1 -1\" is not allowed; 3. You cannot string numbers together. If cards = [1,2,1,2], the expression \"12 + 12\" is invalid. If such an expression can be obtained and its calculation result is 24, return True, otherwise return False.", "test_list": ["assert candidate([4, 1, 8, 7])==True", "assert candidate([1, 2, 1, 2])==False"], "test_function": "def test_run(content1):\n    return ME(content1).public_mathematical_expression()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ME\", \"def __init__(self, cards)\", \"def _private_mathematical_expression\",\"def public_mathematical_expression\"], [\"class ME\", \"def __init__(self, cards)\", \"def __private_mathematical_expression\",\"def public_mathematical_expression\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/136", "question": "Firstly, design an **OS** class using Python language, which has instance attributes **a** and **b**, a private function **private_Overlay_substring**, and a public function **public_Overlay_substring**. Then, implement the following problem in the private function **private_Overlay_substring**. Finally, call the private function **private_Overlay_substring** in the public function **public_Overlay_substring** to return the result.\nProblem: Given two strings **a** and **b**, find the minimum number of times string **a** needs to be repeatedly overlaid so that string **b** becomes a substring of the overlaid string **a**. If it does not exist, return -1.", "test_list": ["assert candidate(\"abcd\",\"cdabcdab\")==3", "assert candidate(\"a\",\"aa\")==2", "assert candidate(\"a\",\"a\")==1", "assert candidate(\"abc\",\"wxyz\")==-1"], "test_function": "def test_run(content1,content2):\n    return OS(content1,content2).public_Overlay_substring()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class OS\", \"def __init__(self, a, b)\", \"def _private_Overlay_substring\",\"def public_Overlay_substring\"], [\"class OS\", \"def __init__(self, a, b)\", \"def __private_Overlay_substring\",\"def public_Overlay_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/137", "question": "Firstly, design a **KC** class using Python language, which has instance attributes **n**, **k**, **row**, and **column**, a private function **private_Knight_Chessboard**, and a public function **public_Knight_Chessboard**. Then, implement the following problem in the private function **private_Knight_Chessboard**. Finally, call the private function **private_Knight_Chessboard** in the public function **public_Knight_Chessboard** to return the result.\nProblem: On an n x n international chessboard, a knight starts from the cell (row, column) and tries to make **k** moves. Rows and columns start from 0, so the top-left cell is (0,0), and the bottom-right cell is (n - 1, n - 1). The chess knight has 8 possible moves, each move is two cells in the basic direction, then one cell in the orthogonal direction. Each time the knight is to move, it randomly selects one from the 8 possible moves (even if the piece will leave the board), and then moves there. The knight continues to move until it has taken **k** steps or has left the board. Return the probability that the knight still remains on the board after it stops moving.", "test_list": ["assert candidate(3,2,0,0)==0.0625", "assert candidate(1,0,0,0)==1.00000"], "test_function": "def test_run(content1,content2,content3,content4):\n    return KC(content1,content2,content3,content4).public_Knight_Chessboard()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class KC\", \"def __init__(self, n, k, row, column)\", \"def _private_Knight_Chessboard\",\"def public_Knight_Chessboard\"], [\"class KC\", \"def __init__(self, n, k, row, column)\", \"def __private_Knight_Chessboard\",\"def public_Knight_Chessboard\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/138", "question": "Firstly, design an **MS** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Maximum_subarray**, and a public function **public_Maximum_subarray**. Then, implement the following problem in the private function **private_Maximum_subarray**. Finally, call the private function **private_Maximum_subarray** in the public function **public_Maximum_subarray** to return the result.\nProblem: Given an integer array **nums** and an integer **k**, find three non-overlapping subarrays of length **k** with the maximum sum of all numbers (3*k items) and return these three subarrays.", "test_list": ["assert candidate([1,2,1,2,6,7,5,1],2)==[0,3,5]", "assert candidate([1,2,1,2,1,2,1,2,1],2)==[0,2,4]"], "test_function": "def test_run(content1,content2):\n    return MS(content1,content2).public_Maximum_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MS\", \"def __init__(self, nums, k)\", \"def _private_Maximum_subarray\",\"def public_Maximum_subarray\"], [\"class MS\", \"def __init__(self, nums, k)\", \"def __private_Maximum_subarray\",\"def public_Maximum_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/139", "question": "Firstly, design a class named **SW** using Python language, which has instance attributes **stickers** and **target**, a private function **private_Sticker_Words**, and a public function **public_Sticker_Words**. Then, implement the following problem in the private function **private_Sticker_Words**. Finally, call the private function **private_Sticker_Words** in the public function **public_Sticker_Words** to return the result.\nProblem: There are **n** different types of stickers, each with a lowercase English word on it. You want to spell out a given string **target** by cutting individual letters from the collected stickers and rearranging them. If you wish, you can use each sticker multiple times, and the quantity of each sticker is unlimited. Return the minimum number of stickers required to spell out the **target**. If the task is impossible, return -1.", "test_list": ["assert candidate([\"with\",\"example\",\"science\"],\"thehat\")==3", "assert candidate([\"notice\",\"possible\"],\"basicbasic\")==-1"], "test_function": "def test_run(content1,content2):\n    return SW(content1,content2).public_Sticker_Words()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SW\", \"def __init__(self, stickers, target)\", \"def _private_Sticker_Words\",\"def public_Sticker_Words\"], [\"class SW\", \"def __init__(self, stickers, target)\", \"def __private_Sticker_Words\",\"def public_Sticker_Words\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/140", "question": "Firstly, design an **MT** class using the Python language, which has instance attributes **words** and **k**, a private function **private_Most_times**, and a public function **public_Most_times**. Then, in the private function **private_Most_times**, return the top **k** most frequently occurring words from a given word list **words** and an integer **k**. Finally, call the private function **private_Most_times** in the public function **public_Most_times** to return the result.", "test_list": ["assert candidate([\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"],2)==[\"i\", \"love\"]", "assert candidate([\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"],4)==[\"the\", \"is\", \"sunny\", \"day\"]"], "test_function": "def test_run(content1,content2):\n    return MT(content1,content2).public_Most_times()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MT\", \"def __init__(self, words, k)\", \"def _private_Most_times\",\"def public_Most_times\"], [\"class MT\", \"def __init__(self, words, k)\", \"def __private_Most_times\",\"def public_Most_times\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/141", "question": "Firstly, design an **AA** class using the Python language, which has an instance attribute **n**, a private function **private_Alternating_appearance**, and a public function **public_Alternating_appearance**. Then, implement the following problem in the private function **private_Alternating_appearance**. Finally, call the private function **private_Alternating_appearance** in the public function **public_Alternating_appearance** to return the result.\nProblem: Given a positive integer, check whether its binary representation always alternates between 0 and 1. In other words, the adjacent digits in the binary representation are never the same. If 0 and 1 alternate, return True; otherwise, return False.", "test_list": ["assert candidate(5)==True", "assert candidate(7)==False", "assert candidate(11)==False"], "test_function": "def test_run(content1):\n    return AA(content1).public_Alternating_appearance()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AA\", \"def __init__(self, n)\", \"def _private_Alternating_appearance\",\"def public_Alternating_appearance\"], [\"class AA\", \"def __init__(self, n)\", \"def __private_Alternating_appearance\",\"def public_Alternating_appearance\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/142", "question": "Firstly, design an **IA** class using Python language, which has an instance attribute **grid**, a private function **private_Island_area**, and a public function **public_Island_area**. Then, implement the following problem in the private function **private_Island_area**. Finally, call the private function **private_Island_area** in the public function **public_Island_area** to return the result.\nProblem: Given a binary matrix **grid** of size m x n. An island is a combination of some adjacent 1s (representing land), where adjacency requires that two 1s must be adjacent in the horizontal or vertical four directions. It can be assumed that the four edges of the **grid** are surrounded by 0s (representing water). The area of the island is the number of cells on the island with a value of 1. Calculate and return the largest island area in the **grid**. If there is no island, return an area of 0.", "test_list": ["assert candidate([[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]])==6", "assert candidate([[0,0,0,0,0,0,0,0]])==0"], "test_function": "def test_run(content1):\n    return IA(content1).public_Island_area()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IA\", \"def __init__(self, grid)\", \"def _private_Island_area\",\"def public_Island_area\"], [\"class IA\", \"def __init__(self, grid)\", \"def __private_Island_area\",\"def public_Island_area\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/143", "question": "Firstly, design an **ES** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Equal_sum**, and a public function **public_Equal_sum**. Then, in the private function **private_Equal_sum**, determine whether it is possible to divide this array into **k** non-empty subsets with equal sums, based on a given integer array **nums** and a positive integer **k**. Finally, call the private function **private_Equal_sum** in the public function **public_Equal_sum** to return the result.", "test_list": ["assert candidate([4, 3, 2, 3, 5, 2, 1],4)==True", "assert candidate([1,2,3,4],3)==False"], "test_function": "def test_run(content1,content2):\n    return ES(content1,content2).public_Equal_sum()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ES\", \"def __init__(self, nums, k)\", \"def _private_Equal_sum\",\"def public_Equal_sum\"], [\"class ES\", \"def __init__(self, nums, k)\", \"def __private_Equal_sum\",\"def public_Equal_sum\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/144", "question": "Firstly, design a **BS** class using Python language, which has an instance attribute **positions**, a private function **private_Block_stacking**, and a public function **public_Block_stacking**. Then, implement the following problem in the private function **private_Block_stacking**. Finally, call the private function **private_Block_stacking** in the public function **public_Block_stacking** to return the result.\nProblem: Given a two-dimensional integer array **positions**, where positions[i] = [left_i, sideLength_i] indicates: the side length of the i-th block is **sideLength_i**, and its left side aligns with the coordinate point **left_i** on the x-axis. Each block falls from a height higher than all the currently landed blocks. The block falls in the negative direction of the y-axis until it lands on the top edge of another square or on the x-axis. A block merely brushing past the left or right side of another block does not count as landing. Once landed, it will be fixed in place and cannot move. After each block falls, you must record the highest height of the currently stable stacked blocks.", "test_list": ["assert candidate([[1,2],[2,3],[6,1]])==[2,5,5]", "assert candidate([[100,100],[200,100]])==[100,100]"], "test_function": "def test_run(content1):\n    return BS(content1).public_Block_stacking()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BS\", \"def __init__(self, positions)\", \"def _private_Block_stacking\",\"def public_Block_stacking\"], [\"class BS\", \"def __init__(self, positions)\", \"def __private_Block_stacking\",\"def public_Block_stacking\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/145", "question": "Firstly, design a **DC** class using the Python language, which has instance attributes **s1** and **s2**, a private function **private_Delete_Characters**, and a public function **public_Delete_Characters**. Then, in the private function **private_Delete_Characters**, return the minimum sum of the ASCII values of the characters that need to be deleted to make the two given strings **s1** and **s2** equal. Finally, call the private function **private_Delete_Characters** in the public function **public_Delete_Characters** to return the result.", "test_list": ["assert candidate(\"sea\",\"eat\")==231", "assert candidate(\"delete\",\"leet\")==403"], "test_function": "def test_run(content1,content2):\n    return DC(content1,content2).public_Delete_Characters()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DC\", \"def __init__(self, s1, s2)\", \"def _private_Delete_Characters\",\"def public_Delete_Characters\"], [\"class DC\", \"def __init__(self, s1, s2)\", \"def __private_Delete_Characters\",\"def public_Delete_Characters\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/146", "question": "Firstly, design a **POE** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Product_of_elements**, and a public function **public_Product_of_elements**. Then, in the private function **private_Product_of_elements**, return the number of continuous subarrays where the product of all elements in the subarray is strictly less than **k**, given an integer array **nums** and an integer **k**. Finally, in the public function **public_Product_of_elements**, call the private function **private_Product_of_elements** to return the result.", "test_list": ["assert candidate([10,5,2,6],100)==8", "assert candidate([1,2,3],0)==0"], "test_function": "def test_run(content1,content2):\n    return POE(content1,content2).public_Product_of_elements()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class POE\", \"def __init__(self, nums, k)\", \"def _private_Product_of_elements\",\"def public_Product_of_elements\"], [\"class POE\", \"def __init__(self, nums, k)\", \"def __private_Product_of_elements\",\"def public_Product_of_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/147", "question": "Firstly, design a **BS** class using Python language, which has instance attributes **prices** and **fee**, a private function **private_buy_share**, and a public function **public_buy_share**. Then, implement the following problem in the private function **private_buy_share**. Finally, call the private function **private_buy_share** in the public function **public_buy_share** to return the result.\nProblem: Given an integer array **prices**, where prices[i] represents the stock price on the i-th day; the integer **fee** represents the transaction fee for trading stocks. You can complete transactions unlimited times, but you need to pay a fee for each transaction. If you have already purchased a stock, you cannot continue to buy stocks before selling it. Return the maximum profit that can be obtained.", "test_list": ["assert candidate([1, 3, 2, 8, 4, 9],2)==8", "assert candidate([1,3,7,5,10,3],3)==6"], "test_function": "def test_run(content1,content2):\n    return BS(content1,content2).public_buy_share()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BS\", \"def __init__(self, prices, fee)\", \"def _private_buy_share\",\"def public_buy_share\"], [\"class BS\", \"def __init__(self, prices, fee)\", \"def __private_buy_share\",\"def public_buy_share\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/148", "question": "Firstly, design a **BC** class using the Python language, which has an instance attribute **bits**, a private function **private_Bit_character**, and a public function **public_Bit_character**. Then, implement the following problem in the private function **private_Bit_character**. Finally, call the private function **private_Bit_character** in the public function **public_Bit_character** to return the result.\nProblem: There are two special characters: the first type of character can be represented by a one-bit 0; the second type of character can be represented by two bits (10 or 11). Given a binary array **bits** ending with 0, if the last character must be a one-bit character, return True; otherwise, return False.", "test_list": ["assert candidate([1, 0, 0])==True", "assert candidate([1,1,1,0])==False"], "test_function": "def test_run(content1):\n    return BC(content1).public_Bit_character()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BC\", \"def __init__(self, bits)\", \"def _private_Bit_character\",\"def public_Bit_character\"], [\"class BC\", \"def __init__(self, bits)\", \"def __private_Bit_character\",\"def public_Bit_character\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/149", "question": "Firstly, design a **BL** class using Python language, which has instance attributes **nums1** and **nums2**, a private function **private_BLongest_length**, and a public function **public_BLongest_length**. Then, in the private function **private_BLongest_length**, return the length of the longest common subarray from the two given integer arrays **nums1** and **nums2**. Finally, call the private function **private_BLongest_length** in the public function **public_BLongest_length** to return the result.", "test_list": ["assert candidate([1,2,3,2,1],[3,2,1,4,7])==3", "assert candidate([0,0,0,0,0],[0,0,0,0,0])==5"], "test_function": "def test_run(content1,content2):\n    return BL(content1,content2).public_BLongest_length()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BL\", \"def __init__(self, nums1, nums2)\", \"def _private_BLongest_length\",\"def public_BLongest_length\"], [\"class BL\", \"def __init__(self, nums1, nums2)\", \"def __private_BLongest_length\",\"def public_BLongest_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/150", "question": "Firstly, design an **AD** class using Python language, which has instance attributes **nums** and **k**, a private function **private_absolute_difference**, and a public function **public_absolute_difference**. Then, implement the following problem in the private function **private_absolute_difference**. Finally, call the private function **private_absolute_difference** in the public function **public_absolute_difference** to return the result.\nProblem: A pair of numbers (a, b) is composed of integers **a** and **b**, and the distance of the pair is defined as the absolute difference between **a** and **b**. Given an integer array **nums** and an integer **k**, the pair is composed of nums[i] and nums[j] and satisfies 0<= i<j<nums.length. Return the k-th smallest pair distance among all pair distances.", "test_list": ["assert candidate([1,3,1],1)==0", "assert candidate([1,1,1],2)==0", "assert candidate([1,6,1],3)==5"], "test_function": "def test_run(content1,content2):\n    return AD(content1,content2).public_absolute_difference()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AD\", \"def __init__(self, nums, k)\", \"def _private_absolute_difference\",\"def public_absolute_difference\"], [\"class AD\", \"def __init__(self, nums, k)\", \"def __private_absolute_difference\",\"def public_absolute_difference\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/151", "question": "Firstly, design an **ED** class using the Python language, which has an instance attribute **words**, a private function **private_English_Dictionary**, and a public function **public_English_Dictionary**. Then, implement the following problem in the private function **private_English_Dictionary**. Finally, call the private function **private_English_Dictionary** in the public function **public_English_Dictionary** to return the result.\nProblem: Given a string array **words** that forms an English dictionary, return the longest word in **words**. This word is formed by gradually adding one letter from other words in the **words** dictionary. If there are multiple feasible answers, return the word with the smallest lexicographical order among the answers. If there is no answer, return an empty string.", "test_list": ["assert candidate([\"w\",\"wo\",\"wor\",\"worl\", \"world\"])==\"world\"", "assert candidate([\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"])==\"apple\""], "test_function": "def test_run(content1):\n    return ED(content1).public_English_Dictionary()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ED\", \"def __init__(self, words)\", \"def _private_English_Dictionary\",\"def public_English_Dictionary\"], [\"class ED\", \"def __init__(self, words)\", \"def __private_English_Dictionary\",\"def public_English_Dictionary\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/152", "question": "Firstly, design an **LS** class using Python language, which has instance attributes **head** and **k**, a private function **private_List_separation**, and a public function **public_List_separation**. Then, implement the following problem in the private function **private_List_separation**. Finally, call the private function **private_List_separation** in the public function **public_List_separation** to return the result.\nProblem: Given a singly linked list with a head node **head** and an integer **k**, please design an algorithm to divide the linked list into **k** consecutive parts. The length of each part should be as equal as possible: the difference in length between any two parts cannot exceed 1. This may cause some parts to be null. These **k** parts should be arranged in the order they appear in the linked list, and the length of the parts in the front should be greater than or equal to the length of the parts in the back. Return an array composed of the above **k** parts.", "test_list": ["assert candidate([1,2,3],5)==[[1],[2],[3],[],[]]", "assert candidate([1,2,3,4,5,6,7,8,9,10],3)==[[1,2,3,4],[5,6,7],[8,9,10]]"], "test_function": "def test_run(content1,content2):\n    return LS(content1,content2).public_public_List_separation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LS\", \"def __init__(self, head, k)\", \"def _private_List_separation\",\"def public_List_separation\"], [\"class LS\", \"def __init__(self, head, k)\", \"def __private_List_separation\",\"def public_List_separation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/153", "question": "Firstly, design a **NOS** class using the Python language, which has an instance attribute **s**, a private function **private_Number_of_sequences**, and a public function **public_Number_of_sequences**. Then, in the private function **private_Number_of_sequences**, return the number of different non-empty palindrome sub-sequences in a given string **s**. Finally, in the public function **public_Number_of_sequences**, call the private function **private_Number_of_sequences** to return the result.", "test_list": ["assert candidate('bccb')==6", "assert candidate('abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba')==104860361"], "test_function": "def test_run(content1):\n    return NOS(content1).public_Number_of_sequences()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NOS\", \"def __init__(self, s)\", \"def _private_Number_of_sequences\",\"def public_Number_of_sequences\"], [\"class NOS\", \"def __init__(self, s)\", \"def __private_Number_of_sequences\",\"def public_Number_of_sequences\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/154", "question": "Firstly, design an **MI** class using Python language, which has an instance attribute **n**, a private function **private_monotonic_increase**, and a public function **public_monotonic_increase**. Then, implement the following problem in the private function **private_monotonic_increase**. Finally, call the private function **private_monotonic_increase** in the public function **public_monotonic_increase** to return the result. \nProblem: An integer is said to be monotonically increasing if and only if each pair of adjacent digits **x** and **y** satisfy x <= y. Given an integer **n**, return the largest number less than or equal to **n** that is monotonically increasing.", "test_list": ["assert candidate(10)==9", "assert candidate(1234)==1234", "assert candidate(332)==299"], "test_function": "def test_run(content1):\n    return MI(content1).public_monotonic_increase()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MI\", \"def __init__(self, n)\", \"def _private_monotonic_increase\",\"def public_monotonic_increase\"], [\"class MI\", \"def __init__(self, n)\", \"def __private_monotonic_increase\",\"def public_monotonic_increase\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/155", "question": "Firstly, design a class **TR** using the Python language, which has an instance attribute **temperatures**, a private function **private_Temperature_rise**, and a public function **public_Temperature_rise**. Then, implement the following problem in the private function **private_Temperature_rise**. Finally, call the private function **private_Temperature_rise** in the public function **public_Temperature_rise** to return the result.\nProblem: Given an integer array **temperatures** representing the temperature of each day, return an array **answer**, where answer[i] refers to the number of days until the next higher temperature for the i-th day. If the temperature will not rise after this, please replace it with 0 at this position.", "test_list": ["assert candidate([73,74,75,71,69,72,76,73])==[1,1,4,2,1,1,0,0]", "assert candidate([30,40,50,60])==[1,1,1,0]", "assert candidate([30,60,90])==[1,1,0]"], "test_function": "def test_run(content1):\n    return TR(content1).public_Temperature_rise()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TR\", \"def __init__(self, temperatures)\", \"def _private_Temperature_rise\",\"def public_Temperature_rise\"], [\"class TR\", \"def __init__(self, temperatures)\", \"def __private_Temperature_rise\",\"def public_Temperature_rise\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/156", "question": "Firstly, design a class **MN** using the Python language, which has an instance attribute **nums**, a private function **private_Maximum_number**, and a public function **public_Maximum_number**. Then, implement the following problem in the private function **private_Maximum_number**. Finally, call the private function **private_Maximum_number** in the public function **public_Maximum_number** to return the result.\nProblem: Given an integer array **nums**, you can perform some operations on it. In each operation, choose any nums[i], delete it and get the points of nums[i]. After that, you must delete all elements equal to nums[i]-1 and nums[i]+1. Initially, you have 0 points. Return the maximum points that can be obtained through these operations.", "test_list": ["assert candidate([3,4,2])==6", "assert candidate([2,2,3,3,3,4])==9"], "test_function": "def test_run(content1):\n    return MN(content1).public_Maximum_number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MN\", \"def __init__(self, nums)\", \"def _private_Maximum_number\",\"def public_Maximum_number\"], [\"class MN\", \"def __init__(self, nums)\", \"def __private_Maximum_number\",\"def public_Maximum_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/157", "question": "Firstly, design a class **NN** using the Python language, which has instance attributes **times**, **n** and **k**, a private function **private_network_node**, and a public function **public_network_node**. Then, implement the following problem in the private function **private_network_node**. Finally, call the private function **private_network_node** in the public function **public_network_node** to return the result.\nProblem: There are **n** network nodes, labeled from 1 to n. Given a list **times**, which represents the transmission time of signals passing through directed edges. times[i] = (u_i, v_i, w_i), where **u_i** is the source node, **v_i** is the target node, and **w_i** is the time it takes for a signal to pass from the source node to the target node. Now, a signal is sent from a certain node **K**, how long will it take for all nodes to receive the signal? If not all nodes can receive the signal, return -1.", "test_list": ["assert candidate([[2,1,1],[2,3,1],[3,4,1]],4,2)==2", "assert candidate([[1,2,1]],2,1)==1", "assert candidate([[1,2,1]],2,2)==-1"], "test_function": "def test_run(content1,content2,content3):\n    return NN(content1,content2,content3).public_network_node()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NN\", \"def __init__(self, times, n, k)\", \"def _private_network_node\",\"def public_network_node\"], [\"class NN\", \"def __init__(self, times, n, k)\", \"def __private_network_node\",\"def public_network_node\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/158", "question": "Firstly, design an **INA** class using Python language, which has an instance attribute **target**, a private function **private_Infinite_number_axis**, and a public function **public_Infinite_number_axis**. Then, implement the following problem in the private function **private_Infinite_number_axis**. Finally, call the private function **private_Infinite_number_axis** in the public function **public_Infinite_number_axis** to return the result.\nProblem: On an infinitely long number axis, you stand at position 0, and the endpoint is at the **target** position. You can make a certain number of moves **numMoves**: each time you can choose to move left or right, and for the i-th move (from i==1 to i==numMoves), you walk **i** steps in the chosen direction. Given an integer **target**, return the minimum number of moves required to reach the target (i.e., the minimum **numMoves**).", "test_list": ["assert candidate(2)==3", "assert candidate(3)==2"], "test_function": "def test_run(content1):\n    return INA(content1).public_Infinite_number_axis()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class INA\", \"def __init__(self, target)\", \"def _private_Infinite_number_axis\",\"def public_Infinite_number_axis\"], [\"class INA\", \"def __init__(self, target)\", \"def __private_Infinite_number_axis\",\"def public_Infinite_number_axis\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/159", "question": "Firstly, design an **IC** class using Python language, which has an instance attribute **intervals**, a private function **private_Include_Collection**, and a public function **public_Include_Collection**. Then, implement the following problem in the private function **private_Include_Collection**. Finally, call the private function **private_Include_Collection** in the public function **public_Include_Collection** to return the result.\nProblem: Given a two-dimensional integer array **intervals**, where intervals[i] = [start_i, end_i] represents all integers from **start_i** to **end_i**, including **start_i** and **end_i**. The inclusion set is an array named **nums**, and it satisfies that each interval in **intervals** has at least two integers in **nums**. Return the possible minimum size of the inclusion set.", "test_list": ["assert candidate([[1,3],[3,7],[8,9]])==5", "assert candidate([[1,3],[1,4],[2,5],[3,5]])==3", "assert candidate([[1,2],[2,3],[2,4],[4,5]])==5"], "test_function": "def test_run(content1):\n    return IC(content1).public_Include_Collection()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IC\", \"def __init__(self, intervals)\", \"def _private_Include_Collection\",\"def public_Include_Collection\"], [\"class IC\", \"def __init__(self, intervals)\", \"def __private_Include_Collection\",\"def public_Include_Collection\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/160", "question": "Firstly, design a class **SP** using Python language, which has an instance attribute **s**, a private function **private_String_partitioning**, and a public function **public_String_partitioning**. Then, implement the following problem in the private function **private_String_partitioning**. Finally, call the private function **private_String_partitioning** in the public function **public_String_partitioning** to return the result.\nProblem: Given a string **s**, partition this string into as many segments as possible, with the same letter appearing at most once in a segment, and return a list representing the length of each string segment.\nThe partition result needs to satisfy: concatenating all partition results in order, the string obtained is still **s**.", "test_list": ["assert candidate(\"ababcbacadefegdehijhklij\")==[9,7,8]", "assert candidate(\"eccbbbbdec\")==[10]"], "test_function": "def test_run(content1):\n    return SP(content1).public_String_partitioning()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SP\", \"def __init__(self, s)\", \"def _private_String_partitioning\",\"def public_String_partitioning\"], [\"class SP\", \"def __init__(self, s)\", \"def __private_String_partitioning\",\"def public_String_partitioning\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/161", "question": "Firstly, design a **PS** class using Python language, which has instance attributes **n** and **mines**, a private function **private_Plus_sign**, and a public function **public_Plus_sign**. Then, implement the following problem in the private function **private_Plus_sign**. Finally, call the private function **private_Plus_sign** in the public function **public_Plus_sign** to return the result.\nProblem: In an n x n matrix **grid**, every element is 1 except for the elements given as 0 in the array **mines**. mines[i]=[x_i,y_i] indicates grid[x_i][y_i]==0. Return the order of the largest axis-aligned plus sign of 1s in **grid**. If no plus sign is found, return 0.", "test_list": ["assert candidate(5,[[4, 2]])==2", "assert candidate(1,[[0, 0]])==0"], "test_function": "def test_run(content1,content2):\n    return PS(content1,content2).public_Plus_sign()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PS\", \"def __init__(self, n, mines)\", \"def _private_Plus_sign\",\"def public_Plus_sign\"], [\"class PS\", \"def __init__(self, n, mines)\", \"def __private_Plus_sign\",\"def public_Plus_sign\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/162", "question": "Firstly, design an **ES** class using Python language, which has an instance attribute **row**, a private function **private_Exchange_seats**, and a public function **public_Exchange_seats**. Then, implement the following problem in the private function **private_Exchange_seats**. Finally, call the private function **private_Exchange_seats** in the public function **public_Exchange_seats** to return the result.\nProblem: There are **n** pairs of couples sitting on **2n** seats arranged in a row, and they want to hold each other's hands. People and seats are represented by an integer array **row**, where row[i] is the ID of the person sitting in the i-th seat. The couples are numbered in order, the first pair is (0, 1), the second pair is (2, 3), and so on, the last pair is (2n-2, 2n-1). Return the minimum number of seat swaps so that each couple can sit together side by side. You can choose any two people for each swap, and have them stand up and exchange seats.", "test_list": ["assert candidate([0,2,1,3])==1", "assert candidate([3,2,0,1])==0"], "test_function": "def test_run(content1):\n    return ES(content1).public_Exchange_seats()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ES\", \"def __init__(self, row)\", \"def _private_Exchange_seats\",\"def public_Exchange_seats\"], [\"class ES\", \"def __init__(self, row)\", \"def __private_Exchange_seats\",\"def public_Exchange_seats\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/163", "question": "Firstly, design a **JM** class using Python language, which has an instance attribute **matrix**, a private function **private_judgment_matrix**, and a public function **public_judgment_matrix**. Then, in the private function **private_judgment_matrix**, determine whether a given m x n **matrix** is a Toeplitz matrix. If it is, return True; otherwise, return False. Finally, call the private function **private_judgment_matrix** in the public function **public_judgment_matrix** to return the result.", "test_list": ["assert candidate([[1,2,3,4],[5,1,2,3],[9,5,1,2]])==True", "assert candidate([[1,2],[2,2]])==False"], "test_function": "def test_run(content1):\n    return JM(content1).public_judgment_matrix()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JM\", \"def __init__(self, matrix)\", \"def _private_judgment_matrix\",\"def public_judgment_matrix\"], [\"class JM\", \"def __init__(self, matrix)\", \"def _private_judgment_matrix\",\"def public_judgment_matrix\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/164", "question": "First, design an **RL** class using the Python language, which has an instance attribute **s**, a private function **private_Rearrange_letters**, and a public function **public_Rearrange_letters**. Then, implement the following problem in the private function **private_Rearrange_letters**. Finally, call the private function **private_Rearrange_letters** in the public function **public_Rearrange_letters** to return the result.\nProblem: Given a string **s**, check if it is possible to rearrange its letters so that no two adjacent characters are the same. Return any possible rearrangement of **s**. If it is not feasible, return an empty string \"\".", "test_list": ["assert candidate(\"aab\")==\"aba\"", "assert candidate(\"aaab\")==\"\""], "test_function": "def test_run(content1):\n    return RL(content1).public_Rearrange_letters()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RL\", \"def __init__(self, s)\", \"def _private_Rearrange_letters\",\"def public_Rearrange_letters\"], [\"class RL\", \"def __init__(self, s)\", \"def _private_Rearrange_letters\",\"def public_Rearrange_letters\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/165", "question": "Firstly, design an **MNB** class using the Python language, which has an instance attribute **arr**, a private function **private_Maximum_number_blocks**, and a public function **public_Maximum_number_blocks**. Then, implement the following problem in the private function **private_Maximum_number_blocks**. Finally, call the private function **private_Maximum_number_blocks** in the public function **public_Maximum_number_blocks** to return the result.\nProblem: Given an integer array **arr**, split **arr** into several chunks, and sort these chunks separately. Then connect them together so that the result of the connection is the same as the original array sorted in ascending order. Return the maximum number of chunks that the array can be divided into.", "test_list": ["assert candidate([5,4,3,2,1])==1", "assert candidate([2,1,3,4,4])==4"], "test_function": "def test_run(content1):\n    return MNB(content1).public_Maximum_number_blocks()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNB\", \"def __init__(self, arr)\", \"def _private_Maximum_number_blocks\",\"def public_Maximum_number_blocks\"], [\"class MNB\", \"def __init__(self, arr)\", \"def __private_Maximum_number_blocks\",\"def public_Maximum_number_blocks\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/166", "question": "Firstly, design a class named **SS** using Python language, which includes an instance attribute **arr**, a private function **private_Sort_separately**, and a public function **public_Sort_separately**. Then, implement the following problem in the private function **private_Sort_separately**. Finally, call the private function **private_Sort_separately** in the public function **public_Sort_separately** and return the result.\nProblem: Given an integer array **arr** of length **n**, which represents the permutation of integers in the range [0, n - 1], divide **arr** into several blocks (i.e., partitions) and sort each block separately. After connecting them, make the result of the connection the same as the original array sorted in ascending order, and return the maximum number of blocks that the array can be divided into.", "test_list": ["assert candidate([4,3,2,1,0])==1", "assert candidate([1,0,2,3,4])==4"], "test_function": "def test_run(content1):\n    return SS(content1).public_Sort_separately()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SS\", \"def __init__(self, arr)\", \"def _private_Sort_separately\",\"def public_Sort_separately\"], [\"class SS\", \"def __init__(self, arr)\", \"def __private_Sort_separately\",\"def public_Sort_separately\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/167", "question": "Firstly, design a class **SPB** using Python language, which has an instance attribute **board**, a private function **private_Solving_puzzle_board**, and a public function **public_Solving_puzzle_board**. Then, implement the following problem in the private function **private_Solving_puzzle_board**. Finally, call the private function **private_Solving_puzzle_board** in the public function **public_Solving_puzzle_board** to return the result.\nProblem: On a 2 x 3 **board**, there are 5 tiles represented by numbers 1~5, and an empty space represented by 0. A move is defined as swapping 0 with an adjacent number (up, down, left, or right). The puzzle is solved when the **board** result is [[1,2,3],[4,5,0]]. Given an initial state of the puzzle **board**, return the minimum number of moves to solve the puzzle. If the puzzle cannot be solved, return -1.", "test_list": ["assert candidate([[1,2,3],[4,0,5]])==1", "assert candidate([[1,2,3],[5,4,0]])==-1", "assert candidate([[4,1,2],[5,0,3]])==5"], "test_function": "def test_run(content1):\n    return SPB(content1).public_Solving_puzzle_board()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SPB\", \"def __init__(self, board)\", \"def _private_Solving_puzzle_board\",\"def public_Solving_puzzle_board\"], [\"class SPB\", \"def __init__(self, board)\", \"def __private_Solving_puzzle_board\",\"def public_Solving_puzzle_board\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/168", "question": "Firstly, design a class **LI** using Python language, which has an instance attribute **nums**, a private function **private_Local_inversion**, and a public function **public_Local_inversion**. Then, implement the following problem in the private function **private_Local_inversion**. Finally, call the private function **private_Local_inversion** in the public function **public_Local_inversion** and return the result.\nProblem: Given an integer array **nums** of length **n**, representing a permutation composed of all integers within the range [0, n - 1]. The number of global inversions is equal to the number of different index pairs (i, j) that satisfy the following conditions: 1. 0 <= i < j < n; 2. nums[i] > nums[j]; The number of local inversions is equal to the number of indexes **i** that satisfy the following conditions: 1. 0 <= i < n - 1; 2. nums[i] > nums[i + 1]; When the number of global inversions in the array **nums** equals the number of local inversions, return True; otherwise, return False.", "test_list": ["assert candidate([1,0,2])==True", "assert candidate([1,2,0])==False"], "test_function": "def test_run(content1):\n    return LI(content1).public_Local_inversion()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LI\", \"def __init__(self, nums)\", \"def _private_Local_inversion\",\"def public_Local_inversion\"], [\"class LI\", \"def __init__(self, nums)\", \"def __private_Local_inversion\",\"def public_Local_inversion\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/169", "question": "Firstly, design a class **GS** using the Python language, which has an instance attribute **grid**, a private function **private_Grid_swimming**, and a public function **public_Grid_swimming**. Then, implement the following problem in the private function **private_Grid_swimming**. Finally, call the private function **private_Grid_swimming** in the public function **public_Grid_swimming** to return the result.\nProblem: In an n x n integer matrix **grid**, each cell's value grid[i][j] represents the platform height at position (i, j). When it starts to rain, the water level in the pool is **t** at time **t**. You can swim to any adjacent platform, but the prerequisite is that the water level must submerge these two platforms at the same time. Assuming you can move an infinite distance instantly, that is, it is assumed that swimming within the grid does not consume time. Of course, you must stay within the coordinate grid while swimming. You start from the top-left platform (0,0) of the coordinate grid, and return the minimum time required to reach the bottom-right platform (n-1, n-1) of the coordinate grid.", "test_list": ["assert candidate([[0,2],[1,3]])==3", "assert candidate([[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]])==16"], "test_function": "def test_run(content1):\n    return GS(content1).public_Grid_swimming()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GS\", \"def __init__(self, grid)\", \"def _private_Grid_swimming\",\"def public_Grid_swimming\"], [\"class GS\", \"def __init__(self, grid)\", \"def __private_Grid_swimming\",\"def public_Grid_swimming\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/170", "question": "Firstly, design a **GNR** class using Python language, which has instance attributes **n** and **k**, a private function **private_Given_number_rows**, and a public function **public_Given_number_rows**. Then, implement the following problem in the private function **private_Given_number_rows**. Finally, call the private function **private_Given_number_rows** in the public function **public_Given_number_rows** to return the result.\nProblem: We have constructed a table with **n** rows (indexed from 1). Initially, we write a 0 on the first row. For each subsequent row, we replace 0 with 01 and 1 with 10 in the previous row. Given the row number **n** and the ordinal **k**, return the k-th character (k indexed from 1) in the n-th row.", "test_list": ["assert candidate(1,1)==0", "assert candidate(2,1)==0", "assert candidate(2,2)==1"], "test_function": "def test_run(content1,content2):\n    return GNR(content1,content2).public_Given_number_rows()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GNR\", \"def __init__(self, n, k)\", \"def _private_Given_number_rows\",\"def public_Given_number_rows\"], [\"class GNR\", \"def __init__(self, n, k)\", \"def __private_Given_number_rows\",\"def public_Given_number_rows\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/171", "question": "Firstly, design a **CN** class using Python language, which has instance attributes **sx**, **sy**, **tx**, and **ty**, a private function **private_Convert_numbers**, and a public function **public_Convert_numbers**. Then, implement the following problem in the private function **private_Convert_numbers**. Finally, call the private function **private_Convert_numbers** in the public function **public_Convert_numbers** to return the result.\nProblem: Given four integers **sx**, **sy**, **tx**, and **ty**. If it is possible to reach the endpoint (tx, ty) from the starting point (sx, sy) through a series of transformations, return True, otherwise return False. From point (x, y), it can be transformed to either (x, x+y) or (x+y, y).", "test_list": ["assert candidate(1,1,3,5)==True", "assert candidate(1,1,2,2)==False", "assert candidate(1,1,1,1)==True"], "test_function": "def test_run(content1,content2,content3,content4):\n    return CN(content1,content2,content3,content4).public_Convert_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CN\", \"def __init__(self, sx, sy, tx, ty)\", \"def _private_Convert_numbers\",\"def public_Convert_numbers\"], [\"class CN\", \"def __init__(self, sx, sy, tx, ty)\", \"def __private_Convert_numbers\",\"def public_Convert_numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/172", "question": "First, design a class **FR** using the Python language, which has an instance attribute **answers**, a private function **private_Forest_Rabbit**, and a public function **public_Forest_Rabbit**. Then, implement the following problem in the private function **private_Forest_Rabbit**. Finally, call the private function **private_Forest_Rabbit** in the public function **public_Forest_Rabbit** to return the result.\nProblem: There is an unknown number of rabbits in the forest. Ask some of the rabbits **how many other rabbits have the same color as you (referring to the rabbit being asked)**, and collect the answers into an integer array **answers**, where answers[i] is the answer of the i-th rabbit.\nGiven the array **answers**, return the minimum number of rabbits in the forest.", "test_list": ["assert candidate([1,1,2])==5", "assert candidate([10,10,10])==11"], "test_function": "def test_run(content1):\n    return FR(content1).public_Forest_Rabbit()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FR\", \"def __init__(self, answers)\", \"def _private_Forest_Rabbit\",\"def public_Forest_Rabbit\"], [\"class FR\", \"def __init__(self, answers)\", \"def __private_Forest_Rabbit\",\"def public_Forest_Rabbit\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/173", "question": "Firstly, design a class **NM** using the Python language, which has an instance attribute **board**, a private function **private_Network_Matrix**, and a public function **public_Network_Matrix**. Then, implement the following problem in the private function **private_Network_Matrix**. Finally, call the private function **private_Network_Matrix** in the public function **public_Network_Matrix** to return the result.\nProblem: A n x n two-dimensional network **board** is composed only of 0 and 1. In each move, you can freely swap the positions of two columns or two rows. Return the minimum number of moves required to transform this matrix into a **chessboard**. If there is no feasible transformation, output -1.", "test_list": ["assert candidate([[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]])==2", "assert candidate([[0,1],[1,0]])==0", "assert candidate([[1,0],[1,0]])==-1"], "test_function": "def test_run(content1):\n    return NM(content1).public_Network_Matrix()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NM\", \"def __init__(self, board)\", \"def _private_Network_Matrix\",\"def public_Network_Matrix\"], [\"class NM\", \"def __init__(self, board)\", \"def __private_Network_Matrix\",\"def public_Network_Matrix\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/174", "question": "Firstly, design a class **CC** using Python language, which has an instance attribute **s**, a private function **private_Change_Case**, and a public function **public_Change_Case**. Then, implement the following problem in the private function **private_Change_Case**. Finally, call the private function **private_Change_Case** in the public function **public_Change_Case** to return the result.\nProblem: Given a string **s**, by changing the case of each letter in the string **s**, we can obtain a new string. Return the set of all possible strings that can be obtained.", "test_list": ["assert candidate(\"a1b2\")==[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]", "assert candidate(\"3z4\")==[\"3z4\",\"3Z4\"]"], "test_function": "def test_run(content1):\n    return CC(content1).public_Change_Case()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CC\", \"def __init__(self, s)\", \"def _private_Change_Case\",\"def public_Change_Case\"], [\"class CC\", \"def __init__(self, s)\", \"def __private_Change_Case\",\"def public_Change_Case\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/175", "question": "Firstly, design a class **MS** using the Python language, which has instance attributes **arr** and **k**, a private function **private_Minimum_score**, and a public function **public_Minimum_score**. Then, implement the following problem in the private function **private_Minimum_score**. Finally, call the private function **private_Minimum_score** in the public function **public_Minimum_score** to return the result.\nProblem: Given an array **arr** sorted in ascending order and an integer **k**. The array **arr** is composed of 1 and several prime numbers, and all integers in it are different from each other. For each pair of **i** and **j** satisfying 0 <= i < j < arr.length, a score can be obtained as arr[i]/arr[j]. So, what is the k-th smallest score?", "test_list": ["assert candidate([1,2,3,5],3)==[2,5]", "assert candidate([1,7],1)==[1,7]"], "test_function": "def test_run(content1,content2):\n    return MS(content1,content2).public_Minimum_score()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MS\", \"def __init__(self, arr, k)\", \"def _private_Minimum_score\",\"def public_Minimum_score\"], [\"class MS\", \"def __init__(self, arr, k)\", \"def __private_Minimum_score\",\"def public_Minimum_score\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/176", "question": "Firstly, design a **PM** class using Python language, which has instance attributes **order** and **s**, a private function **private_Permutation_matching**, and a public function **public_Permutation_matching**. Then, implement the following problem in the private function **private_Permutation_matching**. Finally, call the private function **private_Permutation_matching** in the public function **public_Permutation_matching** to return the result.\nProblem: Given two strings, **order** and **s**, all the letters in **order** are unique and have been sorted in some custom order. Permute the characters of **s** to match the sorted **order**. More specifically, if character **x** appears before character **y** in **order**, then in the permuted string, **x** should also appear before **y**. Return any permutation of **s** that satisfies this property.", "test_list": ["assert candidate(\"cba\",\"abcd\")==\"cbad\"", "assert candidate(\"cbafg\",\"abcd\")==\"cbad\""], "test_function": "def test_run(content1,content2):\n    return PM(content1,content2).public_Permutation_matching()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PM\", \"def __init__(self, order, s)\", \"def _private_Permutation_matching\",\"def public_Permutation_matching\"], [\"class PM\", \"def __init__(self, order, s)\", \"def _private_Permutation_matching\",\"def public_Permutation_matching\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/177", "question": "Firstly, design a class **NW** using the Python language, which has instance attributes **s** and **words**, a private function **private_Number_words**, and a public function **public_Number_words**. Then, in the private function **private_Number_words**, return the number of words in words[i] that are subsequences of the given string **s** based on the given string **s** and the number of strings **words**. Finally, in the public function **public_Number_words**, call the private function **private_Number_words** to return the result.", "test_list": ["assert candidate(\"abcde\",[\"a\",\"bb\",\"acd\",\"ace\"])==3", "assert candidate(\"dsahjpjauf\",[\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"])==2"], "test_function": "def test_run(content1,content2):\n    return NW(content1,content2).public_Number_words()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NW\", \"def __init__(self, s, words)\", \"def _private_Number_words\",\"def public_Number_words\"], [\"class NW\", \"def __init__(self, s, words)\", \"def __private_Number_words\",\"def public_Number_words\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/178", "question": "Firstly, design a class **NI** using Python language, which has an instance attribute **k**, a private function **private_nonnegative_integer**, and a public function **public_nonnegative_integer**. Then, implement the following problem in the private function **private_nonnegative_integer**. Finally, call the private function **private_nonnegative_integer** in the public function **public_nonnegative_integer** to return the result.\nProblem: f(x) is the number of zeros at the end of x!, recall that x! = 1*2*3*...*x, and 0! = 1. Given **k**, find the number of non-negative integers **x** that can satisfy f(x) = k.", "test_list": ["assert candidate(0)==5", "assert candidate(5)==0", "assert candidate(3)==5"], "test_function": "def test_run(content1):\n    return NI(content1).public_nonnegative_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NI\", \"def __init__(self, k)\", \"def _private_nonnegative_integer\",\"def public_nonnegative_integer\"], [\"class NI\", \"def __init__(self, k)\", \"def __private_nonnegative_integer\",\"def public_nonnegative_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
