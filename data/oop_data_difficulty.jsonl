{"task_id": "OOP/0", "question": "Question: Given an integer array **nums** and two integers **left** and **right**. Find the number of subarrays in **nums** that are continuous, non-empty, and have the maximum element within the range [left, right].\n Please create a class called FDSB in Python based on the above problem, with the **nums** attribute. Then create a class called **SN_FDSB** that inherits from the **FDSB** class, and add two attributes **left** and **right**, as well as a public function called **find_subarray** that checks and returns the number of subarrays in **nums** that are continuous, non-empty, and have the maximum element within the range [left, right].", "test_list": ["assert candidate([2,1,4,3],2,3)==3", "assert candidate([2,9,2,5,6],2,8)==7"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FDSB(content1,content2,content3).find_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FDSB\", \"def __init__(self, nums)\", \"def find_subarray\", \"def __init__(self, nums, left, right)\", \"super().__init__(nums)\", \"def find_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/1", "question": "Question: Given an integer array **nums** and two integers: **left** and **right**. Find the continuous, non-empty subarrays in **nums** where the maximum element is within the range [left, right] and return the number of such subarrays that meet the conditions.\nBased on the above question, create a class **FDSB** in Python language with the attribute **nums**; then create another class **SN_FDSB** that inherits from the **FDSB** class, and add two attributes **left** and **right**, as well as a public function **find_subarray** to determine and return the number of continuous, non-empty subarrays in **nums** where the maximum element is within the range [left, right].", "test_list": ["assert candidate([2,1,4,3],2,3)==3", "assert candidate([2,9,2,5,6],2,8)==7"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FDSB(content1,content2,content3).find_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FDSB\", \"def __init__(self, nums)\", \"class SN_FDSB(FDSB)\", \"def __init__(self, nums, left, right)\", \"super().__init__(nums)\", \"def find_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/2", "question": "Question: Given a directed acyclic graph (DAG) with **n** nodes, find and output all paths from node 0 to node n-1;\nBased on the above question, create a class **PO** in Python with the attribute **graph**; then create another class **SN_PO**, inheriting from the **PO** class, and add a public function **Path_output** to return all paths from node 0 to node n-1 in the **n** nodes.", "test_list": ["assert candidate([[1,2],[3],[3],[]])==[[0,1,3],[0,2,3]]", "assert candidate([[4,3,1],[3,2,4],[3],[4],[]])==[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]"], "test_function": "def test_run(content1):\n    return SN_PO(content1).Path_output()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PO\", \"def __init__(self, graph)\", \"class SN_PO(PO)\", \"super().__init__(graph)\", \"super().__init__(nums)\", \"def Path_output\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/3", "question": "Question: Given two integer arrays **nums1** and **nums2** of equal length and not empty. In one operation, you can swap the elements of nums1[i] and nums2[i]. For example, if nums1=[1,2,3,8], nums2=[5,6,7,4], you can swap the element at i=3 to get nums1=[1,2,3,4] and nums2=[5,6,7,8]. Return the minimum number of operations required to make **nums1** and **nums2** strictly increasing;\nBased on the above question, create a class **EE** in Python language with the attribute **nums1**; then create a class **SN_EE** that inherits the **EE** class, and add the attribute **nums2**, as well as a public function **Exchange_Elements** to return the minimum number of operations required to make **nums1** and **nums2** strictly increasing.", "test_list": ["assert candidate([1,3,5,4],[1,2,3,7])==1", "assert candidate([0,3,5,8,9],[2,1,4,6,9])==1"], "test_function": "def test_run(content1,content2):\n    return SN_EE(content1,content2).Exchange_Elements()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EE\", \"def __init__(self, nums1)\", \"class SN_EE(EE)\", \"def __init__(self, nums1, nums2)\", \"super().__init__(nums1)\", \"def Exchange_Elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/4", "question": "Question: Given a directed graph with **n** nodes numbered from 0 to n-1, the graph is represented by a 2D integer array **graph** indexed from 0, where graph[i] is an integer array of nodes adjacent to node **i**, meaning there is an edge from node **i** to each node in **graph[i]**. If a node has no outgoing directed edges, it is a **terminal node**. If all possible paths starting from this node lead to a terminal node, then this node is a **safe node**. Return an array consisting of all the safe nodes in the graph as the answer. The elements in the answer array should be sorted in ascending order;\nBased on the above question, please create a class **SND** in Python with the property **graph**; then create a class **SN_SND** that inherits from the **SND** class, and add a public function **secure_node** to return an array of all the safe nodes in the graph sorted in ascending order.", "test_list": ["assert candidate([[1,2],[2,3],[5],[0],[5],[],[]])==[2,4,5,6]", "assert candidate([[1,2,3,4],[1,2],[3,4],[0,4],[]])==[4]"], "test_function": "def test_run(content1):\n    return SN_SND(content1).secure_node()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SND\", \"def __init__(self, graph)\", \"class SN_SND(SND)\", \"super().__init__(graph)\", \"def secure_node\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/5", "question": "Question: There is an m x n binary **grid**, where 1 represents a brick and 0 represents a blank. The premise for a brick to be stable (not falling) is: a brick is directly connected to the top of the grid, or at least one adjacent (one of the four directions) brick is stable and will not fall. Given an array **hits**, this is the position where the bricks need to be eliminated in order. Whenever the brick at the position hits[i]=(row_i, col_i) is eliminated, the corresponding brick (if it exists) will disappear, and then other bricks may fall due to this elimination operation. Once the brick falls, it will immediately disappear from the grid (it will not fall on other stable bricks). Return an array **result**, where result[i] represents the number of bricks falling corresponding to the i-th elimination operation;\nBased on the above question, please create a class **NBS** in Python language with the property **grid**; then create a class **SN_NBS** that inherits the **NBS** class, and add the property **hits**, and a public function **Number_bricks** to return the array **result** representing the number of bricks falling corresponding to the elimination operation.", "test_list": ["assert candidate([[1,0,0,0],[1,1,1,0]],[[1,0]])==[2]", "assert candidate([[1,0,0,0],[1,1,0,0]],[[1,1],[1,0]])==[0,0]"], "test_function": "def test_run(content1,content2):\n    return SN_NBS(content1,content2).Number_bricks()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NBS\", \"def __init__(self, grid)\", \"class SN_NBS(NBS)\", \"def __init__(self, grid, hits)\", \"super().__init__(grid)\", \"def Number_bricks\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/6", "question": "Question: Given an integer array **nums**. Move each element in the **nums** array to array **A** or array **B**, ensuring that arrays **A** and **B** are not empty, and average(A) == average(B). If it can be completed, return True, otherwise return False;\nBased on the above question, please create a class **EMT** in Python, with the attribute **nums**; then create another class **SN_EMT** that inherits from the **EMT** class, and add a public function **Element_Movement** to determine whether it can be completed.", "test_list": ["assert candidate([1,2,3,4,5,6,7,8])==True", "assert candidate([3,1])==False"], "test_function": "def test_run(content1):\n    return SN_EMT(content1).Element_Movement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EMT\", \"def __init__(self, nums)\", \"class SN_EMT(EMT)\", \"super().__init__(nums)\", \"def Element_Movement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/7", "question": "Question: Given an array **nums** and an integer **k**. We divide the given array **nums** into at most **k** non-empty subarrays, and the array is continuous. The score is composed of the sum of the averages within each subarray. Return the maximum score that can be obtained;\nBased on the above question, use Python language to create a class **MSE** with the attribute **nums**; then create a class **SN_MSE**, inheriting from the **MSE** class, and add the attribute **k**, as well as a public function **Maximum_score** to return the maximum score that can be obtained.", "test_list": ["assert candidate([9,1,2,3,9],3)==20.00000", "assert candidate([1,2,3,4,5,6,7],4)==20.50000"], "test_function": "def test_run(content1,content2):\n    return SN_MSE(content1,content2).Maximum_score()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSE\", \"def __init__(self, nums)\", \"class SN_MSE(MSE)\", \"def __init__(self, nums, k)\", \"super().__init__(nums)\", \"def Maximum_score\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/8", "question": "Question: Given an array **routes**, representing a series of bus routes, where each routes[i] represents a bus route, the i-th bus will circulate on it. For example, the route routes[0]=[1,5,7] indicates that the 0-th bus will always travel in the sequence of 1->5->7->1->5->7->1->... Now starting from the **source** station (not initially on the bus), you want to go to the **target** station. During this period, you can only take the bus. Find the minimum number of buses to take. If it is impossible to reach the terminal station, return -1;\nBased on the above question, please use Python to create a class **TSN** with the attribute **routes**; then create a class **SN_TSN** that inherits from the **TSN** class, and add two attributes **source** and **target**, as well as a public function **Terminal_Station** to return the minimum number of buses to take.", "test_list": ["assert candidate([[1,2,7],[3,6,7]],1,6)==2", "assert candidate([[7,12],[4,5,15],[6],[15,19],[9,12,13]],15,12)==-1"], "test_function": "def test_run(content1,content2,content3):\n    return SN_TSN(content1,content2,content3).Terminal_Station()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TSN\", \"def __init__(self, routes)\", \"class SN_TSN(TSN)\", \"def __init__(self, routes, source, target)\", \"super().__init__(routes)\", \"def Terminal_Station\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/9", "question": "Question: There are some two-dimensional coordinates, such as (1,3) or (2,0.5), and then we remove all commas, decimal points, and spaces to get a string **S**. Return all possible original strings to a list. The original coordinate notation will not have extra zeros, so there will be no **00**, **0.0**, **0.00**, **1.0**, **001**, **00.01** or some other smaller numbers to represent coordinates. In addition, there is at least one number before a decimal point, so there will be no **.1** form of numbers. Note that there is a space between the two returned numbers (after the comma);\nPlease create a class **AOR** based on the above problem using Python language, with the attribute **s**; then create a class **SN_AOR** that inherits the **AOR** class, and add a public function **Any_order** to return all possible original strings in any order to a list after removing all commas, decimal points, and spaces from the string **S**.", "test_list": ["assert candidate(\"(123)\")==[\"(1, 23)\", \"(12, 3)\", \"(1.2, 3)\", \"(1, 2.3)\"]", "assert candidate(\"(00011)\")==[\"(0.001, 1)\", \"(0, 0.011)\"]", "assert candidate(\"(0123)\")==[\"(0, 123)\", \"(0, 12.3)\", \"(0, 1.23)\", \"(0.1, 23)\", \"(0.1, 2.3)\", \"(0.12, 3)\"]", "assert candidate(\"(100)\")==[(10, 0)]"], "test_function": "def test_run(content1):\n    return SN_AOR(content1).Any_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AOR\", \"def __init__(self, s)\", \"class SN_AOR(AOR)\", \"super().__init__(s)\", \"def Any_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/10", "question": "Question: The valid encoding of the word array **words** consists of any mnemonic string **s** and index array **indices**, and meets the following requirements:\n1. words.length == indices.length\n2. The mnemonic string **s** ends with the character '#'\n3. For each index indices[i], a substring of **s** that starts from indices[i] and ends at the next '#' character (but does not include '#') exactly equals to words[i]. Given a word array **words**, return the length of the smallest mnemonic string **s** that successfully encodes **words**;\nBased on the above question, please create a class **ECG** in Python with the attribute **words**; then create a class **SN_ECG** that inherits the **ECG** class, and add a public function **efficient_coding** to return the length of the smallest mnemonic string **s** that successfully encodes **words**.", "test_list": ["assert candidate([\"time\", \"me\", \"bell\"])==10", "assert candidate([\"t\"])==2"], "test_function": "def test_run(content1):\n    return SN_ECG(content1).efficient_coding()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ECG\", \"def __init__(self, words)\", \"class SN_ECG(ECG)\", \"super().__init__(words)\", \"def efficient_coding\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/11", "question": "Question: Given a string **s** and a character **c**, where **c** is a character that appears in **s**. Return an integer array **answer**, where answer.length == s.length and answer[i] is the distance from index **i** in **s** to the nearest character **c**;\nBased on the above question, please create a class **CDC** in Python, with the attribute **s**; then create another class **SN_CDC**, inheriting from the **CDC** class, and add the attribute **c**, as well as a public function **Character_distance** to return an integer array **answer**.", "test_list": ["assert candidate(\"loveleetcode\",\"e\")==[3,2,1,0,1,0,0,1,2,2,1,0]", "assert candidate(\"aaab\",\"b\")==[3,2,1,0]"], "test_function": "def test_run(content1,content2):\n    return SN_CDC(content1,content2).Character_distance()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CDC\", \"def __init__(self, s)\", \"class SN_CDC(CDC)\", \"def __init__(self, s, c)\", \"super().__init__(s)\", \"def Character_distance\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/12", "question": "Question: Given an array **arr** containing non-repeating integer elements, each integer arr[i] is greater than 1. Use these integers to construct a binary tree, each integer can be used any number of times. Where: the value of each non-leaf node should be equal to the product of the values of its two child nodes. How many binary trees are there that meet the conditions;\nBased on the above question, please use Python language to create a class **RIR** with the attribute **arr**; then create a class **SN_RIR** that inherits the **RIR** class, and add a public function **repeating_integer** to return the number of binary trees that meet the conditions.", "test_list": ["assert candidate([2, 4])==3", "assert candidate([2, 4, 5, 10])==7"], "test_function": "def test_run(content1):\n    return SN_RIR(content1).repeating_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RIR\", \"def __init__(self, arr)\", \"class SN_RIR(RIR)\", \"super().__init__(arr)\", \"def repeating_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/13", "question": "Question: You have **n** jobs and **m** workers. Given three arrays: **difficulty**, **profit**, and **worker**, where: difficulty[i] represents the difficulty of the i-th job, profit[i] represents the profit of the i-th job. **worker[i]** is the ability of the i-th worker, that is, the worker can only complete jobs with difficulty less than or equal to worker[i]. Each worker can only be assigned one job at most, but one job can be completed multiple times. For example, if three workers all try to complete the same job with a reward of $1, then the total profit is $3. If a worker cannot complete any job, his profit is $0. Return the maximum profit we can get after assigning workers to jobs;\nPlease create a class **MPT** in Python based on the above question, with the attribute **difficulty**; then create a class **SN_MPT** that inherits the **MPT** class, and add two attributes **profit** and **worker**, as well as a public function **Maximum_profit** to return the maximum profit we can get after assigning **m** workers to **n** jobs.", "test_list": ["assert candidate([2,4,6,8,10],[10,20,30,40,50],[4,5,6,7])==100", "assert candidate([85,47,57],[24,66,99],[40,25,25])==0"], "test_function": "def test_run(content1,content2,content3):\n    return SN_MPT(content1,content2,content3).Maximum_profit()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MPT\", \"def __init__(self, difficulty)\", \"class SN_MPT(MPT)\", \"def __init__(self, difficulty, profit, worker)\", \"super().__init__(difficulty)\", \"def Maximum_profit\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/14", "question": "Question: Given a binary matrix **grid** of size n x n. You are allowed to change at most one 0 to 1. Return the maximum area of an island in the **grid** after this operation;\nPlease create a class **IAA** in Python based on the above question, with the attribute **grid**. Then create a class **SN_IAA** that inherits from the **IAA** class, and add a public function **Island_area** to return the maximum area of an island in the **grid** after changing one 0 to 1 in the binary matrix **grid**.", "test_list": ["assert candidate([[1, 0], [0, 1]])==3", "assert candidate([[1, 1], [1, 0]])==4", "assert candidate([[1, 1], [1, 1]])==4"], "test_function": "def test_run(content1):\n    return SN_IAA(content1).Island_area()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IAA\", \"def __init__(self, grid)\", \"class SN_IAA(IAA)\", \"super().__init__(grid)\", \"def Island_area\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/15", "question": "Question: Define a function **countUniqueChars** to count the unique characters in string **s**, and return the number of unique characters;\nBased on the above question, please create a class **UCR** in Python language with the attribute **s**; then create another class **SN_UCR** that inherits from the **UCR** class, and add a public function **Unique_character** to return the number of unique characters in string **s**.", "test_list": ["assert candidate(\"ABC\")==10", "assert candidate(\"ABA\")==8", "assert candidate(\"LEETCODE\")==92"], "test_function": "def test_run(content1):\n    return SN_UCR(content1).Unique_character()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class UCR\", \"def __init__(self, s)\", \"class SN_UCR(UCR)\", \"super().__init__(s)\", \"def Unique_character\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/16", "question": "Question: Given a positive integer **n**, return the number of groups of consecutive positive integers that satisfy the sum of all numbers equals **n**;\nBased on the above question, please create a class **SNS** in Python, which has an attribute **n**. Then create another class **SN_SNS** that inherits from the **SNS** class, and add a public function **Sum_Numbers** to return the number of groups of consecutive positive integers that satisfy the sum of all numbers equals **n**.", "test_list": ["assert candidate(5)==2", "assert candidate(9)==3", "assert candidate(15)==5"], "test_function": "def test_run(content1):\n    return SN_SNS(content1).Sum_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SNS\", \"def __init__(self, n)\", \"class SN_SNS(SNS)\", \"super().__init__(n)\", \"def Sum_Numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/17", "question": "Question: Given an undirected, connected tree. The tree has **n** nodes labeled from 0 to n-1 and n-1 edges. Given an integer **n** and an array **edges**, edges[i] = [a_i, b_i] indicates that there is an edge between nodes a_i and b_i in the tree. Return an array answer of length **n**, where answer[i] is the sum of the distances between the i-th node and all other nodes in the tree;\nBased on the above question, please create a class **SDC** in Python language with the attribute **n**; then create a class **SN_SDC** that inherits from the **SDC** class, and add the attribute **edges**, as well as a public function **Sum_distances** to return an array **answer** of length **n**.", "test_list": ["assert candidate(6,[[0,1],[0,2],[2,3],[2,4],[2,5]])==[8,12,6,10,10,10]", "assert candidate(1,[])==[0]", "assert candidate(2,[[1,0]])==[1,1]"], "test_function": "def test_run(content1,content2):\n    return SN_SDC(content1,content2).Sum_distances()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SDC\", \"def __init__(self, n)\", \"class SN_SDC(SDC)\", \"def __init__(self, n, edges)\", \"super().__init__(n)\", \"def Sum_distances\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/18", "question": "Question: Given two images **img1** and **img2**, both of which are n x n in size and represented by binary square matrices of the same size. The binary matrix is composed only of several 0s and 1s. Transform one of the images by sliding all the 1s to the left, right, up, or down by any number of units; then place it on top of the other image. The overlap of this transformation refers to the number of positions where both images have 1s. Please note that the transformation does not include rotation in any direction. Any 1s that cross the matrix boundary will be cleared. What is the maximum possible number of overlaps?\nBased on the above question, please create a class **OQT** in Python with the attribute **img1**; then create another class **SN_OQT** that inherits from the **OQT** class, and add the attribute **img2**, as well as a public function **Overlap_quantity** to return the maximum possible number of overlaps.", "test_list": ["assert candidate([[1,1,0],[0,1,0],[0,1,0]],[[0,0,0],[0,1,1],[0,0,1]])==3", "assert candidate([[1]],[[1]])==1", "assert candidate([[0]],[[0]])==0"], "test_function": "def test_run(content1,content2):\n    return SN_OQT(content1,content2).Overlap_quantity()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class OQT\", \"def __init__(self, img1)\", \"class SN_OQT(OQT)\", \"def __init__(self, img1, img2)\", \"super().__init__(img1)\", \"def Overlap_quantity\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/19", "question": "Question: A rectangle is represented as a list [x1,y1,x2,y2], where (x1,y1) is the coordinate of the bottom left corner, and (x2,y2) is the coordinate of the top right corner. The top and bottom edges of the rectangle are parallel to the x-axis, and the left and right edges are parallel to the y-axis. If the intersecting area is positive, then the two rectangles are considered to be **overlapping**. It should be clarified that two rectangles that only touch at the corner or edge do not constitute an overlap. Given two rectangles **rec1** and **rec2**. If they overlap, return True; otherwise, return False.\nBased on the above question, please create a class **ROP** in Python language with the attribute **rec1**; then create a class **SN_ROP** that inherits from the **ROP** class, and add the attribute **rec2**, as well as a public function **Rectangle_overlap** to determine whether the intersecting area of the two rectangles **rec1** and **rec2** is positive. If it is, return True; otherwise, return False.", "test_list": ["assert candidate([0,0,2,2],[1,1,3,3])==True", "assert candidate([0,0,1,1],[1,0,2,1])==False", "assert candidate([0,0,1,1],[2,2,3,3])==False"], "test_function": "def test_run(content1,content2):\n    return SN_ROP(content1,content2).Rectangle_overlap()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ROP\", \"def __init__(self, rec1)\", \"class SN_ROP(ROP)\", \"def __init__(self, rec1, rec2)\", \"super().__init__(rec1)\", \"def Rectangle_overlap\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/20", "question": "Question: Alice participates in a game roughly based on the rules of the card game **Blackjack**, described as follows: Alice starts with 0 points, and draws numbers when her score is less than k points. When drawing, she randomly gets an integer from the range [1, maxPts] to accumulate as a score, where **maxPts** is an integer. Each draw is independent, and the results have the same probability. When Alice gets **k** points or more, she stops drawing numbers. What is the probability that Alice's score does not exceed **n**;\nPlease create a class **ENS** in python language based on the above question, with the attribute **n**; then create a class **SN_ENS**, inheriting from the **ENS** class, and add two attributes **k** and **maxPts**, as well as a public **Extract_Numbers** function to return the probability that Alice's score does not exceed **n**.", "test_list": ["assert candidate(10,1,10)==1.00000", "assert candidate(6,1,10)==0.60000", "assert candidate(21,17,10)==0.73278"], "test_function": "def test_run(content1,content2,content3):\n    return SN_ENS(content1,content2,content3).Extract_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ENS\", \"def __init__(self, n)\", \"class SN_ENS(ENS)\", \"def __init__(self, n, k, maxPts)\", \"super().__init__(n)\", \"def Extract_Numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/21", "question": "Question: If two different positions in string **X** are swapped to make it equal to string **Y**, then **X** and **Y** are considered similar. If the two strings are identical, they are also similar. Given a list of strings **strs**, each string in the list is an anagram of all other strings in **strs**. How many similar string groups are there in **strs**;\nBased on the above question, create a class **SST** in Python with the attribute **strs**; then create a class **SN_SST** that inherits from the **SST** class, and add a public function **Similar_Strings** to return the number of similar string groups in the string list **strs**.", "test_list": ["assert candidate([\"tars\",\"rats\",\"arts\",\"star\"])==2", "assert candidate([\"omv\",\"ovm\"])==1"], "test_function": "def test_run(content1):\n    return SN_SST(content1).Similar_Strings()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SST\", \"def __init__(self, strs)\", \"class SN_SST(SST)\", \"super().__init__(strs)\", \"def Similar_Strings\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/22", "question": "Question: A 3x3 magic square is a 3x3 matrix filled with distinct numbers from 1 to 9, where the sum of each row, each column, and the two diagonals are equal. Given a grid of row x col composed of integers, how many 3x3 **magic square** submatrices are there? (Each submatrix is continuous);\nBased on the above question, please create a **SAX** class in Python with a **grid** attribute; then create a **SN_SAX** class that inherits from the **SAX** class, and add a public **submatrix** function to return the number of 3x3 magic square submatrices.", "test_list": ["assert candidate([[4,3,8,4],[9,5,1,9],[2,7,6,2]])==1", "assert candidate([[8]])==0"], "test_function": "def test_run(content1):\n    return SN_SAX(content1).submatrix()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SAX\", \"def __init__(self, grid)\", \"class SN_SAX(SAX)\", \"super().__init__(grid)\", \"def submatrix\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/23", "question": "Question: There are **n** rooms, numbered from 0 to n-1. Initially, all rooms except room 0 are locked. Your goal is to enter all rooms. However, you cannot enter a locked room without obtaining the key. When you enter a room, you may find a set of different keys inside, each key has a corresponding room number, indicating the room that the key can open. You can take all the keys to unlock other rooms. You are given an array **rooms**, where rooms[i] is the set of keys you can get when you enter room **i**. If you can enter all rooms, return True, otherwise return False.\nPlease create a class **ARS** in Python based on the above question, with the property **rooms**. Then create a class **SN_ARS** that inherits the **ARS** class, and add a public function **All_rooms** to determine whether you can enter all **n** rooms numbered from 0 to n-1. If you can, return True, otherwise return False.", "test_list": ["assert candidate([[1],[2],[3],[]])==True", "assert candidate([[1,3],[3,0,1],[2],[0]])==False"], "test_function": "def test_run(content1):\n    return SN_ARS(content1).All_rooms()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ARS\", \"def __init__(self, rooms)\", \"class SN_ARS(ARS)\", \"super().__init__(rooms)\", \"def All_rooms\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/24", "question": "Question: Given a string of digits **num**, such as \"123456579\", we can split it into a Fibonacci-like sequence [123,456,579]. Formally, a Fibonacci-like sequence is a list of non-negative integers **f**, satisfying:\n1. 0<=f[i]<231, (in other words, each integer conforms to the 32-bit signed integer type). 2. f.length>=3. 3. For all 0<=i<f.length-2, f[i]+f[i+1]=f[i+2]. Also, please note that when splitting the string into chunks, each chunk's number must not start with zero, unless the chunk is the number 0 itself. Return any Fibonacci-like sequence chunks split from num, if it cannot be split, return [].\nBased on the above question, please create a class **FEQ** in Python, with the attribute **num**; then create another class **SN_FEQ**, inheriting from the **FEQ** class, and add a public function **Fibonacci_equation** to return any Fibonacci-like sequence chunks split from **num**, if it cannot be split, return [].", "test_list": ["assert candidate(\"1101111\")==[11,0,11,11]", "assert candidate(\"112358130\")==[]", "assert candidate(\"0123\")==[]"], "test_function": "def test_run(content1):\n    return SN_FEQ(content1).Fibonacci_equation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FEQ\", \"def __init__(self, num)\", \"class SN_FEQ(FEQ)\", \"super().__init__(num)\", \"def Fibonacci_equation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/25", "question": "Question: An array arr is called a mountain array if it meets the following properties:\n1. arr.length>=3. 2. There exists an index **i** (0<i<arr.length-1), such that arr[0]<arr[1]<...<arr[i-1]<arr[i] and arr[i]>arr[i+1]>...>arr[arr.length-1]. Given an integer array **arr**, return the length of the longest mountain subarray. If there is no mountain subarray, return 0;\nBased on the above question, please create a class **LMN** in Python, which has the property **arr**; then create a class **SN_LMN** that inherits the **LMN** class, and add a public function **Longest_mountain** to return the length of the longest **mountain subarray** in the integer array **arr**. If there is no mountain subarray, return 0.", "test_list": ["assert candidate([2,1,4,7,3,2,5])==5", "assert candidate([2,2,2])==0"], "test_function": "def test_run(content1):\n    return SN_LMN(content1).Longest_mountain()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LMN\", \"def __init__(self, arr)\", \"class SN_LMN(LMN)\", \"super().__init__(arr)\", \"def Longest_mountain\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/26", "question": "Question: Alice has a deck of cards in her hand. She wants to rearrange these cards into several groups, each with a group size of **groupSize**, and each group consists of **groupSize** consecutive cards. You are given an integer array **hand** where hand[i] is the value written on the i-th card. If she can rearrange these cards, return True; otherwise, return False.\nBased on the above question, please create a class **RRG** in Python, which has the attribute **hand**; then create a class **SN_RRG** that inherits the **RRG** class, and add the attribute **groupSize**, as well as a public function **rearrange** to determine whether Alice can rearrange the deck of cards in her hand into several groups, each with a group size of **groupSize**, and each group consists of **groupSize** consecutive cards.", "test_list": ["assert candidate([1,2,3,6,2,3,4,7,8],3)==True", "assert candidate([1,2,3,4,5],4)==False"], "test_function": "def test_run(content1,content2):\n    return SN_RRG(content1,content2).rearrange()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RRG\", \"def __init__(self, hand)\", \"class SN_RRG(RRG)\", \"def __init__(self, hand, groupSize)\", \"super().__init__(hand)\", \"def rearrange\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/27", "question": "Question: There exists an undirected connected graph composed of **n** nodes, with the nodes numbered from 0 to n-1. A given array **graph** represents this graph. In it, graph[i] is a list, composed of all nodes directly connected to node **i**. Return the length of the shortest path that can visit all nodes. You can start and stop at any node, revisit nodes multiple times, and reuse edges;\nBased on the above question, create a class **TTH** using Python, with the property **graph**; then create another class **SN_TTH** that inherits from the **TTH** class, and add a public function **The_length** to return the length of the shortest path that can visit all nodes.", "test_list": ["assert candidate([[1,2,3],[0],[0],[0]])==4", "assert candidate([[1],[0,2,4],[1,3,4],[2],[1,2]])==4"], "test_function": "def test_run(content1):\n    return SN_TTH(content1).The_length()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TTH\", \"def __init__(self, graph)\", \"class SN_TTH(TTH)\", \"super().__init__(graph)\", \"def The_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/28", "question": "Question: There is a string **s** composed of lowercase letters, and an integer array **shifts** of the same length. We call the next letter in the alphabet a **shift** of the original letter (since the alphabet is circular, 'z' will become 'a'). Return the final string obtained after applying all these shifts to **s**;\nBased on the above question, please create a class **SAN** in Python language with the attribute **s**; then create a class **SN_SAN** that inherits the **SAN** class, and add the attribute **shifts**, as well as a public function **Shift_application** to return the final string obtained after applying all these shifts to **s**.", "test_list": ["assert candidate(\"abc\",[3,5,9])==\"rpl\"", "assert candidate(\"aaa\",[1,2,3])==\"gfd\""], "test_function": "def test_run(content1,content2):\n    return SN_SAN(content1,content2).Shift_application()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SAN\", \"def __init__(self, s)\", \"class SN_SAN(SAN)\", \"def __init__(self, s, shifts)\", \"super().__init__(s)\", \"def Shift_application\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/29", "question": "Question: Given an array **seats** representing a row of seats, where seats[i]=1 means someone is sitting in the i-th seat, and seats[i]=0 means the i-th seat is empty (index starts from 0). There is at least one empty seat, and at least one person is already sitting. Alex wants to sit in a seat that maximizes the distance to the nearest person;\nBased on the above question, use Python to create a class **ASG** with the attribute **seats**. Then create a class **SN_ASG** that inherits the **ASG** class, and add a public function **Maximized_seating** that returns the maximum distance from Alex to the nearest person.", "test_list": ["assert candidate([1,0,0,0,1,0,1])==2", "assert candidate([1,0,0,0])==3", "assert candidate([0,1])==1"], "test_function": "def test_run(content1):\n    return SN_ASG(content1).Maximized_seating()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ASG\", \"def __init__(self, seats)\", \"class SN_ASG(ASG)\", \"super().__init__(seats)\", \"def Maximized_seating\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/30", "question": "Question: Given an axis-aligned 2D array **rectangles**. For rectangle[i]=[x1,y1,x2,y2], where (x1,y1) are the coordinates of the bottom left corner of rectangle **i**, (x_i1,y_i1) are the coordinates of the bottom left corner of the rectangle, and (x_i2,y_i2) are the coordinates of the top right corner of the rectangle. Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once, return the total area.\nBased on the above question, please create a class **TAR** in Python language with the attribute **rectangles**; then create a class **SN_TAR** that inherits the **TAR** class, and add a public function **total_area** to return the total area covered by all axis-aligned 2D array rectangles in the plane.", "test_list": ["assert candidate([[0,0,2,2],[1,0,2,3],[1,0,3,1]])==6", "assert candidate([[0,0,1000000000,1000000000]])==49"], "test_function": "def test_run(content1):\n    return SN_TAR(content1).total_area()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TAR\", \"def __init__(self, rectangles)\", \"class SN_TAR(TAR)\", \"super().__init__(rectangles)\", \"def total_area\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/31", "question": "Question: For some non-negative integers **k**, if swapping the positions of two letters in **s1** exactly **k** times can result in a string equal to **s2**, then the similarity of strings **s1** and **s2** is considered to be **k**. Given two anagrams s1 and s2, return the minimum value of the similarity **k** between **s1** and **s2**;\nBased on the above question, please create a class named **MVE** using Python, which has an attribute **s1**. Then create another class named **SN_MVE**, inheriting from the **MVE** class, and add an attribute **s2**, as well as a public function **Minimum_value** to return the minimum value of the similarity **k** between the given two anagrams **s1** and **s2**.", "test_list": ["assert candidate(\"ab\",\"ba\")==1", "assert candidate(\"abc\",\"bca\")==2"], "test_function": "def test_run(content1,content2):\n    return SN_MVE(content1,content2).Minimum_value()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MVE\", \"def __init__(self, s1)\", \"class SN_MVE(MVE)\", \"def __init__(self, s1, s2)\", \"super().__init__(s1)\", \"def Minimum_value\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/32", "question": "Question: Given a balanced parentheses string **S**, calculate the score of the string according to the following rules:\n1. **()** gets 1 point. 2. **AB** gets A+B points, where A and B are balanced parentheses strings. 3. **(A)** gets 2*A points, where A is a balanced parentheses string.\nBased on the above question, please create a class **BPS** in Python, with the attribute **S**. Then create another class **SN_BPS** that inherits from the **BPS** class, and add a public function **Balanced_parentheses** to return the score of a given balanced parentheses string **S** calculated according to the rules.", "test_list": ["assert candidate(\"()\")==1", "assert candidate(\"(())\")==2", "assert candidate(\"()()\")==2", "assert candidate(\"(()(()))\")==6"], "test_function": "def test_run(content1):\n    return SN_BPS(content1).Balanced_parentheses()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BPS\", \"def __init__(self, S)\", \"class SN_BPS(BPS)\", \"super().__init__(S)\", \"def Balanced_parentheses\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/33", "question": "Question: There is a special **square room**, each wall of which has a mirror. Except for the **southwest corner**, there is a receiver in each corner, numbered as 0, 1, and 2. The length of the wall of the square room is **p**, a laser beam is emitted from the southwest corner, and it will first meet the east wall. The distance from the point of incidence to receiver 0 is **q**. Return the number of the receiver that the returned light first encounters (ensure that the light will eventually encounter a receiver);\nBased on the above question, please use Python language to create a class **RNE** with the attribute **p**; then create a class **SN_RNE** that inherits the **RNE** class, and add the attribute **q** and a public function **Receiver_number** to return the number of the receiver that the light first encounters.", "test_list": ["assert candidate(2,1)==2", "assert candidate(3,1)==1"], "test_function": "def test_run(content1,content2):\n    return SN_RNE(content1,content2).Receiver_number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RNE\", \"def __init__(self, p)\", \"class SN_RNE(RNE)\", \"def __init__(self, p, q)\", \"super().__init__(p)\", \"def Receiver_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/34", "question": "Question: Given a binary matrix **grid** of size m x n, where each element in the matrix is either 0 or 1. A move is defined as choosing any row or column and flipping the values in that row or column: change all 0s to 1s and all 1s to 0s. After making any number of moves, the score of the matrix is the sum of the numbers obtained by interpreting each row as a binary number. After making any number of moves (including 0), return the possible highest score;\nBased on the above question, please create a class **HSE** in Python with the attribute **grid**. Then create a class **SN_HSE** that inherits from the **HSE** class, and add a public function **Highest_Score** to return the possible highest score.", "test_list": ["assert candidate([[0,0,1,1],[1,0,1,0],[1,1,0,0]])==39", "assert candidate([[0]])==1"], "test_function": "def test_run(content1):\n    return SN_HSE(content1).Highest_Score()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class HSE\", \"def __init__(self, grid)\", \"class SN_HSE(HSE)\", \"super().__init__(grid)\", \"def Highest_Score\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/35", "question": "Question: Given an integer array **nums** and an integer **k**, find the shortest non-empty subarray in **nums** whose sum is at least **k**, and return the length of this subarray. If such a subarray does not exist, return -1;\nBased on the above question, create a class **SEY** in Python, which has the attribute **nums**; then create another class **SN_SEY** that inherits from the **SEY** class, and add the attribute **k**, as well as a public function **Shortest_empty** to return the length of the shortest non-empty subarray in **nums** whose sum is at least **k**.", "test_list": ["assert candidate([1],1)==1", "assert candidate([1,2],4)==-1", "assert candidate([2,-1,2],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_SEY(content1,content2).Shortest_empty()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SEY\", \"def __init__(self, nums)\", \"class SN_SEY(SEY)\", \"def __init__(self, nums, k)\", \"super().__init__(nums)\", \"def Shortest_empty\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/36", "question": "Question: Find the smallest palindrome prime number that is greater than or equal to **N**;\nBased on the above question, please create a class **PPM** in Python with an attribute **N**. Then, create another class **SN_PPM** that inherits from the **PPM** class, and add a public function **prime_palindromes** to return the smallest palindrome prime number that is greater than or equal to **N**.", "test_list": ["assert candidate(6)==7", "assert candidate(8)==11", "assert candidate(13)==101"], "test_function": "def test_run(content1):\n    return SN_PPM(content1).prime_palindromes()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PPM\", \"def __init__(self, N)\", \"class SN_PPM(PPM)\", \"super().__init__(N)\", \"def prime_palindromes\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/37", "question": "Question: Given a positive integer **n**, we reorder the digits in any order (including the original order), noting that the leading digit cannot be zero. If we can obtain a power of 2 in this way, return True; otherwise, return False;\nBased on the above question, please create a class **NRG** in Python with the attribute **n**; then create a class **SN_NRG** that inherits from the **NRG** class, and add a public function **Number_Reordering** to determine whether reordering the positive integer **n** in any order (including the original order) can result in a power of 2. If it can, return True; otherwise, return False.", "test_list": ["assert candidate(1)==True", "assert candidate(10)==False"], "test_function": "def test_run(content1):\n    return SN_NRG(content1).Number_Reordering()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NRG\", \"def __init__(self, n)\", \"class SN_NRG(NRG)\", \"super().__init__(n)\", \"def Number_Reordering\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/38", "question": "Question: Given two arrays of equal length, **nums1** and **nums2**, the advantage of **nums1** over **nums2** can be described by the number of indices **i** for which nums1[i] > nums2[i]. Return any permutation of **nums1** that maximizes its advantage over **nums2**;\nBased on the above question, create a class **MAS** in Python with the attribute **nums1**. Then create a class **SN_MAS** that inherits from the **MAS** class, and add the attribute **nums2**, as well as a public function **Maximizing_Advantages** that returns any permutation of **nums1** that maximizes its **advantage** over **nums2**.", "test_list": ["assert candidate([2,7,11,15],[1,10,4,11])==[2,11,7,15]", "assert candidate([12,24,8,32],[13,25,32,11])==[24,32,8,12]"], "test_function": "def test_run(content1,content2):\n    return SN_MAS(content1,content2).Maximizing_Advantages()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MAS\", \"def __init__(self, nums1)\", \"class SN_MAS(MAS)\", \"def __init__(self, nums1, nums2)\", \"super().__init__(nums1)\", \"def Maximizing_Advantages\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/39", "question": "Question: If a sequence X_1, X_2, ..., X_n satisfies the following conditions, it is said to be **Fibonacci-like**:\n1. n>=3. 2. For all i+2<=n, we have X_i+X_{i+1}=X_{i+2}. Given a strictly increasing positive integer array forming a sequence **arr**, find the length of the longest Fibonacci-like subsequence in **arr**. If one does not exist, return 0;\nBased on the above question, please create a class **PAY** in Python, which has the attribute **arr**; then create a class **SN_PAY** that inherits the **PAY** class, and add a public function **Positive_array** to return the length of the longest Fibonacci-like subsequence in the strictly increasing positive integer array forming the sequence **arr**.", "test_list": ["assert candidate([1,2,3,4,5,6,7,8])==5", "assert candidate([1,3,7,11,12,14,18])==3"], "test_function": "def test_run(content1):\n    return SN_PAY(content1).Positive_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PAY\", \"def __init__(self, arr)\", \"class SN_PAY(PAY)\", \"super().__init__(arr)\", \"def Positive_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/40", "question": "Question: Koko loves to eat bananas. There are **n** piles of bananas here, and the i-th pile has piles[i] bananas. The guard has already left and will return in **h** hours. Koko can decide her eating speed **k** (unit: bananas/hour). Every hour, she will choose a pile of bananas and eat **k** bananas from it. If this pile has fewer than **k** bananas, she will eat all the bananas in this pile, and will not eat any more bananas within this hour. Koko likes to eat slowly, but still wants to eat all the bananas before the guard comes back. Return the minimum speed **k** (k is an integer) at which she can eat all the bananas within **h** hours;\nBased on the above question, please create a class **MSD** in Python language with the attribute **piles**; then create a class **SN_MSD** that inherits the **MSD** class, and add the attribute **h**, as well as a public function **Minimum_Speed** to return the minimum speed **k** at which Koko can eat all the bananas within **h** hours.", "test_list": ["assert candidate([3,6,7,11],8)==4", "assert candidate([30,11,23,4,20],5)==30", "assert candidate([30,11,23,4,20],6)==23"], "test_function": "def test_run(content1,content2):\n    return SN_MSD(content1,content2).Minimum_Speed()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSD\", \"def __init__(self, piles)\", \"class SN_MSD(MSD)\", \"def __init__(self, piles, h)\", \"super().__init__(piles)\", \"def Minimum_Speed\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/41", "question": "Question: A positive integer is magical if it can be divided by **a** or **b**. Given three integers **n**, **a**, **b**, return the n-th magical number;\nBased on the above question, create a class **MNS** in Python with the attribute **n**; then create another class **SN_MNS** that inherits from the **MNS** class, and add two attributes **a** and **b**, as well as a public function **Magical_Numbers** to return the n-th magical number.", "test_list": ["assert candidate(1,2,3)==2", "assert candidate(4,2,3)==6"], "test_function": "def test_run(content1,content2,content3):\n    return SN_MNS(content1,content2,content3).Magical_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNS\", \"def __init__(self, n)\", \"class SN_MNS(MNS)\", \"def __init__(self, n, a, b)\", \"super().__init__(n)\", \"def Magical_Numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/42", "question": "Question: There are **n** employees in the group, who can complete various jobs to generate profits. The i-th job will generate a profit of profit[i], and it requires group[i] members to participate together. If a member participates in one job, he/she cannot participate in another job. Any subset of jobs that generates at least **minProfit** profit is called a profitable plan. And the total number of job members is up to **n**. How many plans can be chosen;\nBased on the above question, please create a class called **PPN** in Python, which has an attribute **n**; then create another class **SN_PPN** that inherits from the **PPN** class, and add three attributes **minProfit**, **group**, and **profit**, as well as a public function **Profit_Plan** that returns the number of profitable plans.", "test_list": ["assert candidate(5,3,[2,2],[2,3])==2", "assert candidate(10,5,[2,3,5],[6,7,8])==7"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_PPN(content1,content2,content3,content4).Profit_Plan()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PPN\", \"def __init__(self, n)\", \"class SN_PPN(PPN)\", \"def __init__(self, n, minProfit, group, profit)\", \"super().__init__(n)\", \"def Profit_Plan\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/43", "question": "Question: Given an encoded string **S**. You are asked to find the decoded string and write it onto a tape. During the decoding process, read one character from the encoded string at a time, and take the following steps:\n1. If the character read is a letter, write it on the tape. 2. If the character read is a number (such as **d**), the entire current tape will be written repeatedly **d-1** times. Now, for the given encoded string **S** and index **K**, find and return the K-th letter in the decoded string;\nYou are required to create a class **DSG** in Python, which has the attribute **S**; then create another class **SN_DSG** that inherits from the **DSG** class, and add the attribute **K**, as well as a public function **Decode_String** to find and return the K-th letter in the given encoded string **S**.", "test_list": ["assert candidate(\"leet2code3\",10)==\"o\"", "assert candidate(\"ha22\",5)==\"h\"", "assert candidate(\"a2345678999999999999999\",1)==\"a\""], "test_function": "def test_run(content1,content2):\n    return SN_DSG(content1,content2).Decode_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DSG\", \"def __init__(self, S)\", \"class SN_DSG(DSG)\", \"def __init__(self, S, K)\", \"super().__init__(S)\", \"def Decode_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/44", "question": "Question: Given an array **people**. people[i] represents the weight of the i-th person, the number of boats is unlimited, and each boat can carry a maximum weight of **limit**. Each boat can carry up to two people at the same time, but the condition is that the sum of these people's weights is at most **limit**. Return the minimum number of boats required to carry all people;\nBased on the above question, please create a class **MSS** in Python language with the attribute **people**; then create a class **SN_MSS**, inherit the **MSS** class, and add the attribute **limit**, as well as a public function **Minimum_ships** to return the minimum number of boats required to carry all people.", "test_list": ["assert candidate([1,2],3)==1", "assert candidate([3,2,2,1],3)==3", "assert candidate([3,5,3,4],5)==4"], "test_function": "def test_run(content1,content2):\n    return SN_MSS(content1,content2).Minimum_ships()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSS\", \"def __init__(self, people)\", \"class SN_MSS(MSS)\", \"def __init__(self, people, limit)\", \"super().__init__(people)\", \"def Minimum_ships\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/45", "question": "Question: In an n x n **grid**, we place some 1 x 1 x 1 cubes aligned with the **x**, **y**, **z** axes. Each value v = grid[i][j] represents **v** cubes stacked on the cell (i, j). Now, we look at the projections of these cubes on the **xy**, **yz**, and **zx** planes. A projection is like a shadow, mapping a three-dimensional shape onto a two-dimensional plane. When we look at the cube from the top, front, and side, we will see the shadow. Return the total area of all three projections;\nPlease create a class **TPD** based on the above question using Python, with the attribute **grid**; then create a class **SN_TPD**, inheriting from the **TPD** class, and add a public function **Total_projected** to return the total area of all the cubes' projections on the **xy**, **yz**, and **zx** planes.", "test_list": ["assert candidate([[1,2],[3,4]])==17", "assert candidate([[2]])==5", "assert candidate([[1,0],[0,2]])==8"], "test_function": "def test_run(content1):\n    return SN_TPD(content1).Total_projected()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TPD\", \"def __init__(self, grid)\", \"class SN_TPD(TPD)\", \"super().__init__(grid)\", \"def Total_projected\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/46", "question": "Question: On a grid of rows x cols, you start from the cell (rStart, cStart) facing east. The northwest corner of the grid is at the first row and the first column, and the southeast corner is at the last row and the last column. You need to walk in a clockwise spiral, visiting every position in this grid. Whenever you move beyond the boundary of the grid, you need to continue walking outside the grid (but you may return to the grid boundary later). Eventually, we have visited all the rows x cols spaces in the grid. Return the list of coordinates representing the grid positions in the order of visit;\nBased on the above question, please create a class **CLT** in Python language with the property **rows**; then create another class **SN_CLT** that inherits the **CLT** class, and add three properties **cols**, **rStart** and **cStart**, as well as a public function **Coordinate_List** to return the list of coordinates representing the grid positions in the order of visit.", "test_list": ["assert candidate(1,4,0,0)==[[0,0],[0,1],[0,2],[0,3]]", "assert candidate(5,6,1,4)==[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_CLT(content1,content2,content3,content4).Coordinate_List()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CLT\", \"def __init__(self, rows)\", \"class SN_CLT(CLT)\", \"def __init__(self, rows, cols, rStart, cStart)\", \"super().__init__(rows)\", \"def Coordinate_List\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/47", "question": "Question: Given a set of **n** people (numbered 1,2,...,n), we want to divide each person into two groups of any size. Each person may not like others, so they should not belong to the same group. Given the integer **n** and the array **dislikes**, where dislikes[i]=[a_i,b_i], it is not allowed to put the people numbered **a_i** and **b_i** into the same group. When all people can be divided into two groups in this way, return True; otherwise, return False;\nBased on the above question, please create a class **GPG** in Python with the attribute **n**; then create a class **SN_GPG** that inherits from the **GPG** class, and add the attribute **dislikes**, as well as a public function **grouping** to determine whether each person can be divided into two groups of any size given the integer **n**and the array **dislikes**. If it is possible, return True; otherwise, return False.", "test_list": ["assert candidate(4,[[1,2],[1,3],[2,4]])==True", "assert candidate(3,[[1,2],[1,3],[2,3]])==False", "assert candidate(5,[[1,2],[2,3],[3,4],[4,5],[1,5]])==False"], "test_function": "def test_run(content1,content2):\n    return SN_GPG(content1,content2).grouping()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GPG\", \"def __init__(self, n)\", \"class SN_GPG(GPG)\", \"def __init__(self, n, dislikes)\", \"super().__init__(n)\", \"def grouping\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/48", "question": "Question: You are given **k** identical eggs and you have access to a building with **n** floors from the 1st floor to the n-th floor. It is known that there exists a floor **f**, satisfying 0<=f<=n, any eggs dropped from a floor higher than **f** will break, and those dropped from the **f** floor or lower will not break. Each time, you can take an unbroken egg and drop it from any floor **x** (satisfying 1<=x<=n). If the egg breaks, you cannot use it again. If an egg does not break after being dropped, it can be reused in subsequent operations. Please calculate and return the minimum number of operations to determine the exact value of **f**.\nPlease create a class **NOS** in Python based on the above problem, with the attribute **k**. Then create a class **SN_NOS** that inherits from the **NOS** class, adds the attribute **n**, and a public function **number_operations** to calculate and return the minimum number of operations to determine the exact value of **f**.", "test_list": ["assert candidate(1,2)==2", "assert candidate(2,6)==3", "assert candidate(3,14)==4"], "test_function": "def test_run(content1,content2):\n    return SN_NOS(content1,content2).number_operations()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NOS\", \"def __init__(self, k)\", \"class SN_NOS(NOS)\", \"def __init__(self, k, n)\", \"super().__init__(k)\", \"def number_operations\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/49", "question": "Question: The width of a sequence is defined as the difference between the maximum and minimum elements in the sequence. Given an integer array **nums**, return the sum of the widths of all non-empty subsequences of **nums**. A subsequence is defined as an array obtained by deleting some (or not deleting) elements from an array without changing the order of the remaining elements.\nBased on the above question, please create a class **SWS** in Python, which has the attribute **nums**; then create another class **SN_SWS** that inherits from the **SWS** class, and add a public function **Sum_widths** to return the sum of the widths of all non-empty subsequences of the integer array **nums**.", "test_list": ["assert candidate([2,1,3])==6", "assert candidate([2])==0"], "test_function": "def test_run(content1):\n    return SN_SWS(content1).Sum_widths()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SWS\", \"def __init__(self, nums)\", \"class SN_SWS(SWS)\", \"super().__init__(nums)\", \"def Sum_widths\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/50", "question": "Question: We have a non-negative integer array **arr**. For each (continuous) subarray sub=[arr[i],arr[i+1],...,arr[j]] (i<=j), we perform a bitwise OR operation on each element in **sub**, obtaining the result arr[i]|arr[i+1]|...|arr[j]. Return the number of possible results. Multiple occurrences of the result are only counted once in the final answer;\nPlease create a class **FAR** with the property **arr** in Python language based on the above question; then create a class **SN_FAR** inheriting the **FAR** class, and add a public function **Final_Answer** to return the number of possible results.", "test_list": ["assert candidate([0])==1", "assert candidate([1,1,2])==3", "assert candidate([1,2,4])==6"], "test_function": "def test_run(content1):\n    return SN_FAR(content1).Final_Answer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FAR\", \"def __init__(self, arr)\", \"class SN_FAR(FAR)\", \"super().__init__(arr)\", \"def Final_Answer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/51", "question": "Question: Given a string **s** and an integer **k**. You can choose one from the first **k** letters of **s** and add it to the end of the string. Return the lexicographically smallest string after any number of moves applying the above steps;\nPlease create a class **SSG** with the attribute **s** in Python based on the above question; then create another class **SN_SSG** that inherits from the **SSG** class, and add the attribute **k**, as well as a public function **Smallest_string** to return the lexicographically smallest string after any number of moves applying the above steps.", "test_list": ["assert candidate(\"cba\",1)==\"acb\"", "assert candidate(\"baaca\",3)==\"aaabc\""], "test_function": "def test_run(content1,content2):\n    return SN_SSG(content1,content2).Smallest_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSG\", \"def __init__(self, s)\", \"class SN_SSG(SSG)\", \"def __init__(self, s, k)\", \"super().__init__(s)\", \"def Smallest_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/52", "question": "Question: Given a numerical array **digits** sorted in non-decreasing order. You can write numbers using digits[i] any number of times. For example, if digits = ['1','3','5'], we can write numbers like '13', '551', and '1351315'. Return the number of positive integers that can be generated that are less than or equal to a given integer **n**;\nPlease create a class **NDG** in Python based on the above question, with the property **digits**; then create a class **SN_NDG** that inherits the **NDG** class, and add the property **n**, as well as a public function **Non_decreasing** to return the number of positive integers that can be generated that are less than or equal to the given integer **n**.", "test_list": ["assert candidate([\"1\",\"3\",\"5\",\"7\"],100)==20", "assert candidate([\"1\",\"4\",\"9\"],1000000000)==29523", "assert candidate([\"7\"],8)==1"], "test_function": "def test_run(content1,content2):\n    return SN_NDG(content1,content2).Non_decreasing()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NDG\", \"def __init__(self, digits)\", \"class SN_NDG(NDG)\", \"def __init__(self, digits, n)\", \"super().__init__(digits)\", \"def Non_decreasing\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/53", "question": "Question: Given a string **s** of length **n**, where s[i] is:\n1. **D** means decrease; 2. **I** means increase; A valid arrangement is a permutation **perm** of n+1 integers within the range [0, n], so that for all **i**:\n1. If s[i] == 'D', then perm[i] > perm[i+1]; 2. If s[i] == 'I', then perm[i] < perm[i+1]. Return the number of valid arrangements **perm**;\nBased on the above question, please create a class **EAT** in Python, with the attribute **s**; then create a class **SN_EAT** that inherits from the **EAT** class, and add a public function **Effective_arrangement** that returns the number of valid arrangements **perm**.", "test_list": ["assert candidate(\"DID\")==5", "assert candidate(\"D\")==1"], "test_function": "def test_run(content1):\n    return SN_EAT(content1).Effective_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EAT\", \"def __init__(self, s)\", \"class SN_EAT(EAT)\", \"super().__init__(s)\", \"def Effective_arrangement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/54", "question": "Question: Given an integer array **arr**, find the sum of min(b), where **b** ranges over each (continuous) subarray of **arr**.\nPlease create a class **IAY** in Python language based on the above question, with the attribute **arr**; then create a class **SN_IAY** that inherits from the **IAY** class, and add a public function **Integer_array** to return the sum of min(b).", "test_list": ["assert candidate([3,1,2,4])==17", "assert candidate([11,81,94,43,3])==444"], "test_function": "def test_run(content1):\n    return SN_IAY(content1).Integer_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IAY\", \"def __init__(self, arr)\", \"class SN_IAY(IAY)\", \"super().__init__(arr)\", \"def Integer_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/55", "question": "Question: Given an integer array **nums** and an integer **k**. For each index **i** (0<=i<nums.length), change nums[i] to nums[i]+k or nums[i]-k. The score of **nums** is the difference between the maximum and minimum elements in **nums**. After changing the value corresponding to each index, return the minimum score of **nums**;\nBased on the above question, please use Python to create a class **MSE** with the attribute **nums**; then create another class **SN_MSE** that inherits from the **MSE** class, and add the attribute **k**, as well as a public function **Minimum_score** that returns the minimum score of **nums**.", "test_list": ["assert candidate([1],0)==0", "assert candidate([0,10],2)==6", "assert candidate([1,3,6],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MSE(content1,content2).Minimum_score()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSE\", \"def __init__(self, nums)\", \"class SN_MSE(MSE)\", \"def __init__(self, nums, k)\", \"super().__init__(nums)\", \"def Minimum_score\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/56", "question": "Question: Given an integer array **nums**, please sort this array in ascending order;\nBased on the above question, please create a class **AOR** using Python language, with the attribute **nums**; then create another class **SN_AOR** that inherits from the **AOR** class, and add a public function **ascend_order** to sort the integer array **nums** in ascending order.", "test_list": ["assert candidate([5,2,3,1])==[1,2,3,5]", "assert candidate([5,1,1,2,0,0])==[0,0,1,1,2,5]"], "test_function": "def test_run(content1):\n    return SN_AOR(content1).ascend_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AOR\", \"def __init__(self, nums)\", \"class SN_AOR(AOR)\", \"super().__init__(nums)\", \"def ascend_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/57", "question": "Question: Two players play the roles of a cat and a mouse respectively, and they play a game on an undirected graph, taking turns to move. The form of the graph is: graph[a] is a list, consisting of all nodes **b** that satisfy that **ab** is an edge in the graph. The **mouse** starts from node 1 and moves first; the **cat** starts from node 2 and moves second. There is a **hole** at node 0. In each player's move, they must move along an edge connected to their current position in the graph. For example, if the mouse is at node 1, it must move to any node in graph[1]. In addition, the cat cannot move into the hole (node 0). Then, the game ends when one of the following three situations occurs: If the cat and the mouse appear at the same node, the cat wins. If the mouse reaches the hole, the mouse wins. If a position is repeated (that is, the player's position and the order of movement are the same as the last action), the game is a draw. Given a graph, and assuming that both players participate in the game in their best state: if the mouse wins, return 1; if the cat wins, return 2; if it is a draw, return 0;\nBased on the above question, please create a class called **CGS** in Python language with the attribute **graph**; then create a class called **SN_CGS** that inherits from the **CGS** class, and add a public function called **Cat_games** to return the final game result.", "test_list": ["assert candidate([[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]])==0", "assert candidate([[1,3],[0],[3],[0,2]])==1"], "test_function": "def test_run(content1):\n    return SN_CGS(content1).Cat_games()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CGS\", \"def __init__(self, graph)\", \"class SN_CGS(CGS)\", \"super().__init__(graph)\", \"def Cat_games\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/58", "question": "Question: Given a deck of cards, each card has an integer written on it. At this point, you need to select a number **X**, so that we can divide the deck into one or more groups according to the following rules: each group has **X** cards. All the cards in the group have the same integer written on them. Return True only when the selectable **X** is greater than or equal to 2, otherwise return False;\nBased on the above question, please use Python language to create a class **SIR** with the attribute **deck**; then create a class **SN_SIR** that inherits the **SIR** class, and add a public function **Same_integer** to determine whether the selectable **X** is greater than or equal to 2. If it is, return True, otherwise, return False.", "test_list": ["assert candidate([1,2,3,4,4,3,2,1])==True", "assert candidate([1,1,1,2,2,2,3,3])==False"], "test_function": "def test_run(content1):\n    return SN_SIR(content1).Same_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SIR\", \"def __init__(self, deck)\", \"class SN_SIR(SIR)\", \"super().__init__(deck)\", \"def Same_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/59", "question": "Question: Given an array **nums**, divide it into two consecutive sub-arrays **left** and **right** so that:\n1. Each element in **left** is less than or equal to each element in **right**. 2. Both **left** and **right** are non-empty. 3. The length of **left** should be as small as possible. After completing such grouping, return the length of **left**;\nPlease create a class **PLH** in Python language based on the above question, with the attribute **nums**; then create another class **SN_PLH** that inherits the **PLH** class, and add a public function **Packet_Length** to divide the array **nums** into two consecutive sub-arrays **left** and **right**, and then return the length of **left** after grouping.", "test_list": ["assert candidate([5,0,3,8,6])==3", "assert candidate([1,1,1,0,6,12])==4"], "test_function": "def test_run(content1):\n    return SN_PLH(content1).Packet_Length()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PLH\", \"def __init__(self, nums)\", \"class SN_PLH(PLH)\", \"super().__init__(nums)\", \"def Packet_Length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/60", "question": "Question: Given two string arrays **words1** and **words2**. Now, if every letter in **b** appears in **a**, including the repeated letters, then we say that string **b** is a subset of string **a**. If for every word **b** in **words2**, **b** is a subset of **a**, then we say that the word **a** in **words1** is a universal word. Return all the universal words in **words1** in the form of an array;\nBased on the above question, create a class **CWS** using Python language, with the property **words1**; then create a class **SN_CWS**, inheriting from the **CWS** class, and add the property **words2**, as well as a public function **Common_Words** to return all the universal words in **words1** in the form of an array.", "test_list": ["assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"e\",\"o\"])==[\"facebook\",\"google\",\"leetcode\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"l\",\"e\"])==[\"apple\",\"google\",\"leetcode\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"e\",\"oo\"])==[\"facebook\",\"google\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"lo\",\"eo\"])==[\"google\",\"leetcode\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"ec\",\"oc\",\"ceo\"])==[\"facebook\",\"leetcode\"]"], "test_function": "def test_run(content1,content2):\n    return SN_CWS(content1,content2).Common_Words()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CWS\", \"def __init__(self, words1)\", \"class SN_CWS(CWS)\", \"def __init__(self, words1, words2)\", \"super().__init__(words1)\", \"def Common_Words\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/61", "question": "Question: Given a circular integer array **nums** of length **n**, return the maximum possible sum of non-empty subarrays in **nums**. \nPlease create a class **CAY** in Python based on the above question, with the attribute **nums**. Then create another class **SN_CAY**, inheriting from the **CAY** class, and add a public function **Circular_array** to return the maximum possible sum of non-empty subarrays in the circular integer array **nums** of length **n**.", "test_list": ["assert candidate([1,-2,3,-2])==3", "assert candidate([5,-3,5])==10", "assert candidate([3,-2,2,-3])==3"], "test_function": "def test_run(content1):\n    return SN_CAY(content1).Circular_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CAY\", \"def __init__(self, nums)\", \"class SN_CAY(CAY)\", \"super().__init__(nums)\", \"def Circular_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/62", "question": "Question: You have **n** different songs in your music player. During your journey, you plan to listen to **goal** songs (not necessarily different, i.e., song repetition is allowed). You will create a playlist according to the following rules:\n1. Each song is played at least once. 2. A song can only be played again after other **k** songs have been played. Given **n**, **goal**, and **k**, return the number of playlists that can meet the requirements.\nBased on the above question, please create a class **PAL** in Python with the attribute **n**; then create another class **SN_PAL**, inheriting from the **PAL** class, and add two attributes **goal** and **k**, as well as a public function **PlayList** that returns the number of playlists that can meet the requirements.", "test_list": ["assert candidate(3,3,1)==6", "assert candidate(2,3,0)==6", "assert candidate(2,3,1)==2"], "test_function": "def test_run(content1,content2,content3):\n    return SN_PAL(content1,content2,content3).PlayList()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PAL\", \"def __init__(self, n)\", \"class SN_PAL(PAL)\", \"def __init__(self, n, goal, k)\", \"super().__init__(n)\", \"def PlayList\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/63", "question": "Question: A parenthesis string is valid only if one of the following conditions is met:\n1. It is an empty string; 2. It can be written as AB (A connected with B), where both A and B are valid strings; 3. It can be written as (A), where A is a valid string. Given a parenthesis string **s**, in each operation, you can insert a parenthesis at any position in the string to make the result string **s** valid. The task is to return the minimum number of parentheses that must be added to make the string **s** valid.\nBased on the above question, please create a class **MPS** in Python, which has an attribute **s**. Then create another class **SN_MPS**, which inherits from the **MPS** class, and add a public function **Minimum_parentheses** that returns the minimum number of parentheses that must be added to make the result string **s** valid.", "test_list": ["assert candidate(\"())\")==1", "assert candidate(\"(((\")==3"], "test_function": "def test_run(content1):\n    return SN_MPS(content1).Minimum_parentheses()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MPS\", \"def __init__(self, s)\", \"class SN_MPS(MPS)\", \"super().__init__(s)\", \"def Minimum_parentheses\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/64", "question": "Question: Given a non-negative integer array **nums**, half of the integers in **nums** are odd, and half are even. Sort the array so that when nums[i] is odd, **i** is also odd; when nums[i] is even, **i** is also even. You can return any array that meets the above conditions as the answer;\nBased on the above question, please use Python to create a class **ASG** with the attribute **nums**; then create a class **SN_ASG** that inherits from the **ASG** class, and add a public function **Array_sorting** that returns an array that meets the conditions as the answer.", "test_list": ["assert candidate([4,2,5,7])==[4,5,2,7]", "assert candidate([2,3])==[2,3]"], "test_function": "def test_run(content1):\n    return SN_ASG(content1).Array_sorting()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ASG\", \"def __init__(self, nums)\", \"class SN_ASG(ASG)\", \"super().__init__(nums)\", \"def Array_sorting\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/65", "question": "Question: Given an integer array **arr**, and an integer **target** as the target value, return the number of tuples **i**, **j**, **k** that satisfy i<j<k and arr[i]+arr[j]+arr[k]==target;\nPlease create a class **NTS** in Python language based on the above question, with **arr** as an attribute; then create another class **SN_NTS**, inheriting from the **NTS** class, and add the attribute **target**, as well as a public function **Number_tuples** to return the number of tuples **i**, **j**, **k** that satisfy i<j<k and arr[i]+arr[j]+arr[k]==target.", "test_list": ["assert candidate([1,1,2,2,3,3,4,4,5,5],8)==20", "assert candidate([1,1,2,2,2,2],5)==12"], "test_function": "def test_run(content1,content2):\n    return SN_NTS(content1,content2).Number_tuples()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NTS\", \"def __init__(self, arr)\", \"class SN_NTS(NTS)\", \"def __init__(self, arr, target)\", \"super().__init__(arr)\", \"def Number_tuples\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/66", "question": "Question: Given a binary string **s**, you can flip any 0 to 1 or flip 1 to 0. Return the minimum number of flips to make **s** monotonically increasing;\nPlease create a class **FTM** in Python based on the above question, with the attribute **s**. Then create another class **SN_FTM** that inherits from the **FTM** class, and add a public function **Flip_Times** to return the minimum number of flips to make the binary string **s** monotonically increasing.", "test_list": ["assert candidate(\"00110\")==1", "assert candidate(\"010110\")==2", "assert candidate(\"00011000\")==2"], "test_function": "def test_run(content1):\n    return SN_FTM(content1).Flip_Times()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTM\", \"def __init__(self, s)\", \"class SN_FTM(FTM)\", \"super().__init__(s)\", \"def Flip_Times\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/67", "question": "Question: Given an array **arr** composed of 0s and 1s, divide the array into three non-empty parts so that all these parts represent the same binary value. If it can be done, please return any [i, j], where i+1<j, so that:\n1. arr[0], arr[1], ..., arr[i] is the first part; 2. arr[i+1], arr[i+2], ..., arr[j-1] is the second part; 3. arr[j], arr[j+1], ..., arr[arr.length-1] is the third part. These three parts represent the same binary value. If it cannot be done, return [-1, -1];\nBased on the above question, please create a class **BVE** in Python with the attribute **arr**; then create a class **SN_BVE** that inherits the **BVE** class, and add a public function **Binary_values** that returns any [i, j], or [-1, -1] if not possible.", "test_list": ["assert candidate([1,0,1,0,1])==[0,3]", "assert candidate([1,1,0,1,1])==[-1,-1]", "assert candidate([1,1,0,0,1])==[0,2]"], "test_function": "def test_run(content1):\n    return SN_BVE(content1).Binary_values()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BVE\", \"def __init__(self, arr)\", \"class SN_BVE(BVE)\", \"super().__init__(arr)\", \"def Binary_values\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/68", "question": "Question: Given a binary array **nums** and an integer **goal**, please count and return how many non-empty subarrays have a sum equal to **goal**. \nPlease create a class **NSY** in Python based on the above question, with the attribute **nums**. Then create another class **SN_NSY**, inheriting from the **NSY** class, and add the attribute **goal**, as well as a public function **Non_subarray** to count and return how many non-empty subarrays have a sum equal to the integer **goal**.", "test_list": ["assert candidate([1,0,1,0,1],2)==4", "assert candidate([0,0,0,0,0],0)==15"], "test_function": "def test_run(content1,content2):\n    return SN_NSY(content1,content2).Non_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NSY\", \"def __init__(self, nums)\", \"class SN_NSY(NSY)\", \"def __init__(self, nums, goal)\", \"super().__init__(nums)\", \"def Non_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/69", "question": "Question: Given a square integer array **matrix** of size n x n, find and return the minimum sum of a descending path through the **matrix**;\nBased on the above question, create a class **DPH** in Python with the attribute **matrix**. Then create another class **SN_DPH** that inherits from the **DPH** class, and add a public function **descent_path** to return the minimum sum of a descending path through the integer array **matrix**.", "test_list": ["assert candidate([[2,1,3],[6,5,4],[7,8,9]])==13", "assert candidate([[-19,57],[-40,-5]])==-59"], "test_function": "def test_run(content1):\n    return SN_DPH(content1).descent_path()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DPH\", \"def __init__(self, matrix)\", \"class SN_DPH(DPH)\", \"super().__init__(matrix)\", \"def descent_path\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/70", "question": "Question: An array **nums** of length **n** is considered a beautiful array if it meets the following conditions:\n1. **nums** is a permutation of the integers in the range [1, n]. \n2. For every 0 <= i < j < n, there is no index **k** (i < k < j) such that 2*nums[k] == nums[i] + nums[j]. \nGiven an integer **n**, return a beautiful array of length **n**.\nBased on the above question, create a class **BAR** in Python with an attribute **n**. Then create another class **SN_BAR** that inherits from the **BAR** class, and add a public function **Beautiful_array** that returns a beautiful array of length **n**.", "test_list": ["assert candidate(4)==[2,1,4,3]", "assert candidate(5)==[3,1,2,5,4]"], "test_function": "def test_run(content1):\n    return SN_BAR(content1).Beautiful_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BAR\", \"def __init__(self, n)\", \"class SN_BAR(BAR)\", \"super().__init__(n)\", \"def Beautiful_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/71", "question": "Question: Given a binary matrix **grid** of size n x n, where 1 represents land and 0 represents water. An island is a maximum group formed by 1s connected on all four sides, i.e., it will not be connected to any other 1s not in the group. There are exactly two islands in the grid. You can turn any number of 0s into 1s to connect the two islands into one. Return the minimum number of 0s that must be flipped.\nBased on the above question, create a class **FNE** in Python, which has the attribute **grid**. Then create another class **SN_FNE** that inherits from the **FNE** class, and add a public function **Flip_Number** that returns the minimum number of 0s that must be flipped.", "test_list": ["assert candidate([[0,1],[1,0]])==1", "assert candidate([[0,1,0],[0,0,0],[0,0,1]])==2", "assert candidate([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]])==1"], "test_function": "def test_run(content1):\n    return SN_FNE(content1).Flip_Number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FNE\", \"def __init__(self, grid)\", \"class SN_FNE(FNE)\", \"super().__init__(grid)\", \"def Flip_Number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/72", "question": "Question: Given a log array **logs**. Each log is a string separated by spaces, with the first word being an identifier mixed with letters and numbers. There are two different types of logs:\n1. Letter logs: Apart from the identifier, all words are composed of lowercase letters; 2. Number logs: Apart from the identifier, all words are composed of numbers; Please re-sort the logs according to the following rules:\n1. All letter logs are ranked before number logs. 2. When the content of the letter logs is different, ignore the identifier and sort according to the alphabetical order of the content; when the content is the same, sort by the identifier. 3. The number logs should retain their original relative order. Return the final order of the logs;\nBased on the above question, please create a class **FOR** in Python language with the property **logs**; then create a class **SN_FOR** that inherits the **FOR** class, and add a public function **Final_order** to return the final order of the logs.", "test_list": ["assert candidate([\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"])==[\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]", "assert candidate([\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"])==[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]"], "test_function": "def test_run(content1):\n    return SN_FOR(content1).Final_order()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FOR\", \"def __init__(self, logs)\", \"class SN_FOR(FOR)\", \"super().__init__(logs)\", \"def Final_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/73", "question": "Question: Given a set of points **drop** on the xy-plane, determine the minimum area of the rectangle formed by these points, where the sides of the rectangle are parallel to the x-axis and y-axis. If no rectangle can be formed, return 0;\nBased on the above question, please create a class **MAR** in Python language with the property **drop**; then create a class **SN_MAR** that inherits from the **MAR** class, and add a public function **Minimum_Area** that returns the minimum area of the rectangle formed. If no rectangle can be formed, return 0.", "test_list": ["assert candidate([[1,1],[1,3],[3,1],[3,3],[2,2]])==4", "assert candidate([[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]])==2"], "test_function": "def test_run(content1):\n    return SN_MAR(content1).Minimum_Area()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MAR\", \"def __init__(self, drop)\", \"class SN_MAR(MAR)\", \"super().__init__(drop)\", \"def Minimum_Area\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/74", "question": "Question: Given a string **s**, calculate the number of different non-empty sub-sequences of **s**;\nBased on the above question, please create a class **ESU** in Python language with the attribute **s**. Then create another class **SN_ESU** that inherits from the **ESU** class, and add a public function **empty_subsequence** to return the number of different non-empty sub-sequences of the string **s**.", "test_list": ["assert candidate(\"abc\")==7", "assert candidate(\"aba\")==6", "assert candidate(\"aaa\")==3"], "test_function": "def test_run(content1):\n    return SN_ESU(content1).empty_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ESU\", \"def __init__(self, s)\", \"class SN_ESU(ESU)\", \"super().__init__(s)\", \"def empty_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/75", "question": "Question: Given an integer array **nums**. Each **move** operation will choose any index **i** that satisfies 0<=i<nums.length, and increase **nums[i]** by 1. Return the minimum number of operations required to make each value in **nums** unique;\nPlease create a class **MOT** with the attribute **nums** in Python based on the above question. Then create a class **SN_MOT** that inherits from the **MOT** class, and add a public function **Minimum_operations** to return the minimum number of operations required to make each value in the integer array **nums** unique.", "test_list": ["assert candidate([1,2,2])==1", "assert candidate([3,2,1,2,1,7])==6"], "test_function": "def test_run(content1):\n    return SN_MOT(content1).Minimum_operations()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MOT\", \"def __init__(self, nums)\", \"class SN_MOT(MOT)\", \"super().__init__(nums)\", \"def Minimum_operations\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/76", "question": "Question: Given two sequences **pushed** and **popped**, each with unique values, return True if they could be the result of a sequence of **push** and **pop** operations on an initially empty stack; otherwise, return False. \nBased on the above question, create a class **ISK** in Python language with the attribute **pushed**; then create another class **SN_ISK** that inherits from the **ISK** class, and add the attribute **popped**, as well as a public function **Initial_stack** that returns the corresponding result.", "test_list": ["assert candidate([1,2,3,4,5],[4,5,3,2,1])==True", "assert candidate([1,2,3,4,5],[4,3,5,1,2])==False"], "test_function": "def test_run(content1,content2):\n    return SN_ISK(content1,content2).Initial_stack()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ISK\", \"def __init__(self, pushed)\", \"class SN_ISK(ISK)\", \"def __init__(self, pushed, popped)\", \"super().__init__(pushed)\", \"def Initial_stack\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/77", "question": "Question: There are **n** stones placed on some integer coordinates in a two-dimensional plane. Each coordinate can have at most one stone. If a stone has other stones on the same row or column, it can be removed. Given an array of length **n**, **stones**, where stones[i] = [x_i, y_i] represents the position of the i-th stone, return the maximum number of stones that can be removed;\nPlease create a class **RSN** in Python based on the above problem, with the attribute **stones**. Then create a class **SN_RSN** that inherits the **RSN** class, and add a public function **Removed_stones** to return the maximum number of stones that can be removed.", "test_list": ["assert candidate([[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]])==5", "assert candidate([[0,0],[0,2],[1,1],[2,0],[2,2]])==3", "assert candidate([[0,0]])==0"], "test_function": "def test_run(content1):\n    return SN_RSN(content1).Removed_stones()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RSN\", \"def __init__(self, stones)\", \"class SN_RSN(RSN)\", \"super().__init__(stones)\", \"def Removed_stones\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/78", "question": "Question: Your initial energy is **power**, and your initial score is 0. You only have one pack of **tokens**. Where tokens[i] is the value of the i-th token (index starts from 0). There are two possible ways to use the tokens as follows:\n1. If you have at least token[i] points of energy, you can flip the i-th token face up, lose token[i] points of energy, and gain 1 point. 2. If we have at least 1 point, we can flip the i-th token face down, gain token[i] points of energy, and lose 1 point. Each token can only be used once, the order of use is not limited, and it is not necessary to use all tokens. After using any number of tokens, return the maximum score we can get;\nPlease create a class **INY** in Python based on the above question, with the attribute **tokens**; then create a class **SN_INY** that inherits the **INY** class, and add the attribute **power**, as well as a public function **Initial_energy** that returns the maximum score that can be obtained.", "test_list": ["assert candidate([100],50)==0", "assert candidate([100,200],150)==1", "assert candidate([100,200,300,400],200)==2"], "test_function": "def test_run(content1,content2):\n    return SN_INY(content1,content2).Initial_energy()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class INY\", \"def __init__(self, tokens)\", \"class SN_INY(INY)\", \"def __init__(self, tokens, power)\", \"super().__init__(tokens)\", \"def Initial_energy\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/79", "question": "Question: Given an array composed of 4 digits, return the maximum time that can be set in accordance with the 24-hour system. The 24-hour format is **HH:MM**, where HH is between 00 and 23, and MM is between 00 and 59. The smallest 24-hour system time is 00:00, and the largest is 23:59. Starting from 00:00 (midnight), the longer it passes, the greater the time. Return the answer in the format of **HH:MM** with a string length of 5. If the valid time cannot be determined, return an empty string;\nBased on the above question, please create a class named **ETM** in Python, which has an attribute **arr**; then create a class **SN_ETM** that inherits from the **ETM** class, and add a public function **effective_time** that returns the maximum time that can be set in accordance with the 24-hour system. If the valid time cannot be determined, return an empty string.", "test_list": ["assert candidate([1,2,3,4])==\"23:41\"", "assert candidate([5,5,5,5])==\"\"", "assert candidate([0,0,0,0])==\"00:00\"", "assert candidate([0,0,1,0])==\"10:00\""], "test_function": "def test_run(content1):\n    return SN_ETM(content1).effective_time()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ETM\", \"def __init__(self, arr)\", \"class SN_ETM(ETM)\", \"super().__init__(arr)\", \"def effective_time\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/80", "question": "Question: Given a non-empty array **nums** composed of different positive integers, consider the following graph:\n1. There are nums.length nodes, marked from nums[0] to nums[nums.length-1]; 2. There is an edge between nums[i] and nums[j] only when nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph;\nBased on the above question, please create a class **CCN** in Python language with the attribute **nums**; then create a class **SN_CCN** that inherits from the **CCN** class, and add a public function **Connected_components** to return the size of the largest connected component in the graph.", "test_list": ["assert candidate([4,6,15,35])==4", "assert candidate([20,50,9,63])==2", "assert candidate([2,3,6,7,4,12,21,39])==8"], "test_function": "def test_run(content1):\n    return SN_CCN(content1).Connected_components()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CCN\", \"def __init__(self, nums)\", \"class SN_CCN(CCN)\", \"super().__init__(nums)\", \"def Connected_components\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/81", "question": "Question: Given an integer array **arr** of even length, return True if **arr** can be rearranged to satisfy for each 0<=i<len(arr)/2, arr[2*i+1]=2*arr[2*i]; otherwise, return False. \nPlease create a class **RSF** with the attribute **arr** in Python based on the above question. Then create another class **SN_RSF** that inherits from the **RSF** class, and add a public function **Reorganization_satisfaction** that returns the corresponding result.", "test_list": ["assert candidate([3,1,3,6])==False", "assert candidate([2,1,2,6])==False", "assert candidate([4,-2,2,-4])==True"], "test_function": "def test_run(content1):\n    return SN_RSF(content1).Reorganization_satisfaction()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RSF\", \"def __init__(self, arr)\", \"class SN_RSF(RSF)\", \"super().__init__(arr)\", \"def Reorganization_satisfaction\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/82", "question": "Question: Given an array **strs** composed of **n** strings, where each string is of equal length. Select a deletion index sequence, for each string in **strs**, delete the character at each corresponding index. Suppose, we have chosen a set of deletion indices **answer**, then after performing the deletion operation, the elements of the final array are arranged in lexicographical order (strs[0]<=strs[1]<=strs[2]...<=strs[n-1]), then please return the smallest possible value of answer.length;\nBased on the above question, please create a class **MPL** in Python language with the attribute **strs**; then create a class **SN_MPL** that inherits the **MPL** class, and add a public function **Minimum_possible** to return the smallest possible value of answer.length.", "test_list": ["assert candidate([\"ca\",\"bb\",\"ac\"])==1", "assert candidate([\"xc\",\"yb\",\"za\"])==0", "assert candidate([\"zyx\",\"wvu\",\"tsr\"])==3"], "test_function": "def test_run(content1):\n    return SN_MPL(content1).Minimum_possible()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MPL\", \"def __init__(self, strs)\", \"class SN_MPL(MPL)\", \"super().__init__(strs)\", \"def Minimum_possible\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/83", "question": "Question: You are installing a billboard and want it to be as high as possible. This billboard will have two steel brackets, one on each side. The height of each steel bracket must be equal. You have a pile of **rods** that can be welded together. For example, if the lengths of the rods are 1, 2, and 3, they can be welded together to form a bracket of length 6. Return the maximum possible installation height of the billboard. If the billboard cannot be installed, please return 0;\nPlease create a class called **IBD** in Python based on the above problem, with the attribute **rods**; then create a class **SN_IBD** that inherits from the **IBD** class, and add a public function **Install_billboards** that returns the maximum possible installation height of the billboard. If the billboard cannot be installed, please return 0.", "test_list": ["assert candidate([1,2,3,6])==6", "assert candidate([1,2,3,4,5,6])==10", "assert candidate([1,2])==0"], "test_function": "def test_run(content1):\n    return SN_IBD(content1).Install_billboards()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IBD\", \"def __init__(self, rods)\", \"class SN_IBD(IBD)\", \"super().__init__(rods)\", \"def Install_billboards\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/84", "question": "Question: In an nxn grid composed of 1x1 squares, each 1x1 square is made up of '/', '\\' or a space. These characters divide the square into some regions with common edges. Given the grid represented as an array of strings, return the number of regions;\nPlease create a class **NAS** in Python based on the above question, with the attribute **grid**; then create a class **SN_NAS** that inherits from the **NAS** class, and add a public function **Number_areas** that returns the number of regions.", "test_list": ["assert candidate([\" /\",\"/ \"])==2", "assert candidate([\" /\",\"  \"])==1", "assert candidate([\"/\\\",\"\\/\"])==5"], "test_function": "def test_run(content1):\n    return SN_NAS(content1).Number_areas()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NAS\", \"def __init__(self, grid)\", \"class SN_NAS(NAS)\", \"super().__init__(grid)\", \"def Number_areas\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/85", "question": "Question: Given an array of **strs** composed of **n** lowercase letter strings, where each string is of equal length. Select a deletion index sequence, and for each string in **strs**, delete the character at each corresponding index. For example, if strs = [\"abcdef\", \"uvwxyz\"], and the deletion index sequence is {0,2,3}, the result after deletion would be [\"bef\", \"vyz\"]. Suppose we have chosen a set of deletion indices **answer**, then after performing the deletion operation, each element in the row of the final array is sorted in dictionary order (i.e., (strs[0][0]<=strs[0][1]<=...<=strs[0][strs[0].length-1]) and (strs[1][0]<=strs[1][1]<=...<=strs[1][strs[1].length-1]), and so on). Please return the smallest possible value of answer.length;\nBased on the above question, please create a class **MSI** in Python language with the property **strs**; then create a class **SN_MSI** that inherits from the **MSI** class, and add a public function **Minimum_spossible** that returns the smallest possible value of answer.length.", "test_list": ["assert candidate([\"babca\",\"bbazb\"])==3", "assert candidate([\"edcba\"])==4", "assert candidate([\"ghi\",\"def\",\"abc\"])==0"], "test_function": "def test_run(content1):\n    return SN_MSI(content1).Minimum_spossible()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSI\", \"def __init__(self, strs)\", \"class SN_MSI(MSI)\", \"super().__init__(strs)\", \"def Minimum_spossible\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/86", "question": "Question: Given an integer array **A**, a slope is a tuple (i, j), where i < j and A[i] <= A[j]. The width of such a slope is j-i. Find the maximum width of the slope in **A**, if it does not exist, return 0.\nPlease create a class **WSP** in Python language based on the above question, with the attribute **A**. Then create another class **SN_WSP**, inheriting from the **WSP** class, and add a public function **Width_slope** to find the maximum width of the slope in **A**, if it does not exist, return 0.", "test_list": ["assert candidate([6,0,8,2,1,5])==4", "assert candidate([9,8,1,0,1,9,4,0,4,1])==7"], "test_function": "def test_run(content1):\n    return SN_WSP(content1).Width_slope()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class WSP\", \"def __init__(self, A)\", \"class SN_WSP(WSP)\", \"super().__init__(A)\", \"def Width_slope\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/87", "question": "Question: Given a set of points **drop** on the **xy** plane, determine the minimum area of any rectangle formed by these points, where the sides of the rectangle are not necessarily parallel to the x-axis and y-axis. If there are no rectangles, return 0;\nBased on the above question, please create a class **ARE** in Python language with the property **drop**; then create a class **SN_ARE** that inherits from the **ARE** class, and add a public function **Any_rectangle** to return the minimum area of any rectangle formed. If there are no rectangles, return 0.", "test_list": ["assert candidate([[1,2],[2,1],[1,0],[0,1]])==2.00000", "assert candidate([[0,1],[2,1],[1,1],[1,0],[2,0]])==1.00000", "assert candidate([[0,3],[1,2],[3,1],[1,3],[2,1]])==0", "assert candidate([[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]])==2.00000"], "test_function": "def test_run(content1):\n    return SN_ARE(content1).Any_rectangle()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ARE\", \"def __init__(self, drop)\", \"class SN_ARE(ARE)\", \"super().__init__(drop)\", \"def Any_rectangle\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/88", "question": "Question: Given a positive integer **x**, we will write an expression of the form x(op1)x(op2)x(op3)x..., where each operator op1, op2, ... can be one of addition, subtraction, multiplication, or division (+, -, *, or /). For example, for x=3, we can write the expression 3*3/3+3-3, which equals 3. When writing such expressions, we need to follow these conventions:\n1. The division operator (/) returns a rational number; 2. There are no parentheses anywhere; 3. We use the usual order of operations: multiplication and division occur before addition and subtraction; 4. The unary negation operator (-) is not allowed. For example, **x-x** is a valid expression because it only uses subtraction, but **-x+x** is not because it uses the negation operator. We want to write an expression that equals a given **target** value and uses the fewest operators. Return the minimum number of operators used.\nBased on the above question, please create a class **MNOOT** in Python with the attribute **x**; then create a class **SN_MNOOT** that inherits from the **MNOOT** class, and add a target attribute and a public function **minimum_operators** that returns the minimum number of operators used.", "test_list": ["assert candidate(3,19)==5", "assert candidate(5,501)==8", "assert candidate(100,100000000)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MNOOT(content1,content2).minimum_operators==5()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNOOT\", \"def __init__(self, x)\", \"class SN_MNOOT(MNOOT)\", \"def __init__(self, x, target)\", \"super().__init__(x)\", \"def minimum_operators\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/89", "question": "Question: Return all non-negative integers of length **n** such that the absolute difference between the digits in every two consecutive positions is **k**;\nPlease create a class **NIG** in Python language based on the above question, with the attribute **n**. Then create a class **SN_NIG** that inherits from the **NIG** class, and add the attribute **k**, as well as a public function **nonnegative_integer** to return the result of the above question.", "test_list": ["assert candidate(3,7)==[181,292,707,818,929]", "assert candidate(2,1)==[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]", "assert candidate(2,0)==[11,22,33,44,55,66,77,88,99]", "assert candidate(2,2)==[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]"], "test_function": "def test_run(content1,content2):\n    return SN_NIG(content1,content2).nonnegative_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NIG\", \"def __init__(self, n)\", \"class SN_NIG(NIG)\", \"def __init__(self, n, k)\", \"super().__init__(n)\", \"def nonnegative_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/90", "question": "Question: Given an integer array **arr**, please sort the array using pancake flipping. The execution process of a pancake flip is as follows:\n1. Choose an integer **k**, where 1<=k<=arr.length; 2. Reverse the sub-array arr[0...k-1] (index starts from 0); Return the sequence of **k** values corresponding to the pancake flipping operations that can sort **arr** in the form of an array. Any valid answer that sorts the array and the number of flips is within the range of 10*arr.length will be judged as correct;\nBased on the above question, please create a class **PFG** in Python language with the property **arr**; then create a class **SN_PFG** that inherits the **PFG** class, and add a public function **Pancake_flipping** to return the sequence of **k** values corresponding to the pancake flipping operations that can sort the integer array **arr** in the form of an array.", "test_list": ["assert candidate([3,2,4,1])==[4,2,4,3]", "assert candidate([1,2,3])==[]"], "test_function": "def test_run(content1):\n    return SN_PFG(content1).Pancake_flipping()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PFG\", \"def __init__(self, arr)\", \"class SN_PFG(PFG)\", \"super().__init__(arr)\", \"def Pancake_flipping\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/91", "question": "Question: Given three integers **x**, **y**, and **bound**, return a list of all powerful integers that are less than or equal to **bound**;\nBased on the above question, please create a class **SIG** in Python with the attribute **x**; then create a class **SN_SIG** that inherits from the **SIG** class, and add two attributes **y** and **bound**, as well as a public function **Strong_integer** to return a list of all powerful integers that are less than or equal to **bound**.", "test_list": ["assert candidate(2,3,10)==[2,3,4,5,7,9,10]", "assert candidate(3,5,15)==[2,4,6,8,10,14]"], "test_function": "def test_run(content1,content2,content3):\n    return SN_SIG(content1,content2,content3).Strong_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SIG\", \"def __init__(self, x)\", \"class SN_SIG(SIG)\", \"def __init__(self, x, y, bound)\", \"super().__init__(x)\", \"def Strong_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/92", "question": "Question: Given two strings **s** and **t**, each string represents a non-negative rational number, return True only when they represent the same number;\nBased on the above question, please create a class **SNR** in Python with the attribute **s**; then create another class **SN_SNR** inheriting from the **SNR** class, adding the attribute **t**, as well as a public function **Same_number** to return the result of the above question.", "test_list": ["assert candidate(\"0.(52)\",\"0.5(25)\")==True", "assert candidate(\"0.1666(6)\",\"0.166(66)\")==True", "assert candidate(\"0.9(9)\",\"1.\")==True"], "test_function": "def test_run(content1,content2):\n    return SN_SNR(content1,content2).()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SNR\", \"def __init__(self, s)\", \"class SN_SNR(SNR)\", \"def __init__(self, s, t)\", \"super().__init__(s)\", \"def Same_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/93", "question": "Question: Given an array **points**, where points[i] = [x_i, y_i] represents a point on the X-Y plane, and an integer **k**, return the **k** points closest to the origin (0,0);\nBased on the above question, create a class **NOG** in Python, with the attribute **points**; then create a class **SN_NOG** that inherits from the **NOG** class, and add the attribute **k**, as well as a public function **Nearest_origin** to return the **k** points closest to the origin (0,0).", "test_list": ["assert candidate([[1,3],[-2,2]],1)==[[-2,2]]", "assert candidate([[3,3],[5,-1],[-2,4]],2)==[[3,3],[-2,4]]"], "test_function": "def test_run(content1,content2):\n    return SN_NOG(content1,content2).Nearest_origin()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NOG\", \"def __init__(self, points)\", \"class SN_NOG(NOG)\", \"def __init__(self, points, k)\", \"super().__init__(points)\", \"def Nearest_origin\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/94", "question": "Question: Given an integer array **nums** and an integer **k**, return the number of (continuous, non-empty) sub-arrays whose sum of elements can be divided by **k**. \nPlease create a class **SET** in Python language based on the above question, which has the attribute **nums**. Then create another class **SN_SET**, inheriting from the **SET** class, and add the attribute **k**, as well as a public function **Sum_Elements** to return the number of (continuous, non-empty) sub-arrays in the integer array **nums** whose sum of elements can be divided by **k**.", "test_list": ["assert candidate([4,5,0,-2,-3,1],5)==7", "assert candidate([5],9)==0"], "test_function": "def test_run(content1,content2):\n    return SN_SET(content1,content2).Sum_Elements()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SET\", \"def __init__(self, nums)\", \"class SN_SET(SET)\", \"def __init__(self, nums, k)\", \"super().__init__(nums)\", \"def Sum_Elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/95", "question": "Question: Given an integer array **A**, you can start from a certain index and make a certain number of jumps. During your jumping process, the 1-th, 3-th, 5-th... jumps are called odd jumps, while the 2-th, 4-th, 6-th... jumps are called even jumps. You can jump from index **i** to index **j** (where **i < j**) in the following ways:\n1. During an odd jump (e.g., the 1-th, 3-th, 5-th... jumps), you will jump to index **j** such that A[i] <= A[j], and A[j] is the smallest possible value. If there are multiple such indexes **j**, you can only jump to the smallest index **j** that meets the requirement.\n2. During an even jump (e.g., the 2-th, 4-th, 6-th... jumps), you will jump to index **j** such that A[i] >= A[j], and A[j] is the largest possible value. If there are multiple such indexes **j**, you can only jump to the smallest index **j** that meets the requirement. (For some indexes **i**, it may not be possible to make a jump that meets the requirement.)\n3. If you can reach the end of the array (index A.length-1) by making a certain number of jumps (possibly 0 or more) starting from a certain index, then that index is considered a good starting index. Return the number of good starting indexes.\nPlease create a class **SID** in Python language based on the above question, with the attribute **A**. Then create another class **SN_SID** that inherits the **SID** class, and add a public function **start_index** that returns the number of good starting indexes.", "test_list": ["assert candidate([10,13,12,14,15])==2", "assert candidate([2,3,1,1,4])==3", "assert candidate([5,1,3,4,2])==3"], "test_function": "def test_run(content1):\n    return SN_SID(content1).start_index()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SID\", \"def __init__(self, A)\", \"class SN_SID(SID)\", \"super().__init__(A)\", \"def start_index\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/96", "question": "Question: Given an integer array **arr**, return the length of the maximum **turbulence subarray** in **arr**. A subarray is a **turbulence subarray** if the comparison sign flips between each pair of adjacent elements in the subarray;\nBased on the above question, create a class **MTL** in Python, which has the attribute **arr**; then create another class **SN_MTL** that inherits from the **MTL** class, and add a public function **Maximum_turbulence** that returns the length of the maximum **turbulence subarray** in **arr**.", "test_list": ["assert candidate([9,4,2,10,7,8,8,1,9])==5", "assert candidate([4,8,12,16])==2", "assert candidate([100])==1"], "test_function": "def test_run(content1):\n    return SN_MTL(content1).Maximum_turbulence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MTL\", \"def __init__(self, arr)\", \"class SN_MTL(MTL)\", \"super().__init__(arr)\", \"def Maximum_turbulence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/97", "question": "Question: On a two-dimensional grid **grid**, there are 4 types of squares:\n**1** represents the starting square, and there is only one starting square; **2** represents the ending square, and there is only one ending square; **0** represents the empty square that we can walk through; **-1** represents the obstacle that we cannot cross. Return the number of different paths from the starting square to the ending square when walking in four directions (up, down, left, and right);\nBased on the above question, please create a class **DPS** using Python language, with the attribute **grid**; then create a class **SN_DPS** that inherits the **DPS** class, and add a public function **Different_paths** to return the result of the above question.", "test_list": ["assert candidate([[1,0,0,0],[0,0,0,0],[0,0,2,-1]])==2", "assert candidate([[1,0,0,0],[0,0,0,0],[0,0,0,2]])==4", "assert candidate([[0,1],[2,0]])==0"], "test_function": "def test_run(content1):\n    return SN_DPS(content1).Different_paths()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DPS\", \"def __init__(self, grid)\", \"class SN_DPS(DPS)\", \"super().__init__(grid)\", \"def Different_paths\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/98", "question": "Question: Given an integer array **nums**, return the number of bitwise AND triplets. A bitwise AND triplet is a triplet made up of indices (i, j, k) that satisfy all of the following conditions:\n1. 0<=i<nums.length; 2. 0<=j<nums.length; 3. 0<=k<nums.length; 4. nums[i]&nums[j]&nums[k]==0, where & represents the bitwise AND operator;\nBased on the above question, create a class **BTT** using Python language, with the attribute **nums**; then create a class **SN_BTT** that inherits from the **BTT** class, and add a public function **Bitwise_triplet** that returns the number of bitwise AND triplets.", "test_list": ["assert candidate([2,1,3])==12", "assert candidate([0,0,0])==27"], "test_function": "def test_run(content1):\n    return SN_BTT(content1).Bitwise_triplet()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BTT\", \"def __init__(self, nums)\", \"class SN_BTT(BTT)\", \"super().__init__(nums)\", \"def Bitwise_triplet\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/99", "question": "Question: Given two integers a and b, return any string s that satisfies the following conditions:\n1. The length of s is a+b, and it contains exactly a occurrences of the letter 'a' and b occurrences of the letter 'b'.\n2. The substring 'aaa' does not appear in s.\n3. The substring 'bbb' does not appear in s.\nPlease create a class **ASG** in Python that has an attribute **a**. Then create a class **SN_ASG** that inherits from **ASG** and adds an attribute **b**, as well as a public function **Any_string** that returns the result of the above problem.", "test_list": ["assert candidate(1,2)==\"abb\"", "assert candidate(4,1)==\"aabaa\""], "test_function": "def test_run(content1,content2):\n    return SN_ASG(content1,content2).Any_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ASG\", \"def __init__(self, a)\", \"class SN_ASG(ASG)\", \"def __init__(self, a, b)\", \"super().__init__(a)\", \"def Any_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/100", "question": "Question: Given two lists composed of some closed intervals, **firstList** and **secondList**, where firstList[i]=[start_i,end_i] and secondList[j]=[start_j,end_j]. Each interval list is pairwise disjoint and already sorted. Return the intersection of these two interval lists;\nBased on the above question, please create a class **ILT** in Python language with the property **firstList**; then create another class **SN_ILT**, inheriting from the **ILT** class, and add the property **secondList**, as well as a public function **Interval_List** to return the intersection of the above two interval lists.", "test_list": ["assert candidate([[0,2],[5,10],[13,23],[24,25]],[[1,5],[8,12],[15,24],[25,26]])==[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]", "assert candidate([[1,3],[5,9]],[])==[]", "assert candidate([],[[4,8],[10,12]])==[]", "assert candidate([[1,7]],[[3,10]])==[[3,7]]"], "test_function": "def test_run(content1,content2):\n    return SN_ILT(content1,content2).Interval_List()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ILT\", \"def __init__(self, firstList)\", \"class SN_ILT(ILT)\", \"def __init__(self, firstList, secondList)\", \"super().__init__(firstList)\", \"def Interval_List\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/101", "question": "Question: Given an array composed of string equations that represent the relationships between variables, each string equation equations[i] has a length of 4 and takes one of two different forms: **a==b** or **a!=b**. Here, a and b are lowercase letters (not necessarily different), representing single-letter variable names. Return True only when integers can be assigned to variable names to satisfy all given equations, otherwise return False;\nBased on the above question, please create a class **SVE** in Python language with the attribute **equations**; then create another class **SN_SVE** that inherits from the **SVE** class, and add a public function **Single_variable** that returns the result of the above question.", "test_list": ["assert candidate([\"a==b\",\"b!=a\"])==False", "assert candidate([\"b==a\",\"a==b\"])==True", "assert candidate([\"a==b\",\"b==c\",\"a==c\"])==True", "assert candidate([\"a==b\",\"b!=c\",\"c==a\"])==False", "assert candidate([\"c==c\",\"b==d\",\"x!=z\"])==True"], "test_function": "def test_run(content1):\n    return SN_SVE(content1).Single_variable()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SVE\", \"def __init__(self, equations)\", \"class SN_SVE(SVE)\", \"super().__init__(equations)\", \"def Single_variable\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/102", "question": "Question: On a broken calculator displaying the number **startValue**, we can perform the following two operations:\n1. Double: Multiply the number on the display by 2; 2. Decrement: Subtract 1 from the number on the display. Given two integers, **startValue** and **target**, return the minimum number of operations required to display the number **target**.\nBased on the above question, please create a class **MOS** in Python, with the attribute **startValue**. Then create another class **SN_MOS**, inheriting from the **MOS** class, and add the attribute **target**, as well as a public function **Minimum_operands** that returns the minimum number of operations required to display the number **target**.", "test_list": ["assert candidate(2,3)==2", "assert candidate(5,8)==2", "assert candidate(3,10)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MOS(content1,content2).Minimum_operands()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MOS\", \"def __init__(self, startValue)\", \"class SN_MOS(MOS)\", \"def __init__(self, startValue, target)\", \"super().__init__(startValue)\", \"def Minimum_operands\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/103", "question": "Question: Given a positive integer array **nums** and an integer **k**, return the number of good sub-arrays in nums. If the number of different integers in a sub-array of nums is exactly **k**, then this continuous, not necessarily different sub-array of **nums** is called a good sub-array;\nBased on the above question, create a class **GAR** in Python language with the attribute **nums**; then create a class **SN_GAR**, inheriting from the **GAR** class, and add the attribute **k**, as well as a public function **Good_array** to return the number of good sub-arrays in **nums**.", "test_list": ["assert candidate([1,2,1,2,3],2)==7", "assert candidate([1,2,1,3,4],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_GAR(content1,content2).Good_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GAR\", \"def __init__(self, nums)\", \"class SN_GAR(GAR)\", \"def __init__(self, nums, k)\", \"super().__init__(nums)\", \"def Good_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/104", "question": "Question: In the given m x n grid **grid**, each cell can have one of the following three values: \n1. Value 0 represents an empty cell.\n2. Value 1 represents a fresh orange.\n3. Value 2 represents a rotten orange. \nEvery minute, a rotten orange will make any fresh orange in the four adjacent directions rot. Return the minimum number of minutes required to make all the oranges rotten. If it is impossible, return -1. \nPlease create a class **MME** in Python based on the above question, with a **grid** attribute. Then create a class **SN_MME** that inherits from the **MME** class and add a public function **Min_Minutes** to return the result of the above question.", "test_list": ["assert candidate([[2,1,1],[1,1,0],[0,1,1]])==4", "assert candidate([[2,1,1],[0,1,1],[1,0,1]])==-1", "assert candidate([[0,2]])==0"], "test_function": "def test_run(content1):\n    return SN_MME(content1).Min_Minutes()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MME\", \"def __init__(self, grid)\", \"class SN_MME(MME)\", \"super().__init__(grid)\", \"def Min_Minutes\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/105", "question": "Question: Given a binary array **nums** and an integer **k**, return the minimum number of k-bit flips required for the array to have no zeros. If it's not possible, return -1. A k-bit flip means choosing a subarray of length **k** from nums, and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0;\nBased on the above question, create a class **MFI** in Python, which has the attribute **nums**. Then create another class **SN_MFI**, inheriting from the **MFI** class, and add the attribute **K**, as well as a public function **Min_Flip** that returns the result of the above problem.", "test_list": ["assert candidate([0,1,0],1)==2", "assert candidate([1,1,0],2)==-1", "assert candidate([0,0,0,1,0,1,1,0],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MFI(content1,content2).Min_Flip()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MFI\", \"def __init__(self, nums)\", \"class SN_MFI(MFI)\", \"def __init__(self, nums, K)\", \"super().__init__(nums)\", \"def Min_Flip\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/106", "question": "Question: Given a non-negative integer array **A**, if the sum of every pair of adjacent elements is a perfect square, then this array is called a square array. Return the number of square arrangements of **A**.\nPlease create a **SAT** class based on the above question, with the attribute **A**; then create a **SN_SAT** class, inheriting the **SAT** class, and add a public **Square_arrangement** function to return the number of square arrangements of A.", "test_list": ["assert candidate([1,17,8])==2", "assert candidate([2,2,2])==1"], "test_function": "def test_run(content1):\n    return SN_SAT(content1).Square_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SAT\", \"def __init__(self, A)\", \"class SN_SAT(SAT)\", \"super().__init__(A)\", \"def Square_arrangement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/107", "question": "Question: There are **n** piles of stones arranged in a row, with stones[i] stones in the i-th pile. Each move requires merging **k** consecutive piles of stones into one pile, and the cost of this move is the total number of stones in these **k** piles. Return the lowest cost to merge all the stones into one pile. If it is impossible to merge into one pile, return -1;\nBased on the above question, create a class **SMG** using Python language, with the attribute **stones**; then create a class **SN_SMG** that inherits the **SMG** class, and add the attribute **K**, as well as a public function **Stone_Merge** that returns the result of the above question.", "test_list": ["assert candidate([3,2,4,1],2)==20", "assert candidate([3,2,4,1],3)==-1", "assert candidate([3,5,1,2,6],3)==25"], "test_function": "def test_run(content1,content2):\n    return SN_SMG(content1,content2).Stone_Merge()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SMG\", \"def __init__(self, stones)\", \"class SN_SMG(SMG)\", \"def __init__(self, stones, K)\", \"super().__init__(stones)\", \"def Stone_Merge\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/108", "question": "Question: In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the i-th domino respectively. (A domino is formed by two numbers from 1 to 6 arranged in columns - each half of the tile has a number.) We can rotate the i-th domino so that the values of tops[i] and bottoms[i] are swapped. Return the minimum number of rotations that can make all values in **tops** or all values in **bottoms** the same. If it is impossible, return -1;\nBased on the above question, please create a class **DMS** in Python with the attribute **tops**; then create another class **SN_DMS** that inherits from the **DMS** class, and add the attribute **bottoms**, as well as a public function **Dominoes** to return the result of the above question.", "test_list": ["assert candidate([2,1,2,4,2,2],[5,2,6,2,3,2])==2", "assert candidate([3,5,1,2,3],[3,6,3,3,4])==-1"], "test_function": "def test_run(content1,content2):\n    return SN_DMS(content1,content2).Dominoes()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DMS\", \"def __init__(self, tops)\", \"class SN_DMS(DMS)\", \"def __init__(self, tops, bottoms)\", \"super().__init__(tops)\", \"def Dominoes\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/109", "question": "Question: In the song list, the duration of the i-th song is time[i] seconds. Return the number of song pairs whose total duration (in seconds) can be divided by 60;\nBased on the above question, please create a class **TDN** in Python, with the attribute **time**; then create another class **SN_TDN**, inheriting from the **TDN** class, and add a public function **Total_duration** to return the number of song pairs whose total duration (in seconds) can be divided by 60.", "test_list": ["assert candidate([30,20,150,100,40])==3", "assert candidate([60,60,60])==3"], "test_function": "def test_run(content1):\n    return SN_TDN(content1).Total_duration()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TDN\", \"def __init__(self, time)\", \"class SN_TDN(TDN)\", \"super().__init__(time)\", \"def Total_duration\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/110", "question": "Question: The packages on the **conveyor belt** must be transported from one port to another within **days**. The weight of the i-th package on the conveyor belt is weights[i]. Every day, we load packages onto the conveyor belt in the order of the given weights. The weight we load will not exceed the maximum carrying weight of the ship. Return the minimum carrying capacity of the ship that can deliver all the packages on the conveyor belt within **days**;\nBased on the above question, please use Python to create a class **MCG** with the attribute **weights**; then create a class **SN_MCG** that inherits from the **MCG** class, and add the attribute **days**, as well as a public function **Minimum_carrying** to return the minimum carrying capacity of the ship that can deliver all the packages on the conveyor belt within **days**.", "test_list": ["assert candidate([1,2,3,4,5,6,7,8,9,10],5)==15", "assert candidate([3,2,2,4,1,4],3)==6", "assert candidate([1,2,3,1,1],4)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MCG(content1,content2).Minimum_carrying()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MCG\", \"def __init__(self, weights)\", \"class SN_MCG(MCG)\", \"def __init__(self, weights, days)\", \"super().__init__(weights)\", \"def Minimum_carrying\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/111", "question": "Question: Given a positive integer **n**, return the number of positive integers within the range [1, n] that have at least one repeating digit;\nBased on the above question, please create a class called **RNS** in Python, with an attribute **n**. Then create another class **SN_RNS** that inherits from the **RNS** class, and add a public function **Repeating_numbers** that returns the result of the above question.", "test_list": ["assert candidate(20)==1", "assert candidate(100)==10", "assert candidate(1000)==262"], "test_function": "def test_run(content1):\n    return SN_RNS(content1).Repeating_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RNS\", \"def __init__(self, n)\", \"class SN_RNS(RNS)\", \"super().__init__(n)\", \"def Repeating_numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/112", "question": "Question: Given a positive integer array **values**, where values[i] represents the rating of the i-th sightseeing spot, and the distance between two spots i and j is j-i. The score of a sightseeing combination of a pair of spots (i<j) is values[i]+values[j]+i-j, which is the sum of the ratings of the spots minus the distance between them. Return the highest score that a pair of sightseeing spots can achieve;\nBased on the above question, please create a class **SCT** in Python language with the attribute **values**; then create a class **SN_SCT** that inherits the **SCT** class, and add a public function **Sightseeing_combination** that returns the highest score that a pair of sightseeing spots can achieve.", "test_list": ["assert candidate([8,1,5,2,6])==11", "assert candidate([1,2])==2"], "test_function": "def test_run(content1):\n    return SN_SCT(content1).Sightseeing_combination()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SCT\", \"def __init__(self, values)\", \"class SN_SCT(SCT)\", \"super().__init__(values)\", \"def Sightseeing_combination\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/113", "question": "Question: Given a positive integer **k**, you need to find the length of the smallest positive integer **n** that can be divided by **k** and only contains the digit 1. Return the length of **n**. If there is no such **n**, return -1;\nBased on the above question, please create a class **MIR** in Python with the attribute **k**; then create a class **SN_MIR** that inherits the **MIR** class, and add a public function **Minimum_integer** to return the result of the above question.", "test_list": ["assert candidate(1)==1", "assert candidate(2)==-1", "assert candidate(3)==3"], "test_function": "def test_run(content1):\n    return SN_MIR(content1).Minimum_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MIR\", \"def __init__(self, k)\", \"class SN_MIR(MIR)\", \"super().__init__(k)\", \"def Minimum_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/114", "question": "Question: Given a binary string **s** and a positive integer **n**, return True if the binary representation of every integer in the range [1, n] is a substring of **s**, otherwise return False;\nPlease create a class **ETG** in Python language based on the above question, with the attribute **s**. Then create a class **SN_ETG** that inherits from the **ETG** class, add the attribute **n**, and a public function **Each_integer** that returns the result of the above question.", "test_list": ["assert candidate(\"0110\",3)==True", "assert candidate(\"0110\",4)==False"], "test_function": "def test_run(content1,content2):\n    return SN_ETG(content1,content2).Each_integer()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ETG\", \"def __init__(self, s)\", \"class SN_ETG(ETG)\", \"def __init__(self, s, n)\", \"super().__init__(s)\", \"def Each_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/115", "question": "Question: Given an integer **n**, return its negative binary (base-2) representation in the form of a binary string;\nBased on the above question, create a class **NGY** in Python language with the attribute **n**; then create a class **SN_NGY** that inherits from the **NGY** class, and add a public function **negabinary** to return the negative binary (base-2) representation of the integer **n** in the form of a binary string.", "test_list": ["assert candidate(2)==\"110\"", "assert candidate(3)==\"111\"", "assert candidate(4)==\"100\""], "test_function": "def test_run(content1):\n    return SN_NGY(content1).negabinary()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NGY\", \"def __init__(self, n)\", \"class SN_NGY(NGY)\", \"super().__init__(n)\", \"def negabinary\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/116", "question": "Question: Given a linked list of length **n**, **head**. For each node in the list, find the value of the next larger node. That is, for each node, find the value of the first node next to it, the value of this node is strictly greater than its value. Return an integer array **answer**, where answer[i] is the value of the next larger node of the i-th node (starting from 1). If the i-th node does not have a next larger node, set answer[i]=0;\nBased on the above question, please create a class **LNS** in Python, with the attribute **head**; then create a class **SN_LNS** that inherits the **LNS** class, and add a public function **Larger_nodes** to return the result of the above question.", "test_list": ["assert candidate([2,1,5])==[5,5,0]", "assert candidate([2,7,4,3,5])==[7,0,5,5,0]"], "test_function": "def test_run(content1):\n    return SN_LNS(content1).Larger_nodes()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LNS\", \"def __init__(self, head)\", \"class SN_LNS(LNS)\", \"super().__init__(head)\", \"def Larger_nodes\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/117", "question": "Question: Given a binary matrix grid of size m x n, where 0 represents an ocean cell and 1 represents a land cell. A move is defined as moving from one land cell to another adjacent (up, down, left, right) land cell or crossing the border of the **grid**. Return the number of land cells in the grid that cannot leave the grid border in any number of moves;\nPlease create a class **LCL** in Python based on the above question, with the attribute **grid**. Then create a class **SN_LCL** that inherits from the **LCL** class, and add a public function **Land_Cell** to return the number of land cells in the grid that cannot leave the grid border in any number of moves.", "test_list": ["assert candidate([[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]])==3", "assert candidate([[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]])==0"], "test_function": "def test_run(content1):\n    return SN_LCL(content1).Land_Cell()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LCL\", \"def __init__(self, grid)\", \"class SN_LCL(LCL)\", \"super().__init__(grid)\", \"def Land_Cell\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/118", "question": "Question: Given a string array **queries** and a string representing a **pattern**, return a boolean array **answer**. Only when the query item queries[i] matches the pattern string pattern, answer[i] is True, otherwise it is False;\nBased on the above question, please create a class **BAY** in Python with the property **queries**; then create a class **SN_BAY** that inherits from the **BAY** class, and add the property **pattern**, as well as a public function **boolean_array** that returns the above results.", "test_list": ["assert candidate([\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"],\"FB\")==[True,False,True,True,False]", "assert candidate([\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"],\"FoBa\")==[True,False,True,False,False]", "assert candidate([\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"],\"FoBaT\")==[False,True,False,False,False]"], "test_function": "def test_run(content1,content2):\n    return SN_BAY(content1,content2).boolean_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BAY\", \"def __init__(self, queries)\", \"class SN_BAY(BAY)\", \"def __init__(self, queries, pattern)\", \"super().__init__(queries)\", \"def boolean_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/119", "question": "Question: Given an integer array **nums**, return the length of the longest arithmetic subsequence in **nums**;\nBased on the above question, create a class **LSQ** using Python language, with the attribute **nums**. Then create another class **SN_LSQ**, inheriting from the **LSQ** class, and add a public function **Longest_subsequence** to return the length of the longest arithmetic subsequence in the integer array **nums**.", "test_list": ["assert candidate([3,6,9,12])==4", "assert candidate([9,4,7,2,10])==3", "assert candidate([20,1,15,3,10,5,8])==4"], "test_function": "def test_run(content1):\n    return SN_LSQ(content1).Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LSQ\", \"def __init__(self, nums)\", \"class SN_LSQ(LSQ)\", \"super().__init__(nums)\", \"def Longest_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/120", "question": "Question: The company plans to interview 2n people. Given an array **costs**, where costs[i]=[aCosti,bCosti]. The cost for the i-th person to fly to city **a** is **aCost_i**, and the cost to fly to city **b** is **bCost_i**. Return the minimum cost to fly each person to either city **a** or **b**, with the requirement that **n** people must arrive in each city;\nBased on the above question, create a class **MCT** in Python language with the attribute **costs**; then create a class **SN_MCT** that inherits from the **MCT** class, and add a public function **Minimum_cost** to return the result of the above question.", "test_list": ["assert candidate([[10,20],[30,200],[400,50],[30,20]])==110", "assert candidate([[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]])==1859", "assert candidate([[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]])==3086"], "test_function": "def test_run(content1):\n    return SN_MCT(content1).Minimum_cost()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MCT\", \"def __init__(self, costs)\", \"class SN_MCT(MCT)\", \"super().__init__(costs)\", \"def Minimum_cost\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/121", "question": "Question: Given an integer array **nums** and two integers **firstLen** and **secondLen**, you are to find and return the maximum sum of elements in two non-overlapping subarrays, with lengths respectively as **firstLen** and **secondLen**;\nBased on the above question, create a class **OSR** in Python with the attribute **nums**; then create another class **SN_OSR** that inherits from the **OSR** class, and add two attributes **firstLen** and **secondLen**, as well as a public function **overlapping_subarray** that returns the result of the above question.", "test_list": ["assert candidate([0,6,5,2,2,5,1,9,4],1,2)==20", "assert candidate([3,8,1,3,2,1,8,9,0],3,2)==29", "assert candidate([2,1,5,6,0,9,5,0,3,8],4,3)==31"], "test_function": "def test_run(content1,content2,content3):\n    return SN_OSR(content1,content2,content3).overlapping_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class OSR\", \"def __init__(self, nums)\", \"class SN_OSR(OSR)\", \"def __init__(self, nums, firstLen, secondLen)\", \"super().__init__(nums)\", \"def overlapping_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/122", "question": "Question: Three stones are placed on the number line at positions **a**, **b**, and **c**. In each round, you can pick up a stone from one of the ends (either the largest or smallest position) and place it in any free position between the two ends. Formally, suppose the three stones are currently at positions **x**, **y**, and **z** with x<y<z. Then you can pick up a stone from position **x** or **z** and move it to an integer position **k**, where x<k<z and k!=y. The game ends when you can't make any more moves, i.e., when the positions of the stones are consecutive. What are the minimum and maximum number of moves you can make to end the game? Return the answer in the form of a 2-length array: answer=[minimum_moves,maximum_moves];\nBased on the above question, please create a class **SMT** in Python with an attribute **a**; then create a class **SN_SMT** that inherits from the **SMT** class, and add two attributes **b** and **c**, as well as a public function **Stone_movement** that returns the result of the above question.", "test_list": ["assert candidate(1,2,5)==[1, 2]", "assert candidate(4,3,2)==[0, 0]"], "test_function": "def test_run(content1,content2,content3):\n    return SN_SMT(content1,content2,content3).Stone_movement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SMT\", \"def __init__(self, a)\", \"class SN_SMT(SMT)\", \"def __init__(self, a, b, c)\", \"super().__init__(a)\", \"def Stone_movement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/123", "question": "Question: Write down the integers in **nums1** and **nums2** in the given order on two independent horizontal lines. Now, some lines can be drawn connecting the two numbers nums1[i] and nums2[j]. These lines need to satisfy the following conditions:\n1. nums1[i] == nums2[j]; \n2. The drawn line does not intersect with any other lines (non-horizontal lines). Please note that the lines cannot intersect even at the endpoints: each number can only belong to one line. Draw lines in this way and return the maximum number of lines that can be drawn.\nPlease create a class called **MCT** in Python, which has the attribute **nums1**. Then create another class called **SN_MCT** that inherits from the **MCT** class, and add the attribute **nums2**, as well as a public function **max_connections** that returns the maximum number of lines that can be drawn.", "test_list": ["assert candidate([1,4,2],[1,2,4])==2", "assert candidate([2,5,1,2,5],[10,5,2,1,5,2])==3", "assert candidate([1,3,7,1,7,5],[1,9,2,5,1])==2"], "test_function": "def test_run(content1,content2):\n    return SN_MCT(content1,content2).max_connections()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MCT\", \"def __init__(self, nums1)\", \"class SN_MCT(MCT)\", \"def __init__(self, nums1, nums2)\", \"super().__init__(nums1)\", \"def max_connections\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/124", "question": "Question: In a 10^6x10^6 grid, the coordinates of each cell are (x,y). Now, starting from the source cell source=[sx,sy], the intention is to rush to the target cell target=[tx,ty]. The array blocked is a list of blocked cells, where each blocked[i]=[xi,yi] indicates that the cell with coordinates (xi,yi) is forbidden to pass. Each move can go to the cell adjacent in the four directions in the grid, as long as the cell is not on the given **blocked** list. Also, it is not allowed to go out of the grid. Only when it is possible to reach the target cell target from the source cell source through a series of moves, return True. Otherwise, return False;\nBased on the above question, please create a class **SGD** in Python language with the attribute **blocked**; then create a class **SN_SGD**, inherit the **SGD** class, and add two attributes **source** and **target**, and a public function **Source_grid** to return the result of the above question.", "test_list": ["assert candidate([[0,1],[1,0]],[0,0],[0,2])==False", "assert candidate([],[0,0],[999999,999999])==True"], "test_function": "def test_run(content1,content2,content3):\n    return SN_SGD(content1,content2,content3).Source_grid()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SGD\", \"def __init__(self, blocked)\", \"class SN_SGD(SGD)\", \"def __init__(self, blocked, source, target)\", \"super().__init__(blocked)\", \"def Source_grid\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/125", "question": "Question: You have a convex n-polygon, each vertex of which has an integer value. Given an integer array **values**, where values[i] is the value of the i-th vertex (i.e., in clockwise order). Assume the polygon is divided into n-2 triangles. For each triangle, the value of the triangle is the product of the vertex labels, and the score of the triangulation is the sum of the values of all n-2 triangles after the triangulation. Return the lowest score that can be obtained after the polygon is triangulated;\nBased on the above question, please create a class **TGT** in Python, with the attribute **values**; then create a class **SN_TGT** that inherits from the **TGT** class, and add a public function **triangulation** that returns the lowest score that can be obtained after the polygon is triangulated.", "test_list": ["assert candidate([1,2,3])==6", "assert candidate([3,7,4,5])==144", "assert candidate([1,3,1,4,1,5])==13"], "test_function": "def test_run(content1):\n    return SN_TGT(content1).triangulation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TGT\", \"def __init__(self, values)\", \"class SN_TGT(TGT)\", \"super().__init__(values)\", \"def triangulation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/126", "question": "Question: On an infinite plane, the robot initially stands at the point (0,0), facing north. Note:\n1. North is the positive direction of the y-axis. 2. South is the negative direction of the y-axis. 3. East is the positive direction of the x-axis. 4. West is the negative direction of the x-axis. The robot can accept one of the following three instructions:\n1. **G**: Go straight for 1 unit. 2. **L**: Turn left by 90 degrees. 3. **R**: Turn right by 90 degrees. The robot executes the **instructions** in order and repeats them indefinitely. Only when there is a loop in the plane that the robot can never leave, return True. Otherwise, return False;\nPlease create a class **EIT** in Python based on the above problem, with the property **instructions**; Then create a class **SN_EIT**, inheriting from the **EIT** class, and add a public function **Execute_instructions** to return the result of the above problem.", "test_list": ["assert candidate(\"GGLLGG\")==True", "assert candidate(\"GG\")==False", "assert candidate(\"GL\")==True"], "test_function": "def test_run(content1):\n    return SN_EIT(content1).Execute_instructions()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EIT\", \"def __init__(self, instructions)\", \"class SN_EIT(EIT)\", \"super().__init__(instructions)\", \"def Execute_instructions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/127", "question": "Question: There are **n** gardens, labeled from 1 to **n**. There is also an array **paths**, where paths[i] = [x_i, y_i] describes the bidirectional path from garden **x_i** to garden **y_i**. In each garden, you plan to plant one of four types of flowers. Moreover, each garden can have at most three paths leading in or out. You need to choose a type of flower for each garden so that the types of flowers in any two gardens connected by a path are different. Return any feasible solution as the answer **answer** in the form of an array, where answer[i] represents the type of flower planted in the (i+1)th garden. The types of flowers are represented by 1, 2, 3, and 4;\nBased on the above question, create a class **PFS** in Python with the attribute **n**; then create a class **SN_PFS** that inherits from the **PFS** class, and add the attribute **paths**, as well as a public function **Planted_flowers** that returns the result of the above question.", "test_list": ["assert candidate(3,[[1,2],[2,3],[3,1]])==[1,2,3]", "assert candidate(4,[[1,2],[3,4]])==[1,2,1,2]", "assert candidate(4,[[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]])==[1,2,3,4]"], "test_function": "def test_run(content1,content2):\n    return SN_PFS(content1,content2).Planted_flowers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PFS\", \"def __init__(self, n)\", \"class SN_PFS(PFS)\", \"def __init__(self, n, paths)\", \"super().__init__(n)\", \"def Planted_flowers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/128", "question": "Question: Given an integer array **arr**, please divide this array into some (continuous) sub-arrays with a maximum length of **k**. After the division, all values in each sub-array will become the maximum value in that sub-array. Return the maximum sum of elements that can be obtained after the array is divided and transformed;\nBased on the above question, create a class **STF** in Python language with the attribute **arr**; then create a class **SN_STF** that inherits the **STF** class, and add the attribute **k**, as well as a public function **Separation_transformation** that returns the maximum sum of elements that can be obtained after the array is divided and transformed.", "test_list": ["assert candidate([1,15,7,9,2,5,10],3)==84", "assert candidate([1,4,1,5,7,3,6,1,9,9,3],4)==83", "assert candidate([1],1)==4"], "test_function": "def test_run(content1,content2):\n    return SN_STF(content1,content2).Separation_transformation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STF\", \"def __init__(self, arr)\", \"class SN_STF(STF)\", \"def __init__(self, arr, k)\", \"super().__init__(arr)\", \"def Separation_transformation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/129", "question": "Question: Given a string **s**, consider all its repeated substrings: that is, the (continuous) substrings of **s** that appear 2 or more times in **s**. These appearances may overlap. Return any one of the possible longest repeated substrings. If **s** does not contain repeated substrings, then the answer is \"\";\nPlease create a class **RST** in Python language based on the above question, with the attribute **s**; then create another class **SN_RST** that inherits from the **RST** class, and add a public function **Repeated_substring** that returns the possible longest repeated substring.", "test_list": ["assert candidate(\"banana\")==\"ana\"", "assert candidate(\"abcd\")==\"\""], "test_function": "def test_run(content1):\n    return SN_RST(content1).Repeated_substring()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RST\", \"def __init__(self, s)\", \"class SN_RST(RST)\", \"super().__init__(s)\", \"def Repeated_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/130", "question": "Question: Given a word array **words**, each word is composed of lowercase English letters. If we can add exactly one letter anywhere in **wordA** without changing the order of other characters to make it become **wordB**, then we consider **wordA** to be the predecessor of **wordB**. For example, **abc** is the predecessor of **abac**, while **cba** is not the predecessor of **bcad**. A word chain is a sequence composed of words [word_1, word_2, ..., word_k], k>=1, where **word1** is the predecessor of **word2**, **word2** is the predecessor of **word3**, and so on. A word is usually a word chain where k==1. Choose words from the given word list **words** to form a word chain, and return the longest possible length of the word chain;\nBased on the above question, please create a class **FCA** in Python with the attribute **words**; then create another class **SN_FCA** that inherits from the **FCA** class, and add a public function **Form_chain** that returns the longest possible length of the word chain.", "test_list": ["assert candidate([\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"])==4", "assert candidate([\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"])==5", "assert candidate([\"abcd\",\"dbqca\"])==1"], "test_function": "def test_run(content1):\n    return SN_FCA(content1).Form_chain()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FCA\", \"def __init__(self, words)\", \"class SN_FCA(FCA)\", \"super().__init__(words)\", \"def Form_chain\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/131", "question": "Question: There is a pile of stones, represented by an integer array **stones**. Where stones[i] represents the weight of the i-th stone. Each round, select any two stones from it and crush them together. Suppose the weights of the stones are **x** and **y**, and x <= y. Then the possible results of crushing are as follows:\n1. If x == y, then both stones will be completely crushed; 2. If x != y, then the stone with weight **x** will be completely crushed, and the new weight of the stone with weight **y** is y-x. In the end, at most one stone will be left. Return the minimum possible weight of this stone. If no stones are left, return 0;\nBased on the above question, please create a class **MWG** in Python, with the property **stones**; then create a class **SN_MWG** that inherits from the **MWG** class, and add a public function **Minimum_weight** to return the result of the above question.", "test_list": ["assert candidate([2,7,4,1,8,1])==1", "assert candidate([31,26,33,21,40])==5"], "test_function": "def test_run(content1):\n    return SN_MWG(content1).Minimum_weight()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MWG\", \"def __init__(self, stones)\", \"class SN_MWG(MWG)\", \"super().__init__(stones)\", \"def Minimum_weight\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/132", "question": "Question: Given a positive integer array **arr** (which may contain duplicate elements), please return the maximum arrangement that is lexicographically smaller than **arr** and can be obtained by one swap (swapping the positions of two numbers arr[i] and arr[j]). If such operation is not possible, please return the original array;\nBased on the above question, create a class **OEH** in Python with the attribute **arr**. Then create another class **SN_OEH** that inherits from the **OEH** class, and add a public function **One_exchange** that returns the result of the above question.", "test_list": ["assert candidate([3,2,1])==[3,1,2]", "assert candidate([1,1,5])==[1,1,5]", "assert candidate([1,9,4,6,7])==[1,7,4,6,9]"], "test_function": "def test_run(content1):\n    return SN_OEH(content1).One_exchange()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class OEH\", \"def __init__(self, arr)\", \"class SN_OEH(OEH)\", \"super().__init__(arr)\", \"def One_exchange\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/133", "question": "Question: In a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i]. Please rearrange these barcodes so that no two adjacent barcodes are the same. You can return any answer that meets this requirement, and it is guaranteed that an answer exists;\nPlease create a class **ABD** in Python based on the above question, with the property **barcodes**; then create a class **SN_ABD** that inherits from the **ABD** class, and add a public function **Adjacent_barcodes** that returns the result of the above question.", "test_list": ["assert candidate([1,1,1,2,2,2])==[2,1,2,1,2,1]", "assert candidate([1,1,1,1,2,2,3,3])==[1,3,1,3,2,1,2,1]"], "test_function": "def test_run(content1):\n    return SN_ABD(content1).Adjacent_barcodes()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ABD\", \"def __init__(self, barcodes)\", \"class SN_ABD(ABD)\", \"super().__init__(barcodes)\", \"def Adjacent_barcodes\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/134", "question": "Question: Given two strings of equal length, **s1** and **s2**, and another string, baseStr, where s1[i] and s2[i] are a pair of equivalent characters. For example, if s1 = **abc** and s2 = **cde**, then 'a' == 'c', 'b' == 'd', and 'c' == 'e'. Equivalent characters follow the general rules of any equivalence relation:\n1. Reflexivity: 'a' == 'a'; 2. Symmetry: if 'a' == 'b', then 'b' == 'a'; 3. Transitivity: if 'a' == 'b' and 'b' == 'c', then 'a' == 'c'. Using the equivalence information of **s1** and **s2**, find and return the lexicographically smallest equivalent string of baseStr;\nBased on the above question, please create a class **EST** in Python, with the attribute **s1**; then create another class **SN_EST**, inheriting from the **EST** class, and add two attributes **s2** and **baseStr**, as well as a public function **Equivalent_String** that returns the lexicographically smallest equivalent string of **baseStr**.", "test_list": ["assert candidate(\"parker\",\"morris\",\"parser\")==\"makkek\"", "assert candidate(\"hello\",\"world\",\"hold\")==\"hdld\"", "assert candidate(\"leetcode\",\"programs\",\"sourcecode\")==\"aauaaaaada\""], "test_function": "def test_run(content1,content2,content3):\n    return SN_EST(content1,content2,content3).Equivalent_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class EST\", \"def __init__(self, s1)\", \"class SN_EST(EST)\", \"def __init__(self, s1, s2, baseStr)\", \"super().__init__(s1)\", \"def Equivalent_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/135", "question": "Question: Given an m x n matrix **matrix**, you can select any number of columns from it and flip each cell on it. (That is, after flipping, the value of the cell changes from 0 to 1, or from 1 to 0.) Return the maximum number of rows where all values in the row are equal after some flips;\nPlease create a class **MRW** with the property **matrix** in Python based on the above question; then create a class **SN_MRW** that inherits the **MRW** class, and add a public function **Maximum_rows** to return the result of the above question.", "test_list": ["assert candidate([[0,1],[1,1]])==1", "assert candidate([[0,1],[1,0]])==2", "assert candidate([[0,0,0],[0,0,1],[1,1,0]])==2"], "test_function": "def test_run(content1):\n    return SN_MRW(content1).Maximum_rows()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MRW\", \"def __init__(self, matrix)\", \"class SN_MRW(MRW)\", \"super().__init__(matrix)\", \"def Maximum_rows\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/136", "question": "Question: Given two numbers **arr1** and **arr2** in base -2, return the result of their addition;\nPlease create a class named **ANS** in Python based on the above question, with the attribute **arr1**. Then create another class named **SN_ANS**, which inherits from the **ANS** class, and adds the attribute **arr2**, as well as a public function **Adding_Numbers** to return the result of adding the two numbers.", "test_list": ["assert candidate([1,1,1,1,1],[1,0,1])==[1,0,0,0,0]", "assert candidate([0],[0])==[0]", "assert candidate([0],[1])==[1]"], "test_function": "def test_run(content1,content2):\n    return SN_ANS(content1,content2).Adding_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ANS\", \"def __init__(self, arr1)\", \"class SN_ANS(ANS)\", \"def __init__(self, arr1, arr2)\", \"super().__init__(arr1)\", \"def Adding_Numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/137", "question": "Question: Given a **matrix** and a **target** value, return the number of non-empty submatrices whose sum of elements equals the target value;\nPlease create a class **ESI** in Python language based on the above question, with the attribute **matrix**; then create another class **SN_ESI**, inheriting from the **ESI** class, and add the attribute **target**, as well as a public function **empty_submatrix** to return the number of non-empty submatrices whose sum of elements equals the **target** value.", "test_list": ["assert candidate([[0,1,0],[1,1,1],[0,1,0]],0)==4", "assert candidate([[1,-1],[-1,1]],0)==5", "assert candidate([[904]],0)==0"], "test_function": "def test_run(content1,content2):\n    return SN_ESI(content1,content2).empty_submatrix()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ESI\", \"def __init__(self, matrix)\", \"class SN_ESI(ESI)\", \"def __init__(self, matrix, target)\", \"super().__init__(matrix)\", \"def empty_submatrix\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/138", "question": "Question: You have a set of movable type **tiles**, each of which is engraved with a letter tiles[i]. Return the number of non-empty letter sequences you can print;\nPlease create a class **LSQ** based on the above question, with the attribute **tiles** using Python language; then create another class **SN_LSQ**, inheriting from the **LSQ** class, and add a public function **letter_sequence** that returns the number of non-empty letter sequences that can be printed.", "test_list": ["assert candidate(\"AAB\")==8", "assert candidate(\"AAABBC\")==188", "assert candidate(\"V\")==1"], "test_function": "def test_run(content1):\n    return SN_LSQ(content1).letter_sequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LSQ\", \"def __init__(self, tiles)\", \"class SN_LSQ(LSQ)\", \"super().__init__(tiles)\", \"def letter_sequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/139", "question": "Question: Return the subsequence of **s** with the smallest lexicographical order, which contains all distinct characters of **s** and only contains them once;\nBased on the above question, create a class **SSU** in Python language with the attribute **s**. Then create another class **SN_SSU**, which inherits from the **SSU** class, and add a public function **smallest_subsequence** to return the result of the above question.", "test_list": ["assert candidate(\"bcabc\")==\"abc\"", "assert candidate(\"cbacdcbc\")==\"acdb\""], "test_function": "def test_run(content1):\n    return SN_SSU(content1).smallest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSU\", \"def __init__(self, s)\", \"class SN_SSU(SSU)\", \"super().__init__(s)\", \"def smallest_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/140", "question": "Question: We have a set of **n** items. Two integer arrays, **values** and **labels**, are given, where the value and label of the i-th element are values[i] and labels[i] respectively. Two more integers, **numWanted** and **useLimit**, are also given. We are to select a subset **s** from the **n** elements such that:\n1. The size of subset **s** is less than or equal to numWanted. 2. There are at most useLimit items with the same label in **s**. The score of a subset is the sum of the values of the subset. The task is to return the maximum score of subset **s**;\nBased on the above question, please create a class named **MSR** in Python, which has the attribute **values**. Then create another class **SN_MSR**, which inherits from the **MSR** class, and adds three attributes: **labels**, **numWanted**, and **useLimit**, as well as a public function **Maximum_score** that returns the maximum score of subset **s**.", "test_list": ["assert candidate([5,4,3,2,1],[1,1,2,2,3],3,1)==9", "assert candidate([5,4,3,2,1],[1,3,3,3,2],3,2)==12", "assert candidate([9,8,8,7,6],[0,0,0,1,1],3,1)==16"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_MSR(content1,content2,content3,content4).Maximum_score()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MSR\", \"def __init__(self, values)\", \"class SN_MSR(MSR)\", \"def __init__(self, values, labels, numWanted, useLimit)\", \"super().__init__(values)\", \"def Maximum_score\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/141", "question": "Question: Given an n x n binary matrix **grid**, return the length of the shortest unobstructed path in the matrix. If such a path does not exist, return -1;\nBased on the above question, please create a **UPT** class in Python with a **grid** attribute; then create a **SN_UPT** class that inherits the **UPT** class, and add a public **Unobstructed_path** function to return the result of the above question.", "test_list": ["assert candidate([[0,1],[1,0]])==2", "assert candidate([[0,0,0],[1,1,0],[1,1,0]])==4", "assert candidate([[1,0,0],[1,1,0],[1,1,0]])==-1"], "test_function": "def test_run(content1):\n    return SN_UPT(content1).Unobstructed_path()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class UPT\", \"def __init__(self, grid)\", \"class SN_UPT(UPT)\", \"super().__init__(grid)\", \"def Unobstructed_path\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/142", "question": "Question: Given two strings **str1** and **str2**, return the shortest string that has both **str1** and **str2** as subsequences;\nPlease create a class **SSI** in Python, which has the attribute **str1**. Then create another class **SN_SSI** that inherits from the **SSI** class, and add the attribute **str2**, as well as a public function **Shortest_string** to return the shortest string that has both **str1** and **str2** as subsequences.", "test_list": ["assert candidate(\"abac\",\"cab\")==\"cabac\"", "assert candidate(\"aaaaaaaa\",\"aaaaaaaa\")==\"aaaaaaaa\""], "test_function": "def test_run(content1,content2):\n    return SN_SSI(content1,content2).Shortest_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSI\", \"def __init__(self, str1)\", \"class SN_SSI(SSI)\", \"def __init__(self, str1, str2)\", \"super().__init__(str1)\", \"def Shortest_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/143", "question": "Question: Initially, there are **capacity** empty seats on the bus. The bus can only travel in one direction (that is, it is not allowed to turn around or change direction). Given the integer **capacity** and an array **trips**, trip[i] = [numPassengers_i, from_i, to_i] indicates that there are **numPassengers_i** passengers in the i-th trip, and their pick-up and drop-off locations are **from_i** and **to_i** respectively. These locations are the kilometers from the initial position of the car to the east. Return True only and only when you can pick up and drop off all passengers in all given trips, otherwise please return False;\nBased on the above question, please create a class **PPG** using Python language, with the attribute **trips**; then create a class **SN_PPG** that inherits the **PPG** class, and add the attribute **capacity**, and a public function **Pick_passengers** that returns the result of the above question.", "test_list": ["assert candidate([[2,1,5],[3,3,7]],4)==False", "assert candidate([[2,1,5],[3,3,7]],5)==True"], "test_function": "def test_run(content1,content2):\n    return SN_PPG(content1,content2).Pick_passengers()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PPG\", \"def __init__(self, trips)\", \"class SN_PPG(PPG)\", \"def __init__(self, trips, capacity)\", \"super().__init__(trips)\", \"def Pick_passengers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/144", "question": "Question: Given a mountain array **mountainArr**, please return the smallest index **index** that makes mountainArr.get(index) equal to **target**. If there is no such index **index**, please return -1. What is a mountain array? If array **A** is a mountain array, then it satisfies the following conditions:\n1. A.length>=3; 2. Under the condition of 0<i<A.length-1, there exists i such that: A[0]<A[1]<...A[i-1]<A[i]; A[i]>A[i+1]>...>A[A.length-1];\nBased on the above question, please use Python language to create a class **MAR** with the property **array**; then create a class **SN_MAR** that inherits the **MAR** class, and add the property **target**, as well as a public function **Mountain_array** that returns the result of the above question.", "test_list": ["assert candidate([1,2,3,4,5,3,1],3)==2", "assert candidate([0,1,2,4,2,1],3)==-1"], "test_function": "def test_run(content1,content2):\n    return SN_MAR(content1,content2).Mountain_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MAR\", \"def __init__(self, array)\", \"class SN_MAR(MAR)\", \"def __init__(self, array, target)\", \"super().__init__(array)\", \"def Mountain_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/145", "question": "Question: Given a boolean expression **expression** in string form, return the result of the operation. A boolean expression is an expression whose result is either True or False. Valid expressions must follow the following conventions:\n1. 't', the operation result is True; 2. 'f', the operation result is False; 3. '!(subExpr)', the operation process is to perform logical NOT operation on the internal expression subExpr; 4. '&(subExpr1,subExpr2,...,subExprn)', the operation process is to perform logical AND operation on two or more internal expressions subExpr1, subExpr2,...,subExprn; 5. '|(subExpr1,subExpr2,...,subExprn)', the operation process is to perform logical OR operation on two or more internal expressions subExpr1, subExpr2,...,subExprn;\nBased on the above question, please create a class **BLS** in Python with the attribute **expression**. Then create another class **SN_BLS** that inherits from the **BLS** class, and add a public function **Booleans** to return the result of the above question.", "test_list": ["assert candidate(\"&(|(f))\")==False", "assert candidate(\"|(f,f,f,t)\")==True", "assert candidate(\"!(&(f,t))\")==True"], "test_function": "def test_run(content1):\n    return SN_BLS(content1).Booleans()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BLS\", \"def __init__(self, expression)\", \"class SN_BLS(BLS)\", \"super().__init__(expression)\", \"def Booleans\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/146", "question": "Question: Here we have **n** flights, numbered from 1 to **n**. There is a flight booking sheet **bookings**. The i-th booking record in the sheet, bookings[i]=[firsti,lasti,seatsi], means that **seatsi** seats have been booked on each flight from **firsti** to **lasti** (including **firsti** and **lasti**). Please return an array **answer** of length **n**, where each element is the total number of seats booked for each flight;\nBased on the above question, please create a class **RSA** in Python language with the attribute **bookings**; then create a class **SN_RSA** that inherits from the **RSA** class, and add the attribute **n**, as well as a public function **Reserved_seats** that returns the result of the above question.", "test_list": ["assert candidate([[1,2,10],[2,3,20],[2,5,25]],5)==[10,55,45,25,25]", "assert candidate([[1,2,10],[2,2,15]],2)==[10,25]"], "test_function": "def test_run(content1,content2):\n    return SN_RSA(content1,content2).Reserved_seats()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RSA\", \"def __init__(self, bookings)\", \"class SN_RSA(RSA)\", \"def __init__(self, bookings, n)\", \"super().__init__(expression)\", \"def Reserved_seats\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/147", "question": "Question: Given a work schedule **hours**, which records the daily working hours of an employee. We consider that if the working hours of an employee in a day exceed 8 hours, then this day is a tiring day. The so-called good performance period means that during this period, the number of tiring days is strictly greater than the number of non-tiring days. Please return the maximum length of the good performance period;\nPlease create a **PWL** class in Python based on the above question, with the attribute **hours**; then create a **SN_PWL** class that inherits the **PWL** class, and add a public **Performing_well** function to return the maximum length of the good performance period.", "test_list": ["assert candidate([9,9,6,0,6,6,9])==3", "assert candidate([6,6,6])==0"], "test_function": "def test_run(content1):\n    return SN_PWL(content1).Performing_well()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PWL\", \"def __init__(self, hours)\", \"class SN_PWL(PWL)\", \"super().__init__(hours)\", \"def Performing_well\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/148", "question": "Question: As a project manager, you have planned a list of required skills **req_skills**, and intend to select some people from the list of alternative personnel **people** to form a **necessary team** (the alternative personnel numbered **i**, people[i], has a list of skills that this alternative personnel masters). The so-called necessary team is a team in which, for each skill listed in the required skill list **req_skills**, at least one member of the team has already mastered it. The team members can be represented by the numbers of each person: please return any necessary team of the smallest scale, with the team members represented by the personnel numbers. You can return the answer in any order, and the question data guarantees that the answer exists;\nPlease create a class **NTM** in Python based on the above question, with the attribute **req_skills**; then create a class **SN_NTM** that inherits the **NTM** class, and add the attribute **people**, as well as a public function **Necessary_team** that returns the result of the above question.", "test_list": ["assert candidate([\"java\",\"nodejs\",\"reactjs\"],[[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]])==[0,2]", "assert candidate([\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"],[[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]])==[1,2]"], "test_function": "def test_run(content1,content2):\n    return SN_NTM(content1,content2).Necessary_team()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NTM\", \"def __init__(self, req_skills)\", \"class SN_NTM(NTM)\", \"def __init__(self, req_skills, people)\", \"super().__init__(req_skills)\", \"def Necessary_team\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/149", "question": "Question: Given an integer **n**, which is the number of nodes in a directed graph, where the nodes are labeled from 0 to n-1. Each edge in the graph is either red or blue, and there may be self-loops or parallel edges. Given two arrays **redEdges** and **blueEdges**, where:\n1. redEdges[i]=[a_i,b_i] represents that there is a red directed edge from node **a_i** to node **b_i** in the graph, 2. **blueEdges[j]=[u_j,v_j]** represents that there is a blue directed edge from node **u_j** to node **v_j** in the graph. Return an array **answer** of length **n**, where answer[X] is the length of the shortest path from node 0 to node **X** with alternating appearances of red and blue edges. If such a path does not exist, then answer[x]=-1;\nPlease create a class **AAR** with the attribute **n** using Python based on the above question; then create a class **SN_AAR** that inherits the **AAR** class, and add two attributes **red_edges** and **blue_edges**, as well as a public function **Alternating_appearance** that returns the result of the above question.", "test_list": ["assert candidate(3,[[0,1],[1,2]],[])==[0,1,-1]", "assert candidate(3,[[0,1]],[[2,1]])==[0,1,-1]"], "test_function": "def test_run(content1,content2,content3):\n    return SN_AAR(content1,content2,content3).Alternating_appearance()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AAR\", \"def __init__(self, n)\", \"class SN_AAR(AAR)\", \"def __init__(self, n, red_edges, blue_edges)\", \"super().__init__(n)\", \"def Alternating_appearance\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/150", "question": "Question: Given two integer arrays of equal length, return the maximum value of the following expression: |arr1[i]-arr1[j]|+|arr2[i]-arr2[j]|+|i-j| where the indices **i**, **j** satisfy 0<=i,j<arr1.length;\nBased on the above question, please create a class **MES** in Python, which has the attribute **arr1**. Then create another class **SN_MES**, inheriting from the **MES** class, and add the attribute **arr2**, as well as a public function **Maximum_expression** to return the result of the above question.", "test_list": ["assert candidate([1,2,3,4],[-1,4,5,6])==13", "assert candidate([1,-2,-5,0,10],[0,-2,-1,-7,-4])==20"], "test_function": "def test_run(content1,content2):\n    return SN_MES(content1,content2).Maximum_expression()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MES\", \"def __init__(self, arr1)\", \"class SN_MES(MES)\", \"def __init__(self, arr1, arr2)\", \"super().__init__(arr1)\", \"def Maximum_expression\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/151", "question": "Question: Given a two-dimensional **grid** composed of several 0s and 1s, please find the largest square sub-grid whose boundaries are all composed of 1s, and return the number of elements in the sub-grid. If it does not exist, return 0;\nPlease create a class **SSR** with the property **grid** in Python based on the above question; then create a class **SN_GGG** that inherits from the **GGG** class, and add a public function **Square_subgrid** to return the result of the above question.", "test_list": ["assert candidate([[1,1,1],[1,0,1],[1,1,1]])==9", "assert candidate([[1,1,0,0]])==1"], "test_function": "def test_run(content1):\n    return SN_GGG(content1).Square_subgrid()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSR\", \"def __init__(self, grid)\", \"class SN_GGG(GGG)\", \"super().__init__(grid)\", \"def Square_subgrid\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/152", "question": "Question: Alice and Bob continue their stone game. Many piles of stones are lined up, each pile has a positive integer number of stones piles[i]. The game is decided by who has the most stones in their hands. Alice and Bob take turns, with Alice starting first. Initially, M=1. In each player's turn, the player can take all the stones from the remaining first **X** piles, where 1<=X<=2M. Then, let M=max(M,X). The game continues until all the stones are taken. Assuming Alice and Bob both play at their best, return the maximum number of stones Alice can get;\nBased on the above question, please create a class **SGA** using Python language, with the attribute **piles**; then create a class **SN_SGA** that inherits the **SGA** class, and add a public function **Stone_Game** to return the maximum number of stones Alice can get.", "test_list": ["assert candidate([2,7,9,4,4])==10", "assert candidate([1,2,3,4,5,100])==104"], "test_function": "def test_run(content1):\n    return SN_SGA(content1).Stone_Game()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SGA\", \"def __init__(self, piles)\", \"class SN_SGA(SGA)\", \"super().__init__(piles)\", \"def Stone_Game\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/153", "question": "Question: Given two strings **text1** and **text2**, return the length of the longest common subsequence of these two strings. If there is no common subsequence, return 0. A subsequence of a string is a new string that is formed by deleting some characters (or no characters) from the original string without changing the relative order of the characters. The common subsequence of two strings is a subsequence that the two strings both have;\nBased on the above question, please create a class **SSN** in Python, with the attribute **text1**; then create another class **SN_SSN** that inherits from the **SSN** class, and add the attribute **text2**, as well as a public function **Shared_subsequences** to return the result of the above question.", "test_list": ["assert candidate(\"abcde\",\"ace\")==3", "assert candidate(\"abc\",\"abc\")==3", "assert candidate(\"abc\",\"def\")==0"], "test_function": "def test_run(content1,content2):\n    return SN_SSN(content1,content2).Shared_subsequences()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSN\", \"def __init__(self, text1)\", \"class SN_SSN(SSN)\", \"def __init__(self, text1, text2)\", \"super().__init__(text1)\", \"def Shared_subsequences\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/154", "question": "Question: Given an integer array **nums**, each operation will select an element and decrease its value by 1. If one of the following conditions is met, then array **A** is a zigzag array:\n1. Each element corresponding to an even index is greater than its adjacent elements, i.e., A[0]>A[1]<A[2]>A[3]<A[4]>...; \n2. Or, each element corresponding to an odd index is greater than its adjacent elements, i.e., A[0]<A[1]>A[2]<A[3]>A[4]<...; \nReturn the minimum number of operations required to convert the array **nums** into a zigzag array.\n\nBased on the above question, please create a class **JAR** in Python language, which has the attribute **nums**. Then create a class **SN_JAR** that inherits from the **JAR** class, and add a public function **Jagged_array** to return the minimum number of operations required to convert the integer array **nums** into a zigzag array.", "test_list": ["assert candidate([1,2,3])==2", "assert candidate([9,6,1,6,2])==4"], "test_function": "def test_run(content1):\n    return SN_JAR(content1).Jagged_array()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JAR\", \"def __init__(self, nums)\", \"class SN_JAR(JAR)\", \"super().__init__(nums)\", \"def Jagged_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/155", "question": "Question: You will be given a string **text**, which should be divided into **k** substrings (subtext1, subtext2,,subtextk), with the following requirements:\n1. Each **subtexti** is a non-empty string; \n2. The concatenation of all substrings equals to **text** (i.e., subtext1+subtext2+...+subtextk==text); \n3. For all valid values of **i** (i.e., 1<=i<=k), subtexti==subtextk-i+1 should hold True; \nThe task is to return the maximum possible value of **k**.\nPlease create a class **ESI** in Python, which has the attribute **text**. Then create another class **SN_ESI**, which inherits from the **ESI** class, and add a public function **empty_string** that returns the maximum possible value of **k**.", "test_list": ["assert candidate(\"ghiabcdefhelloadamhelloabcdefghi\")==7", "assert candidate(\"merchant\")==1", "assert candidate(\"antaprezatepzapreanta\")==11"], "test_function": "def test_run(content1):\n    return SN_ESI(content1).empty_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ESI\", \"def __init__(self, text)\", \"class SN_ESI(ESI)\", \"super().__init__(text)\", \"def empty_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/156", "question": "Question: Here we have **n** identical dice, each with **k** faces, numbered from 1 to **k**. Given three integers **n**, **k**, and **target**, return the number of possible ways (out of a total of k^n ways) to roll the dice so that the sum of the numbers facing up equals **target**;\nBased on the above question, please create a class **FUP** in Python, with the attribute **n**; then create another class **SN_FUP**, inheriting from the **FUP** class, and add two attributes **k** and **target**, as well as a public function **face_up** that returns the result of the above question.", "test_list": ["assert candidate(1,6,3)==1", "assert candidate(2,6,7)==6", "assert candidate(30,30,500)==222616187"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FUP(content1,content2,content3).face_up()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FUP\", \"def __init__(self, n)\", \"class SN_FUP(FUP)\", \"def __init__(self, n, k, target)\", \"super().__init__(n)\", \"def face_up\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/157", "question": "Question: If all characters in a string are the same, then the string is a single-character repeated string. Given a string **text**, you can only swap two characters once or do nothing, and then get some single-character repeated substrings. Return the length of the longest substring;\nPlease create a **DSN** class in Python based on the above question, with the attribute **text**. Then create a class **SN_DSN** that inherits from the **DSN** class, and add a public function **Duplicate_string** that returns the length of the longest substring.", "test_list": ["assert candidate(\"ababa\")==3", "assert candidate(\"aaabaaa\")==6", "assert candidate(\"aaabbaaa\")==4", "assert candidate(\"aaaaa\")==5", "assert candidate(\"abcdef\")==1"], "test_function": "def test_run(content1):\n    return SN_DSN(content1).Duplicate_string()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DSN\", \"def __init__(self, text)\", \"class SN_DSN(DSN)\", \"super().__init__(text)\", \"def Duplicate_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/158", "question": "Question: You currently have a **grid** of size n x n in your hand, with each cell marked with 0 and 1. Here, 0 represents the ocean, and 1 represents the **land**. Please find an ocean cell where the distance to the nearest land cell is the maximum, and return this distance. If the grid only contains land or ocean, please return -1;\nBased on the above question, create an **OCL** class in Python language with the **grid** attribute; then create a **SN_OCL** class that inherits the **OCL** class, and add a public **Ocean_Cell** function to return the result of the above question.", "test_list": ["assert candidate([[1,0,1],[0,0,0],[1,0,1]])==2", "assert candidate([[1,0,0],[0,0,0],[0,0,0]])==4"], "test_function": "def test_run(content1):\n    return SN_OCL(content1).Ocean_Cell()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class OCL\", \"def __init__(self, grid)\", \"class SN_OCL(OCL)\", \"super().__init__(grid)\", \"def Ocean_Cell\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/159", "question": "Question: Given a string **s**, find all its substrings and sort them in lexicographical order, return the last substring;\nBased on the above question, create a class **LAM** in Python language with the attribute **s**; then create another class **SN_LAM**, inheriting from the **LAM** class, and add a public function **Lexicographic_arrangement** to return the last substring.", "test_list": ["assert candidate(\"abab\")==\"bab\"", "assert candidate(\"leetcode\")==\"tcode\""], "test_function": "def test_run(content1):\n    return SN_LAM(content1).Lexicographic_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LAM\", \"def __init__(self, s)\", \"class SN_LAM(LAM)\", \"super().__init__(s)\", \"def Lexicographic_arrangement\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/160", "question": "Question: A transaction may be invalid under the following two circumstances:\n1. The transaction amount exceeds $1000; 2. Or, it is not more than 60 minutes (including 60 minutes) apart from another transaction with the same name in another city; Given the string array transaction list **transactions**. Each transaction string transactions[i] is composed of some values separated by commas, which represent the name, time (in minutes), amount, and city of the transaction. Return **transactions**, return the list of possible invalid transactions;\nPlease create a class **TLI** in Python language based on the above question, with the attribute **transactions**; then create another class **SN_TLI** that inherits from the **TLI** class, and add a public function **Transaction_List** that returns the result of the above question.", "test_list": ["assert candidate([\"alice,20,800,mtv\",\"alice,50,100,beijing\"])==[\"alice,20,800,mtv\",\"alice,50,100,beijing\"]", "assert candidate([\"alice,20,800,mtv\",\"alice,50,1200,mtv\"])==[\"alice,50,1200,mtv\"]", "assert candidate([\"alice,20,800,mtv\",\"bob,50,1200,mtv\"])==[\"bob,50,1200,mtv\"]"], "test_function": "def test_run(content1):\n    return SN_TLI(content1).Transaction_List()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TLI\", \"def __init__(self, transactions)\", \"class SN_TLI(TLI)\", \"super().__init__(transactions)\", \"def Transaction_List\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/161", "question": "Question: Given two integer arrays **arr1** and **arr2**, return the minimum number of operations required to make **arr1** strictly increasing (possibly 0). In each operation, you can select an index from both **arr1** and **arr2**, respectively **i** and **j**, where 0<=i<arr1.length and 0<=j<arr2.length, and then perform the assignment operation arr1[i]=arr2[j]. If it is impossible to make **arr1** strictly increasing, please return -1;\nBased on the above question, please create a class **SII** in Python language with the property **arr1**; then create another class **SN_SII** that inherits the **SII** class, and add the property **arr2**, as well as a public function **Strictly_Increasing** that returns the result of the above question.", "test_list": ["assert candidate([1,5,3,6,7],[1,3,2,4])==1", "assert candidate([1,5,3,6,7],[4,3,1])==2", "assert candidate([1,5,3,6,7],[1,6,3,3])==-1"], "test_function": "def test_run(content1,content2):\n    return SN_SII(content1,content2).Strictly_Increasing()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SII\", \"def __init__(self, arr1)\", \"class SN_SII(SII)\", \"def __init__(self, arr1, arr2)\", \"super().__init__(arr1)\", \"def Strictly_Increasing\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/162", "question": "Question: Given a string **s** (containing only lowercase English letters and parentheses), please reverse the string in each pair of matching parentheses from the inside out in order, and return the final result;\nBased on the above question, please create a class **MBC** in Python language with the attribute **s**. Then create another class **SN_MBC** that inherits from the **MBC** class, and add a public function **Match_Brace** to return the final result.", "test_list": ["assert candidate(\"(abcd)\")==\"dcba\"", "assert candidate(\"(u(love)i)\")==\"iloveu\"", "assert candidate(\"(ed(et(oc))el)\")==\"leetcode\"", "assert candidate(\"a(bcdefghijkl(mno)p)q\")==\"apmnolkjihgfedcbq\""], "test_function": "def test_run(content1):\n    return SN_MBC(content1).Match_Brace()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MBC\", \"def __init__(self, s)\", \"class SN_MBC(MBC)\", \"super().__init__(s)\", \"def Match_Brace\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/163", "question": "Question: Given an integer array **arr** and an integer **k**, modify the array by repeating **k** times. Return the sum of the largest subarray in the modified array;\nPlease create a class **SSA** in Python based on the above question, with the attribute **arr**. Then create a class **SN_SSA** that inherits from the **SSA** class, and add the attribute **k**, as well as a public function **Sum_subarrays** that returns the sum of the largest subarray in the modified array.", "test_list": ["assert candidate([1,2],3)==9", "assert candidate([1,-2,1],5)==2", "assert candidate([-1,-2],7)==0"], "test_function": "def test_run(content1,content2):\n    return SN_SSA(content1,content2).Sum_subarrays()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SSA\", \"def __init__(self, arr)\", \"class SN_SSA(SSA)\", \"def __init__(self, arr, k)\", \"super().__init__(k)\", \"def Sum_subarrays\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/164", "question": "Question: Given four integers: **n**, **a**, **b**, **c**, please design an algorithm to find the n-th ugly number;\nBased on the above question, create a class **UNB** in Python, with the attribute **n**; then create another class **SN_UNB**, inheriting from the **UNB** class, and add three attributes **a**, **b** and **c**, as well as a public function **Ugly_number** to return the n-th ugly number.", "test_list": ["assert candidate(3,2,3,5)==4", "assert candidate(4,2,3,4)==6", "assert candidate(5,2,11,13)==10", "assert candidate(1000000000,2,217983653,336916467)==1999999984"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_UNB(content1,content2,content3,content4).Ugly_number()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class UNB\", \"def __init__(self, n)\", \"class SN_UNB(UNB)\", \"def __init__(self, n, a, b, c)\", \"super().__init__(n)\", \"def Ugly_number\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/165", "question": "Question: Given a string **s** and some index pairs array **pairs** in the string, where pairs[i]=[a,b] represents two indexes in the string (numbered from 0). You can swap the characters at any pair of indexes in pairs any number of times. Return the lexicographically smallest string that **s** can become after several swaps;\nBased on the above question, please create a class **DMM** in Python with the attribute **s**; then create a class **SN_DMM** that inherits the **DMM** class, and add the attribute **pairs**, as well as a public function **Dictionary_minimum** to return the result of the above question.", "test_list": ["assert candidate(\"dcab\",[[0,3],[1,2]])==\"bacd\"", "assert candidate(\"dcab\",[[0,3],[1,2],[0,2]])==\"abcd\"", "assert candidate(\"cba\",[[0,1],[1,2]])==\"abc\""], "test_function": "def test_run(content1,content2):\n    return SN_DMM(content1,content2).Dictionary_minimum()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DMM\", \"def __init__(self, s)\", \"class SN_DMM(DMM)\", \"def __init__(self, s, pairs)\", \"super().__init__(s)\", \"def Dictionary_minimum\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/166", "question": "Question: Given two strings of equal length, **s** and **t**. Changing the i-th character in **s** to the i-th character in **t** requires a cost of |s[i]-t[i]| (the cost could be 0), which is the absolute difference of the ASCII values of the two characters. The maximum budget for changing the string is **maxCost**. During the string transformation, the total cost should be less than or equal to this budget, which also means that the string transformation may be incomplete. If you can transform a substring of **s** into its corresponding substring in **t**, then return the maximum length that can be transformed. If there is no substring in **s** that can be transformed into a corresponding substring in **t**, then return 0;\nBased on the above question, please create a class named **MBG** in Python, which has an attribute **s**. Then create a class named **SN_MBG**, which inherits from the **MBG** class, and adds two attributes **t** and **maxCost**, as well as a public function **Maximum_budget** to return the result of the above question.", "test_list": ["assert candidate(\"abcd\",\"bcdf\",3)==3", "assert candidate(\"abcd\",\"cdef\",3)==1", "assert candidate(\"abcd\",\"acde\",0)==1"], "test_function": "def test_run(content1,content2,content3):\n    return SN_MBG(content1,content2,content3).Maximum_budget()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MBG\", \"def __init__(self, s)\", \"class SN_MBG(MBG)\", \"def __init__(self, s, t, maxCost)\", \"super().__init__(s)\", \"def Maximum_budget\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/167", "question": "Question: Given a string **s**, the **k** times repeated item deletion operation will select **k** adjacent and equal letters from **s** and delete them, connecting the left and right sides of the deleted string. You need to repeatedly perform such deletion operations on **s** indefinitely until it can no longer continue. After all deletion operations are completed, return the final obtained string;\nBased on the above question, please create a class **DOT** in Python language with the attribute **s**; then create a class **SN_DOT**, inherit the **DOT** class, and add the attribute **k**, as well as a public **Delete_Operation** function to return the final obtained string.", "test_list": ["assert candidate(\"abcd\",2)==\"abcd\"", "assert candidate(\"deeedbbcccbdaa\",3)==\"aa\"", "assert candidate(\"pbbcggttciiippooaais\",2)==\"ps\""], "test_function": "def test_run(content1,content2):\n    return SN_DOT(content1,content2).Delete_Operation()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DOT\", \"def __init__(self, s)\", \"class SN_DOT(DOT)\", \"def __init__(self, s, k)\", \"super().__init__(s)\", \"def Delete_Operation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/168", "question": "Question: Given an integer array **arr** and an integer **difference**, please find and return the length of the longest arithmetic subsequence in **arr**, where the difference between adjacent elements equals **difference**;\nBased on the above question, please create a class **ESQ** in Python, which has the attribute **arr**. Then create another class **SN_ESQ**, inheriting from the **ESQ** class, and add the attribute **difference**, as well as a public function **Equidistant_subsequence** to return the length of the longest arithmetic subsequence in the integer array **arr**.", "test_list": ["assert candidate([1,2,3,4],1)==4", "assert candidate([1,3,5,7],1)==1", "assert candidate([1,5,7,8,5,3,4,2,1],-2)==4"], "test_function": "def test_run(content1,content2):\n    return SN_ESQ(content1,content2).Equidistant_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ESQ\", \"def __init__(self, arr)\", \"class SN_ESQ(ESQ)\", \"def __init__(self, arr, difference)\", \"super().__init__(arr)\", \"def Equidistant_subsequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/169", "question": "Question: You are to develop a gold mine. Geological surveyors have determined the resource distribution in the mine and marked it with an m*n grid. Each integer in a cell represents the amount of gold in that cell; if the cell is empty, it is 0. To maximize profits, miners need to mine gold according to the following rules:\n1. Whenever a miner enters a cell, he collects all the gold in that cell. 2. Miners can move up, down, left, and right from their current position. 3. Each cell can only be mined (entered) once. 4. Cells with zero gold cannot be mined (entered). 5. Miners can start or stop from any cell with gold in the grid;\nBased on the above question, please use Python to create a class **RDB** with the attribute **grid**. Then create a class **SN_RDB** that inherits from the **RDB** class and add a public function **resource_distribution** that returns the result of the above question.", "test_list": ["assert candidate([[0,6,0],[5,8,7],[0,9,0]])==24", "assert candidate([[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]])==28"], "test_function": "def test_run(content1):\n    return SN_RDB(content1).resource_distribution()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RDB\", \"def __init__(self, grid)\", \"class SN_RDB(RDB)\", \"super().__init__(grid)\", \"def resource_distribution\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/170", "question": "Question: Given an integer **n**, please help to count how many strings of length **n** can be formed according to the following rules:\n1. Each character in the string should be a lowercase vowel ('a', 'e', 'i', 'o', 'u'); 2. Each vowel 'a' can only be followed by 'e'; 3. Each vowel 'e' can only be followed by 'a' or 'i'; 4. Each vowel 'i' cannot be followed by another 'i'; 5. Each vowel 'o' can only be followed by 'i' or 'u'; 6. Each vowel 'u' can only be followed by 'a';\nPlease create a class named **FSG** in Python, with an attribute **n**; then create another class **SN_FSG** that inherits from the **FSG** class, and add a public method **Forming_String** that returns the result of the above question.", "test_list": ["assert candidate(1)==5", "assert candidate(2)==10", "assert candidate(5)==68"], "test_function": "def test_run(content1):\n    return SN_FSG(content1).Forming_String()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FSG\", \"def __init__(self, n)\", \"class SN_FSG(FSG)\", \"super().__init__(n)\", \"def Forming_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/171", "question": "Question: On an 8x8 chessboard, there are several black queens and one white king. Given an array of integer coordinates **queens**, representing the positions of the black queens; and a pair of coordinates **king**, representing the position of the white king, return the coordinates of all queens that can attack the king (in any order);\nBased on the above question, please use python language to create a class **CKB** with the property **queens**; then create a class **SN_CKB**, inheriting from the **CKB** class, and add the property **king**, as well as a public **checkerboard** function to return the coordinates of all queens that can attack the king.", "test_list": ["assert candidate([[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]],[0,0])==[[0,1],[1,0],[3,3]]", "assert candidate([[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]],[3,3])==[[2,2],[3,4],[4,4]]", "assert candidate([[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]],[3,4])==[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]"], "test_function": "def test_run(content1,content2):\n    return SN_CKB(content1,content2).checkerboard()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CKB\", \"def __init__(self, queens)\", \"class SN_CKB(CKB)\", \"def __init__(self, queens, king)\", \"super().__init__(queens)\", \"def checkerboard\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/171", "question": "Create a class named **SBFD** in Python, with properties **nums**, **left**, and **right**, as well as a public function named **find_subarray**. In the public function **find_subarray**, identify and return the count of contiguous, non-empty subarrays within **nums** where the maximum element falls within the range **[left, right]**. Next, create a class named **SN_FDSB** that inherits from the **SBFD** class and add a public function named **find_subarray**. This method should return the count of elements in **nums** within the range **[left, right]**, inclusive of both **left** and **right**. If the range is empty, the function should return 0.", "test_list": ["assert candidate([2,1,4,3],2,3,1,2)==True", "assert candidate([2,9,2,5,6],2,8,1,4)==True"], "test_function": "def test_run(content1, content2, content3, res1, res2):\n    if SBFD(content1, content2, content3).find_subarray()==res1 and SN_FDSB(content1, content2, content3).find_subarray() == res2\n        return True\n    else:\n        return False", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SBFD\", \"def __init__(self, nums, left, right)\", \"class SN_FDSB\", \"def find_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/172", "question": "First, write a class named **STR** in Python, which has an instance attribute, **s**, and a public function named **without_duplicates**. In the public function **without_duplicates**, based on the instance attribute **s**, find the length of the longest substring without duplicate characters. Next, create a class named **SUB_STR** that inherits from the **STR** class and add a public function named **without_duplicates**. In the public function **without_duplicates** of the **SUB_STR** class, find the maximum distance between repeated characters in the instance attribute **s**.", "test_list": ["assert candidate(\"abcabcbb\", 3, 3)==True", "assert candidate(\"abcabcccbb\", 3, 4)==True", "assert candidate(\"pwwkeyow\", 5, 5)==True"], "test_function": "def test_run(content1, res1, res2):\n    if STR(content1).without_duplicates()==res1 and SUB_STR(content1).without_duplicates() == res2\n        return True\n    else:\n        return False", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STR\", \"def __init__(self, s)\", \"class SUB_STR\", \"def without_duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/173", "question": "Using the Python language, start by creating a class named **PLDR** with an instance attribute **number** and a public function **PLind**. Within the **PLind** function, check if a given number is a palindrome; return **True** if it is, otherwise return **False**. Next, create a subclass named **SUBPLDR** that inherits from the **PLDR** class, and introduce a public function **PLind**. In the **PLind** function of the **SUBPLDR** class, assess whether a given number is a palindrome string; return **True** if it is, otherwise return **False**.", "test_list": ["assert candidate(1211, \"abcabcbb\", False, False)==True", "assert candidate(121, \"abcabcccbb\", True, False)==True", "assert candidate(4576, \"level\", False, True)==True"], "test_function": "def test_run(content1, content2, res1, res2):\n    if PLDR(content1).PLind()==res1 and SUBPLDR(content2).PLind() == res2\n        return True\n    else:\n        return False", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PLDR\", \"def __init__(self, number)\", \"class SUBPLDR\", \"def PLind\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}

