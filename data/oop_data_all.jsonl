{"task_id": "OOP/0", "question": "First, write a **WDS** class using the Python language. Then, within the WDS class, create a public function called **without_duplicates** to implement finding the length of the longest substring in a given string **s** that does not contain any duplicate characters.", "test_list": ["assert candidate(\"abcabcbb\")==3", "assert candidate(\"bbbbb\")==1", "assert candidate(\"pwwkew\")==3"], "test_function": "def test_run(content1):\n    return WDS().without_duplicates(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class WDS\", \"def without_duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/1", "question": "First, design a class called **MNS** in Python, which has an instance attribute called **machines**, a private function called **private_Ministeps**, and a public function called **public_Ministeps**. Then, implement the following problem in the private function **private_Ministeps**. Finally, call the private function private_Ministeps in the public function **public_Ministeps** and return the result.\nProblem: There are **n** super washing machines placed in a row, and it is unknown whether there are clothes inside each machine. You can choose any **m** machines and move one piece of clothing from each selected machine to an adjacent machine. Return the minimum number of steps required to make the number of clothes remaining in each machine equal.", "test_list": ["assert candidate([1,0,5])==3", "assert candidate([0,3,0])==2", "assert candidate([0,2,0])==-1"], "test_function": "def test_run(content1):\n    return MNS(content1).public_Minimum_number_steps()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNS\", \"def public_Ministeps\", \"def __private_Ministeps\"],[\"class MNS\", \"def public_Ministeps\", \"def _private_Ministeps\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/3", "question": "First, write a class called **FTM** using the Python language. Then, within the **FTM** class, create a public function called **find_the_median** that returns the median of two sorted arrays, **nums1** and **nums2**.", "test_list": ["assert candidate([1,3], [2])==2.00000", "assert candidate([1,2], [3,4])==2.50000"], "test_function": "def test_run(content1,content2):\n    return FTM().find_the_median(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTM\", \"def find_the_median\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/4", "question": "First, write a **PDSB** class using the Python language. Then, within the **PDSB** class, implement a public **pa_substring** function to find the longest palindrome substring in string **s**.", "test_list": ["assert candidate(\"babad\")==\"bab\"", "assert candidate(\"cbbd\")==\"bb\""], "test_function": "def test_run(content1):\n    return PDSB().pa_substring(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PDSB\", \"def pa_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/5", "question": "First, write a **ZZPTN** class using the Python language, then write a public **Zigzag_pattern** function in the **ZZPTN** class to solve the following problem.\nProblem: Given a string **s** and an integer **numRows**, arrange the string **s** from top to bottom and from left to right in a Z shape according to the given **numRows**.", "test_list": ["assert candidate(\"PAYPALISHIRING\", 3)==\"PAHNAPLSIIGYIR\"", "assert candidate(\"PAYPALISHIRING\", 4)==\"PINALSIGYAHRPI\"", "assert candidate(\"A\", 1)==\"A\""], "test_function": "def test_run(content1,content2):\n    return ZZPTN().Zigzag_pattern(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ZZPTN\", \"def Zigzag_pattern\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/6", "question": "First, write an **ITOC** class using the Python language. Then, within the **ITOC** class, create a public function called **Invert_outcome** that takes a 32-bit signed integer **x** as input and returns the result of reversing the numerical part of **x**.", "test_list": ["assert candidate(123)==321", "assert candidate(-123)==-321", "assert candidate(120)==21", "assert candidate(0)==0"], "test_function": "def test_run(content1):\n    return ITOC().Invert_outcome(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ITOC\", \"def Invert_outcome\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/7", "question": "First, write a **PDIT** class using Python language. Then, within the **PDIT** class, write a public function named **Palindromic_integer**. This function should determine whether a given integer **x** is a palindromic integer. If it is, the function should return True; otherwise, it should return False.", "test_list": ["assert candidate(121)==True", "assert candidate(-121)==False", "assert candidate(10)==False"], "test_function": "def test_run(content1):\n    return PDIT().Palindromic_integer(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PDIT\", \"def Palindromic_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/8", "question": "First, write a **RLMH** class using the Python language. Then, within the **RLMH** class, create a public **rule_matching** function that implements a regular expression matching for a given string **s** and a character pattern **p**, using the following rules: 1. '.' matches any single character; 2. '*' matches zero or more occurrences of the preceding element.", "test_list": ["assert candidate(\"aa\", \"a\")==False", "assert candidate(\"aa\", \"a*\")==True", "assert candidate(\"ab\", \".*\")==True"], "test_function": "def test_run(content1,content2):\n    return RLMH().rule_matching(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RLMH\", \"def rule_matching\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/9", "question": "First, write a **LCMP** class using the Python language. Then, within the **LCMP** class, create a public function called **longest_common_prefix** to find the longest common prefix among an array of strings. If no common prefix exists, return an empty string \"\".", "test_list": ["assert candidate([\"flower\",\"flow\",\"flight\"])==\"fl\"", "assert candidate([\"dog\",\"racecar\",\"car\"])==\"\""], "test_function": "def test_run(content1,content2,content3):\n    return LCMP().longest_common_prefix(content1,content2,content3)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LCMP\", \"def longest_common_prefix\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/10", "question": "First, write a **TSOTN** class using the Python language. Then, within the **TSOTN** class, create a public function called **sum_three_numbers**. This function takes in an integer array called **nums** with a length of **n**, and a target value called **target**. The function selects three integers from **nums** in such a way that their sum is closest to the target value. Finally, the function returns the sum of these three numbers.", "test_list": ["assert candidate([-1,2,1,-4], 1)==2", "assert candidate([0,0,0], 1)==0"], "test_function": "def test_run(content1,content2):\n    return TSOTN().sum_three_numbers(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TSOTN\", \"def sum_three_numbers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/11", "question": "Firstly, write a class **VLD_ST** using the Python language, then write a public function **valid_string** within the **VLD_ST** class to judge whether a given string **s**, which only includes '(',')','{','}','[',']', is valid or not. \nA valid string must meet the following conditions: \n1. The left bracket must be closed by the right bracket of the same type; \n2. The left brackets must be closed in the correct order; \n3. Each right bracket has a corresponding left bracket of the same type.", "test_list": ["assert candidate(\"()\")==True", "assert candidate(\"()[]{}\")==True", "assert candidate(\"(]\")==False"], "test_function": "def test_run(content1):\n    return VLD_ST().valid_string(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VLD_ST\", \"def valid_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/12", "question": "First, write a **VDPT** class using the Python language. Then, within the **VDPT** class, create a public **valid_parentheses** function. This function should take an integer **n** as input, representing the number of pairs of parentheses to generate. The function should then print out all possible and valid combinations of parentheses.", "test_list": ["assert candidate(3)==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()==[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]", "assert candidate(1)==[\"()==[\"()\"]", "assert candidate(\"(]\")==False"], "test_function": "def test_run(content1):\n    return VDPT().valid_parentheses(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class VDPT\", \"def valid_parentheses\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/13", "question": "First, write a **NLAR** class using the Python language. Then, within the **NLAR** class, create a public function called **new_length_removal**. This function should take an array called **nums** and a value called **val** as input. The function should remove all elements in the array that are equal to **val**, and return the new length of the array after removal.", "test_list": ["assert candidate([3,2,2,3], 3)==2", "assert candidate([0,1,2,2,3,0,4,2], 2)==5"], "test_function": "def test_run(content1,content2):\n    return NLAR().new_length_removal(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NLAR\", \"def new_length_removal\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/14", "question": "First, write a class **FMIS** using the Python language. Then, within the **FMIS** class, write a public function **find_matching_items** that, given two strings **haystack** and **needle**, finds the index of the first matching item of the **needle** string in the **haystack** string (index starts from 0). If the **needle** is not part of the **haystack**, return -1.", "test_list": ["assert candidate(\"sadbutsad\", \"sad\")==0", "assert candidate(\"leetcode\", \"leeto\")==-1"], "test_function": "def test_run(content1,content2):\n    return FMIS().find_matching_items(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FMIS\", \"def find_matching_items\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/15", "question": "First, write an **LVPSS** class using the Python language. Then, within the **LVPSS** class, write a public function named **long_valid_substring**. This function should find the length of the longest valid (correctly formatted and continuous) parenthesis substring in a given string that only contains '(' and ')'.", "test_list": ["assert candidate(\"(()\")==2", "assert candidate(\"\")==0", "assert candidate(\")()())\")==4"], "test_function": "def test_run(content1):\n    return LVPSS().long_valid_substring(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class LVPSS\", \"def long_valid_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/16", "question": "First, write a class named **FTGV** using the Python language. Then, within the **FTGV** class, write a public function called **find_target_value** that, given a sorted array and a target value, finds the target value in the array and returns its index. If the target value does not exist in the array, it returns the position where it would be inserted in order.", "test_list": ["assert candidate([1,3,5,6], 5)==2", "assert candidate([1,3,5,6], 2)==1", "assert candidate([1,3,5,6], 7)==4"], "test_function": "def test_run(content1,content2):\n    return FTGV().find_target_value(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTGV\", \"def find_target_value\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/17", "question": "First, write a class **FSAEP** using the Python language, then write a public function **finding_positions** in the **LVPSS** class. Given an integer array **nums** sorted in non-decreasing order and a target value **target**, this function finds the starting and ending positions of the given target value in the array. If the target value **target** does not exist in the array, return [-1, -1].", "test_list": ["assert candidate([5,7,7,8,8,10], 8)==[3,4]", "assert candidate([5,7,7,8,8,10], 6)==[-1,-1]", "assert candidate([], 0)==[-1,-1]"], "test_function": "def test_run(content1,content2):\n    return LVPSS().long_valid_substring(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FSAEP\", \"def finding_positions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/18", "question": "Firstly, write an **NCBT** class using the Python language. Then, within the **NCBT** class, write a public function named **numeric_combination**. Given a set of candidate numbers **candidates** and a target number **target**, this function should find all combinations in **candidates** that can sum up to the **target** and return them in the form of a list.", "test_list": ["assert candidate([10,1,2,7,6,1,5], 8)==[[1,1,6],[1,2,5],[1,7],[2,6]]", "assert candidate([2,5,2,1,2], 5)==[[1,2,2],[5]]"], "test_function": "def test_run(content1,content2):\n    return NCBT().numeric_combination(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NCBT\", \"def numeric_combination\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/19", "question": "First, create a class called **TSPI** using the Python language. Then, within the **TSPI** class, write a public function called **smallest_positive_integer**. This function should take an unsorted array of integers called **nums** as input and find the smallest positive integer that is not present in the array.", "test_list": ["assert candidate([1,2,0])==3", "assert candidate([3,4,-1,1])==2", "assert candidate([7,8,9,11,12])==1"], "test_function": "def test_run(content1):\n    return TSPI().smallest_positive_integer(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TSPI\", \"def smallest_positive_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/20", "question": "First, write an **HTRW** class using the Python language, then write a public function named **harvest_rainwater** within the **HTRW** class to solve the following problem.\nProblem: Given **n** non-negative integers representing the height of each pillar of width 1 in the diagram, calculate how much rainwater can be collected after it rains with the pillars arranged in this way.", "test_list": ["assert candidate([0,1,0,2,1,0,1,3,2,1,2,1])==6", "assert candidate([4,2,0,3,2,5])==9"], "test_function": "def test_run(content1):\n    return HTRW().harvest_rainwater(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class HTRW\", \"def harvest_rainwater\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/21", "question": "First, write a class called **STFM** using the Python language. Then, within the **STFM** class, create a public function called **string_form**. This function should take two non-negative integers, **num1** and **num2**, represented as strings, and return their product as a string.", "test_list": ["assert candidate(\"123\", \"456\")==\"56088\"", "assert candidate(\"2\", \"3\")==\"6\""], "test_function": "def test_run(content1,content2):\n    return HTRW().harvest_rainwater(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STFM\", \"def string_form\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/22", "question": "First, write a **PMTTN** class using the Python language. Then, within the **PMTTN** class, create a public **permutation** function that takes an array **nums** without duplicate numbers as input and returns all possible permutations.", "test_list": ["assert candidate([1,2,3])==[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]", "assert candidate([0,1])==[[0,1],[1,0]]", "assert candidate([1])==[[1]]"], "test_function": "def test_run(content1):\n    return PMTTN().permutation(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PMTTN\", \"def permutation\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/23", "question": "First, write a **UQPTT** class using the Python language, then write a public **unique_permutations** function within the **UQPTT** class to solve the following problem.\nProblem: Given a sequence of **nums** containing duplicate numbers, return all unique permutations.", "test_list": ["assert candidate([1,1,2])==[[1,1,2],[1,2,1],[2,1,1]]", "assert candidate([1,2,3])==[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"], "test_function": "def test_run(content1):\n    return UQPTT().unique_permutations(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class UQPTT\", \"def unique_permutations\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/24", "question": "First, write a class called **RTICW** using the Python language. Then, within the **RTICW** class, create a public function called **rotate_image_clockwise**. This function should take a 2D matrix, represented by the variable matrix, with dimensions n Ã— n, which represents an image. The function should rotate the image clockwise by 90 degrees.", "test_list": ["assert candidate([[1,2,3],[4,5,6],[7,8,9]])==[[7,4,1],[8,5,2],[9,6,3]]", "assert candidate([[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]])==[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]"], "test_function": "def test_run(content1):\n    return RTICW().rotate_image_clockwise(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RTICW\", \"def rotate_image_clockwise\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/25", "question": "First, write a class called **AAGM** using the Python language. Then, within the **AAGM** class, create a public function called **anagram** that takes an array of strings as input. This function should group together anagrams and return the result as a list.", "test_list": ["assert candidate([\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"])==[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]", "assert candidate([\"\"])==[[\"\"]]", "assert candidate([\"a\"])==[[\"a\"]]"], "test_function": "def test_run(content1):\n    return AAGM().anagram(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AAGM\", \"def anagram\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/26", "question": "First, write a **PFTN** class using the Python language. Then, within the **PFTN** class, create a public **power_function** function that calculates the integer power of **x** to the n-th degree.", "test_list": ["assert candidate(2.00000, 10)==1024.00000", "assert candidate(2.10000, 3)==9.26100", "assert candidate(2.00000, -2)==0.25000"], "test_function": "def test_run(content1,content2):\n    return PFTN().power_function(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PFTN\", \"def power_function\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/27", "question": "First, write a class called **FDSB** using the Python language. Then, within the **FDSB** class, write a public function called **find_subarray** that takes an integer array called **nums** as input. This function will find a contiguous subarray within **nums** that has the maximum sum.", "test_list": ["assert candidate([-2,1,-3,4,-1,2,1,-5,4])==6", "assert candidate([1])==1", "assert candidate([5,4,-1,7,8])==23"], "test_function": "def test_run(content1):\n    return FDSB().find_subarray(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FDSB\", \"def find_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/28", "question": "First, write a class called **CWSO** using the Python language. Then, within the **CWSO** class, create a public function called **clockwise_spiral_order**. This function takes a matrix with **m** rows and **n** columns as input and returns all the elements in the matrix in a clockwise spiral order.", "test_list": ["assert candidate([[1,2,3],[4,5,6],[7,8,9]])==[1,2,3,6,9,8,7,4,5]", "assert candidate([[1,2,3,4],[5,6,7,8],[9,10,11,12]])==[1,2,3,4,8,12,11,10,9,5,6,7]"], "test_function": "def test_run(content1):\n    return CWSO().clockwise_spiral_order(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CWSO\", \"def clockwise_spiral_order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/29", "question": "First, write a class called **MMJL** using the Python language. Then, within the **MMJL** class, write a public function called **maximum_jump_length**. Given a non-negative integer array called **nums**, this function should determine whether it is possible to reach the last index based on the following rules: 1. Initially, start at the first index of the array. 2. Each element in the array represents the maximum length that can be jumped from that position. If it is possible to reach the last index, the function should return True; otherwise, it should return False.", "test_list": ["assert candidate([2,3,1,1,4])==True", "assert candidate([3,2,1,0,4])==False"], "test_function": "def test_run(content1):\n    return MMJL().maximum_jump_length(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MMJL\", \"def maximum_jump_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/30", "question": "Firstly, write a class named **MOLI** using Python language. Then, in the **MOLI** class, write a public function called **merge_overlapping_intervals** that takes an array **intervals** representing a collection of ranges, where each individual range is represented as intervals[i] = [start_i, end_i]. This function should merge all overlapping ranges and return an array of non-overlapping ranges that exactly cover all the ranges in the input.", "test_list": ["assert candidate([[1,3],[2,6],[8,10],[15,18]])==[[1,6],[8,10],[15,18]]", "assert candidate([[1,4],[4,5]])==[[1,5]]"], "test_function": "def test_run(content1):\n    return MOLI().merge_overlapping_intervals(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MOLI\", \"def merge_overlapping_intervals\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/31", "question": "First, write a **STANOL** class using the Python language. Then, within the **STANOL** class, create a public function called **sorted_non_overlapping** that inserts a new interval into a sorted list of non-overlapping intervals, sorted by the starting points of each interval. This function should ensure that the intervals in the list remain sorted and non-overlapping.", "test_list": ["assert candidate([[1,3],[6,9]], [2,5])==[[1,5],[6,9]]", "assert candidate([[1,2],[3,5],[6,7],[8,10],[12,16]], [4,8])==[[1,2],[3,10],[12,16]]", "assert candidate([], [5,7])==[[5,7]]", "assert candidate([[1,5]], [2,3])==[[1,5]]", "assert candidate([[1,5]], [2,7])==[[1,7]]"], "test_function": "def test_run(content1,content2):\n    return STANOL().sorted_non_overlapping(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STANOL\", \"def sorted_non_overlapping\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/32", "question": " First, write a **WDLH** class using the Python language, then write a public **word_length** function in the **WDLH** class to solve the following problem.\nProblem: Given a string **s**, the string **s** is composed of several words, separated by some space characters before and after the word, return the length of the last word in the string.", "test_list": ["assert candidate(\"Hello World\")==5", "assert candidate(\"   fly me   to   the moon  \")==4", "assert candidate(\"luffy is still joyboy\")==6"], "test_function": "def test_run(content1):\n    return WDLH().word_length(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class WDLH\", \"def word_length\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/33", "question": "First, write an **STP** class using the Python language. Then, in the **STP** class, write a public function named **shortest_path**. Given a m x n grid containing non-negative integers, this function should find a path from the top left corner to the bottom right corner that minimizes the sum of the numbers along the path.", "test_list": ["assert candidate([[1,3,1],[1,5,1],[4,2,1]])==7", "assert candidate([[1,2,3],[4,5,6]])==12"], "test_function": "def test_run(content1):\n    return STP().shortest_path(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STP\", \"def shortest_path\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/34", "question": "First, write a **NNTI** class using the Python language, then write a public **non_negative_integer** function in the **NNTI** class to solve the following problem.\nProblem: Given a non-empty array composed of integers representing a non-negative integer, add one to this number, and return the result with the highest digit stored at the beginning of the array.\nNote:Each element in the array only stores a single digit (except for the integer 0, this integer will not start with zero).", "test_list": ["assert candidate([1,2,3])==[1,2,4]", "assert candidate([4,3,2,1])==[4,3,2,2]", "assert candidate([0])==[1]"], "test_function": "def test_run(content1):\n    return NNTI().non_negative_integer(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NNTI\", \"def non_negative_integer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/35", "question": "First, write a class called **BASTI** using the Python language. Then, within the **BASTI** class, create a public function called **binary_string**. This function should take two binary strings, **a** and **b**, as input and return their sum in the form of a binary string.", "test_list": ["assert candidate(\"11\", \"1\")==\"100\"", "assert candidate(\"1010\", \"1011\")==\"10101\""], "test_function": "def test_run(content1,content2):\n    return BASTI().binary_string(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class BASTI\", \"def binary_string\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/36", "question": "First, write a **CRTP** class using the Python language. Then, within the **CRTP** class, implement a public function called **climb_rooftop** to solve the following problem: Suppose you are climbing a staircase and it takes **n** steps to reach the top. At each step, you can either climb 1 or 2 steps. How many distinct ways are there to climb to the top?", "test_list": ["assert candidate(2)==2", "assert candidate(3)==3"], "test_function": "def test_run(content1):\n    return CRTP().climb_rooftop(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CRTP\", \"def climb_rooftop\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/37", "question": "First, write a **TAFER** class using the Python language. Then, within the **TAFER** class, create a public **trans_fomer** function. This function takes two words, **word1** and **word2**, as input and returns the minimum number of operations required to transform **word1** into **word2**. There are three possible operations that can be performed on a word: 1. Inserting a character, 2. Deleting a character, and 3. Replacing a character.", "test_list": ["assert candidate(\"horse\", \"ros\")==3", "assert candidate(\"intention\", \"execution\")==5"], "test_function": "def test_run(content1,content2):\n    return TAFER().trans_fomer(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TAFER\", \"def trans_fomer\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/38", "question": "First, write a class called **STEZ** using the Python language. Then, within the **STEZ** class, create a public function called **element_setting_zero**. This function should take in an m x n matrix as input. If an element in the matrix is 0, it should set all the elements in its corresponding row and column to 0.", "test_list": ["assert candidate([[1,1,1],[1,0,1],[1,1,1]])==[[1,0,1],[0,0,0],[1,0,1]]", "assert candidate([[0,1,2,0],[3,4,5,2],[1,3,1,5]])==[[0,0,0,0],[0,4,5,0],[0,3,1,0]]"], "test_function": "def test_run(content1):\n    return STEZ().element_setting_zero(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STEZ\", \"def element_setting_zero\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/39", "question": "First, implement the **GYHT** class using the Python language. Then, write a public function called **YangHui_Triangle** within the **GYHT** class. This function should take a non-negative integer **numRows** as input and generate the first **numRows** rows of the Yang Hui triangle.", "test_list": ["assert candidate(5)==[[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]", "assert candidate(1)==[[1]]"], "test_function": "def test_run(content1):\n    return GYHT().Generate_Yang_Hui_Triangle(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GYHT\", \"def YangHui_Triangle\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/40", "question": "First, implement the **FTMPA** class using the Python language. Then, write a public function called **Minimum_Path** in the **FTMPA** class. This function should aim to find the minimum path sum from top to bottom in a given **triangle**.", "test_list": ["assert candidate([[2],[3,4],[6,5,7],[4,1,8,3]])==11", "assert candidate([[-10]])==-10"], "test_function": "def test_run(content1):\n    return FTMPA().Find_The_Minimum_Path_And(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTMPA\", \"def Minimum_Path\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/41", "question": "First, implement the **CMP** class using the Python language. Then, within the **CMP** class, write a public function called **Calculate_Maximum_Profit**. This function should take an array as input and calculate the maximum profit that can be obtained. Each element in the array represents the price of a given stock on the i-th day. It is allowed to complete a maximum of two transactions.", "test_list": ["assert candidate([3,3,5,0,0,3,1,4])==6", "assert candidate([1,2,3,4,5])==4", "assert candidate([7,6,4,3,1])==0", "assert candidate([1])==0"], "test_function": "def test_run(content1):\n    return CMP().Calculate_Maximum_Profit(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CMP\", \"def Calculate_Maximum_Profit\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/42", "question": "First, implement the **FTLOTLS** class using the Python language. Then, write a public function called **Longest_Sequence** within the **FTLOTLS** class. This function should take an unsorted integer array called **nums** as input and find the length of the longest sequence of consecutive numbers (the sequence elements do not need to be consecutive in the original array).", "test_list": ["assert candidate([100,4,200,1,3,2])==4", "assert candidate([0,3,7,2,5,8,4,6,0,1])==9"], "test_function": "def test_run(content1):\n    return FTLOTLS().Find_The_Length_Of_The_Longest_Sequence(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTLOTLS\", \"def Longest_Sequence\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/43", "question": "First, implement the **AF** class using the Python language. Then, within the **AF** class, write a public function called **Area_Fill** that takes a given m x n matrix called **board**, which is composed of characters 'X' and 'O'. The function should find all the regions surrounded by 'X' and fill all the 'O' within these regions with 'X'.", "test_list": ["assert candidate([[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]])==[[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\"],[\"X\",\"O\",\"X\",\"X\"]]", "assert candidate([[\"X\"]])==[[\"X\"]]"], "test_function": "def test_run(content1):\n    return AF().Area_Fill(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AF\", \"def Area_Fill\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/44", "question": "First, implement the **SS** class using the Python language. Then, within the **SS** class, write a public function called **Split_String** that takes a string **s** as input and returns all possible partition schemes of **s**, where each substring in the partition is a palindrome.", "test_list": ["assert candidate(\"aab\")==[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]", "assert candidate(\"a\")==[[\"a\"]]"], "test_function": "def test_run(content1):\n    return SS().Split_String(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SS\", \"def Split_String\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/45", "question": "First, implement the **MNOD** class using the Python language. Then, within the **MNOD** class, write a public function called **Minimum_Divisions** that takes a string **s** as input. This function should split the string **s** into substrings, where each substring is a palindrome, and return the minimum number of divisions required to satisfy this condition.", "test_list": ["assert candidate(\"aab\")==1", "assert candidate(\"a\")==0", "assert candidate(\"ab\")==1"], "test_function": "def test_run(content1):\n    return MNOD().Minimum_Number_Of_Divisions(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNOD\", \"def Minimum_Divisions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/46", "question": "Firstly, implement the **DSBCD** class using Python language. Then, write a public **distribute_candie** function in the **DSBCD** class to solve the following problem.\nProblem: **n** children are standing in a line, and an integer array **ratings** is given to represent the ratings of each child. Candies need to be distributed to these children according to the following requirements:\n1. Each child should be allocated at least one candy; \n2. The child with a higher rating among two adjacent children will get more candies. \nFor distributing candies to each child, calculate and return the minimum number of candies that need to be prepared.", "test_list": ["assert candidate([1,0,2])==5", "assert candidate([1,2,2])==4"], "test_function": "def test_run(content1):\n    return DSBCD().distribute_candie(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DSBCD\", \"def distribute_candie\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/47", "question": "First, implement the **ITETAO** class using the Python language. Then, write a public function called **Appeared_Once** in the **ITETAO** class. This function should take a non-empty integer array called **nums** as input. The function should find the element that appears only once in the array, while all other elements appear twice.", "test_list": ["assert candidate([2,2,1])==1", "assert candidate([4,1,2,1,2])==4", "assert candidate([1])==1"], "test_function": "def test_run(content1):\n    return ITETAO().Identify_The_Element_That_Appeared_Once(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ITETAO\", \"def Appeared_Once\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/48", "question": "Firstly, implement a **JS** class using Python language. Then, in the **JS** class, write a public function named **Judgment_Splicing**. This function should take a string **s** and a list of strings **wordDict** as a dictionary, and determine whether the string **s** can be spliced together using the words that appear in the dictionary. If it can, return True; otherwise, return False.", "test_list": ["assert candidate(\"leetcode\", [\"leet\", \"code\"])==True", "assert candidate(\"applepenapple\", [\"apple\", \"pen\"])==True", "assert candidate(\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"])==False"], "test_function": "def test_run(content1,content2):\n    return JS().Judgment_Splicing(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JS\", \"def Judgment_Splicing\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/49", "question": "First, implement the **CS** class using the Python language. Then, write a public **Constructing_Sentences** function in the **CS** class to create a sentence by adding spaces in a given string **s**, using words from the wordDict string dictionary. The function should return all possible sentences that can be constructed.", "test_list": ["assert candidate(\"catsanddog\", [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"])==[\"cats and dog\",\"cat sand dog\"]", "assert candidate(\"pineapplepenapple\", [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"])==[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]", "assert candidate(\"catsandog\", [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"])==[]"], "test_function": "def test_run(content1,content2):\n    return CS().Constructing_Sentences(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CS\", \"def Constructing_Sentences\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/50", "question": "Firstly, implement the **FTMP** class using Python language. Then, in the **FTMP** class, write a public function named **Most_Points**. This function should take an array of **points** as input, where points[i]=[x_i,y_i] represents a point on the X-Y plane. The function should return how many points can be on the same line at most.", "test_list": ["assert candidate([[1,1],[2,2],[3,3]])==3", "assert candidate([[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]])==4"], "test_function": "def test_run(content1):\n    return FTMP().Find_The_Most_Points(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTMP\", \"def Most_Points\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/51", "question": "First, implement the **CE** class using the Python language. Then, write a public function called **Calculating_Expressions** in the **CE** class to calculate the arithmetic expression represented by a given string array called **tokens**, which represents the expression in Reverse Polish Notation. The function should calculate the expression and return an integer representing the value of the expression.", "test_list": ["assert candidate([\"2\",\"1\",\"+\",\"3\",\"*\"])==9", "assert candidate([\"4\",\"13\",\"5\",\"/\",\"+\"])==6", "assert candidate([\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"])==22"], "test_function": "def test_run(content1):\n    return CE().Calculating_Expressions(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CE\", \"def Calculating_Expressions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/52", "question": "First, implement the **RWO** class using the Python language. Then, write a public function called **Reverse_Word_Order** in the **RWO** class to solve the following problem.\nProblem: Given a string **s**, return the order of the words in the reversed string.", "test_list": ["assert candidate(\"the sky is blue\")==\"blue is sky the\"", "assert candidate(\"  hello world  \")==\"world hello\"", "assert candidate(\"a good   example\")==\"example good a\""], "test_function": "def test_run(content1):\n    return RWO().Reverse_Word_Order(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RWO\", \"def Reverse_Word_Order\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/53", "question": "First, implement the **NCS** class using the Python language. Then, write a public **non_empty_subarray** function in the **NCS** class to solve the following problem:\nProblem: Given an integer array **nums**, find the contiguous subarray with the maximum product (the subarray must contain at least one number) and return the product of that subarray.", "test_list": ["assert candidate([2,3,-2,4])==6", "assert candidate([-2,0,-1])==0"], "test_function": "def test_run(content1):\n    return NCS().non_empty_contiguous_subarray(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NCS\", \"def non_empty_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/54", "question": "First, implement the **PE** class using the Python language. Then, write a public function called **Peak_elements** in the **PE** class to solve the following problem:\nProblem: Given an integer array **nums**, find a peak element and return its index.\nA peak element is defined as an element that is strictly greater than its adjacent elements on the left and right.", "test_list": ["assert candidate([1,2,3,1])==2", "assert candidate([1,2,1,3,5,6,4])==1", "assert candidate([1,2,1,3,5,6,4])==5"], "test_function": "def test_run(content1):\n    return PE().Peak_elementes(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PE\", \"def Peak_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/55", "question": "First, implement the **TMDBAE** class using the Python language. Then, write a public function called **adjacent_elements** in the **TMDBAE** class to solve the following problem:\nProblem: Given an unordered array **nums**, return the maximum difference between adjacent elements after sorting the array. If the number of elements in the array is less than 2, return 0.", "test_list": ["assert candidate([3,6,9,1])==3", "assert candidate([10])==0"], "test_function": "def test_run(content1):\n    return TMDBAE().The_maximum_difference_between_adjacent_elements(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TMDBAE\", \"def adjacent_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/56", "question": "First, implement the **GME** class using the Python language. Then, write a public function called **get_most_elements** in the **GME** class to solve the following problem:\nProblem: Given an array **nums** of size **n**, return the majority element.\nThe majority element is the element that appears more than âŒŠn/2âŒ‹ times in the array.", "test_list": ["assert candidate([3,2,3])==3", "assert candidate([2,2,1,1,1,2,2])==2"], "test_function": "def test_run(content1):\n    return GME().get_most_elements(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GME\", \"def get_most_elements\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/57", "question": "First, implement the **GTNOTZ** class using the Python language. Then, write a public function called **get_trailing** within the **GTNOTZ** class to solve the following problem:\nProblem: Given an integer **n**, return the number of trailing zeros in the result of **n!**.", "test_list": ["assert candidate(3)==3", "assert candidate(5)==1"], "test_function": "def test_run(content1):\n    return GTNOTZ().get_the_number_of_trailing_zeros(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GTNOTZ\", \"def get_trailing\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/58", "question": "First, implement the **NNI** class using the Python language. Then, write a public function called **Non_negative_integers** in the **NNI** class to solve the following problem:\nProblem: Given a set of non-negative integers **nums**, rearrange the order of each number (without splitting any number) to form the largest possible integer.\nNote: The output result may be very large, so you need to return a string instead of an integer.", "test_list": ["assert candidate([10,2])==210", "assert candidate([3,30,34,5,9])==9534330"], "test_function": "def test_run(content1):\n    return NNI().Non_negative_integers(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class NNI\", \"def Non_negative_integers\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/59", "question": "First, implement the **IRSID** class using the Python language. Then, write a public function named **sequences_DNA** in the **IRSID** class to solve the following problem:\nProblem: DNA sequences are composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'. When studying DNA, it is useful to identify repetitive sequences in the DNA.\nGiven a string **s** representing a DNA sequence, return all the 10-letter sequences (substrings) that appear more than once in the DNA molecule.", "test_list": ["assert candidate([\"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"])==[\"AAAAACCCCC\",\"CCCCCAAAAA\"]", "assert candidate(\"AAAAAAAAAAAAA\")==[\"AAAAAAAAAA\"]"], "test_function": "def test_run(content1):\n    return IRSID().Identify_repetitive_sequences_in_DNA(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class IRSID\", \"def sequences_DNA\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/60", "question": "First, implement the **ERTTR** class using the Python language. Then, write a public function called **element_rotates** in the **ERTTR** class to solve the following problem:\nProblem: Given an integer array **nums**, rotate the elements in the array to the right by **k** positions and return the result.", "test_list": ["assert candidate([1,2,3,4,5,6,7],3)==[5,6,7,1,2,3,4]", "assert candidate([-1,-100,3,99],2)==[3,99,-1,-100]"], "test_function": "def test_run(content1,content2):\n    return ERTTR().element_rotates_to_the_right(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ERTTR\", \"def element_rotates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/61", "question": "First, implement the **ITBB** class using the Python language. Then, write a public function called **Invert_the_binary_bits** in the **ITBB** class to solve the following problem:\nProblem: Reverse the binary bits of a given 32-bit unsigned integer and return the unsigned integer result.", "test_list": ["assert candidate(00000010100101000001111010011100)==964176192", "assert candidate(11111111111111111111111111111101)==3221225471"], "test_function": "def test_run(content1):\n    return ITBB().Invert_the_binary_bits(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class ITBB\", \"def Invert_the_binary_bits\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/62", "question": "First, implement the **RTN** class using the Python language. Then, write a public function called **Hamming_weight** in the **RTN** class to solve the following problem:\nProblem: Write a function that takes an unsigned integer as input (in the form of a binary string) and returns the number of '1' digits in its binary representation (also known as the Hamming weight).", "test_list": ["assert candidate(00000000000000000000000000001011)==3", "assert candidate(00000000000000000000000010000000)==1", "assert candidate(11111111111111111111111111111101)==31"], "test_function": "def test_run(content1):\n    return RTN().Returns_the_number(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RTN\", \"def Hamming_weight\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/63", "question": "First, implement the **CTNOI** class using the Python language. Then, write a public function called **number_islands** in the **CTNOI** class to solve the following problem:\nProblem: Given a 2D grid consisting of '1' (land) and '0' (water), calculate the number of islands in the grid.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally and/or vertically.", "test_list": ["assert candidate([[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]])==1", "assert candidate([[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]])==3"], "test_function": "def test_run(content1):\n    return CTNOI().Calculate_the_number_of_islands(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CTNOI\", \"def number_islands\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/64", "question": "First, implement the **DABA** class using the Python language. Then, write a public function called **Digits_bitwise** in the **DABA** class to solve the following problem:\nProblem: Given two integers, **left** and **right**, representing the range [left, right], return the bitwise AND of all numbers in this range (including the endpoints **left** and **right**).", "test_list": ["assert candidate(5,7)==4", "assert candidate(0,0)==0", "assert candidate(1,2147483647)==0"], "test_function": "def test_run(content1,content2):\n    return DABA().Digits_are_bitwise_and(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DABA\", \"def Digits_bitwise\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/65", "question": "First, implement the **RV** class using the Python language. Then, write a public **Return_value** function in the **RV** class to solve the following problem:\nProblem: Given an integer **n**, return the count of prime numbers less than the non-negative integer **n**.", "test_list": ["assert candidate(10)==4", "assert candidate(0)==0", "assert candidate(1)==0"], "test_function": "def test_run(content1):\n    return RV().Return_value(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RV\", \"def Return_value\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/66", "question": "First, implement the **DIIII** class using Python language, then write a public function called **isomorphic** in the **DIIII** class to solve the following problem.\nProblem: Given two strings **s** and **t**, determine whether they are isomorphic. If the characters in **s** can be replaced by some mapping relationship to get **t**, then these two strings are isomorphic.", "test_list": ["assert candidate(\"egg\",\"add\")==True", "assert candidate(\"foo\", \"bar\")==False", "assert candidate(\"paper\",\"title\")==True"], "test_function": "def test_run(content1,content2):\n    return DIIII().Determine_if_it_is_isomorphic(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class DIIII\", \"def isomorphic\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/67", "question": "First, implement the **FTA** class using the Python language. Then, write a public function called **Find_the_array** in the **FTA** class to solve the following problem:\nProblem: Given an array of **n** positive integers and a positive integer **target**, find the length of the smallest contiguous subarray [numsl, numsl+1, ..., numsr-1, numsr] whose sum is greater than or equal to the target. If no such subarray exists, return 0.", "test_list": ["assert candidate(7, [2,3,1,2,4,3])==2", "assert candidate(4, [1,4,4])==1", "assert candidate(11, [1,1,1,1,1,1,1,1])==0"], "test_function": "def test_run(content1,content2):\n    return FTA().Find_the_array(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTA\", \"def Find_the_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/68", "question": "First, implement the **STPD** class using the Python language. Then, write a public function called **Shortest_Palindrome** in the **STPD** class to solve the following problem:\n\nProblem: Given a string **s**, convert it into a palindrome by adding characters at the beginning of the string. Find and return the shortest palindrome that can be obtained using this method.", "test_list": ["assert candidate(\"aacecaaa\")==\"aaacecaaa\"", "assert candidate(\"abcd\")==\"dcbabcd\""], "test_function": "def test_run(content1):\n    return STPD().Shortest_Palindrome(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STPD\", \"def Shortest_Palindrome\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/69", "question": "First, implement the **RTLE** class using the Python language. Then, write a public function **largest_element** in the **RTLE** class to solve the following problem:\nProblem: Given an integer array **nums** and an integer **k**, return the k-th largest element in the array.", "test_list": ["assert candidate([3,2,1,5,6,4],2)==5", "assert candidate([3,2,3,1,2,4,5,5,6],4)==4"], "test_function": "def test_run(content1,content2):\n    return RTLE().Returns_the_largest_element(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class RTLE\", \"def largest_element\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/70", "question": "First, implement the **GTAC** class using the Python language. Then, write a public function called **additive_combination** in the **GTAC** class to solve the following problem:\n\nProblem: Find all combinations of **k** numbers that add up to **n**, satisfying the following conditions:\n1. Only use numbers from 1 to 9.\n2. Each number can only be used once.\nReturn a list of all possible valid combinations.", "test_list": ["assert candidate(3,7)==[[1,2,4]]", "assert candidate(3,9)==[[1,2,6], [1,3,5], [2,3,4]]", "assert candidate(4,1)==[]"], "test_function": "def test_run(content1,content2):\n    return GTAC().Get_the_additive_combination(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GTAC\", \"def additive_combination\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/71", "question": "First, implement the **JTA** class using the Python language. Then, write a public function called **judging_the_array** in the **JTA** class to solve the following problem:\nProblem: Given an integer array **nums**, return True if any value appears at least twice in the array, and False if every element in the array is distinct.", "test_list": ["assert candidate([1,2,3,1])==True", "assert candidate([1,2,3,4])==False", "assert candidate([1,1,1,3,3,4,3,2,4,2])==True"], "test_function": "def test_run(content1):\n    return JTA().Judging_the_array(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JTA\", \"def Judging_the_array\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/72", "question": "First, implement the **JI** class using the Python language. Then, write a public function called **Judgment_Index** in the **JI** class to solve the following problem:\nProblem: Given an integer array **nums** and an integer **k**, determine if there are two distinct indices **i** and **j** in the array such that nums[i] == nums[j] and abs(i - j) <= k. If such indices exist, return True; otherwise, return False.", "test_list": ["assert candidate([1,2,3,1])==3", "assert candidate([1,0,1,1])==1", "assert candidate([1,2,3,1,2,3])==2"], "test_function": "def test_run(content1):\n    return JI().Judgment_Index(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class JI\", \"def Judgment_Index\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/73", "question": "First, implement the **AC** class using the Python language. Then, write a public function called **Array_conditions** in the **AC** class to solve the following problem:\nProblem: Given an integer array **nums** and two integers **indexDiff** and **valueDiff**, find the index pair (i, j) that satisfies the following conditions:\n1. i != j;\n2. abs(i - j) <= indexDiff;\n3. abs(nums[i] - nums[j]) <= valueDiff.\n\nIf such a pair exists, return True; otherwise, return False.", "test_list": ["assert candidate([1,2,3,1],3,0)==True", "assert candidate([1,5,9,1,5,9],2,3)==False"], "test_function": "def test_run(content1,content2,content3):\n    return AC().Array_conditions(content1,content2,content3)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class AC\", \"def Array_conditions\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/74", "question": "First, implement the **FTLS** class using the Python language. Then, write a public function called **largest_square** in the **FTLS** class to solve the following problem:\nProblem: Given a 2D matrix consisting of '0' and '1', find the largest square that contains only '1' and return its area.", "test_list": ["assert candidate([[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]])==4", "assert candidate([[\"0\",\"1\"],[\"1\",\"0\"]])==1", "assert candidate([[\"0\"]])==0"], "test_function": "def test_run(content1):\n    return FTLS().Find_the_largest_square(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTLS\", \"def largest_square\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/75", "question": "First, implement the **CTMA** class using the Python language. Then, write a public function called **matrix_area** in the **CTMA** class to solve the following problem:\nProblem: Given two rectangles on a two-dimensional plane, each formed by lines parallel/vertical to the coordinate axes, calculate and return the total area covered by the two rectangles. Each rectangle is defined by the coordinates of its bottom-left vertex and top-right vertex:\n1. The first rectangle is defined by its bottom-left vertex (ax1, ay1) and top-right vertex (ax2, ay2).\n2. The second rectangle is defined by its bottom-left vertex (bx1, by1) and top-right vertex (bx2, by2).", "test_list": ["assert candidate(-3,0,3,4,0,-1,9,2)==45", "assert candidate(-2,-2,2,2,-2,-2,2,2)==16"], "test_function": "def test_run(content1,content2,content3,content4,content5,content6,content7,content8):\n    return CTMA().Calculate_the_matrix_area(content1,content2,content3,content4,content5,content6,content7,content8)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class CTMA\", \"def matrix_area\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/76", "question": "First, implement the **TAC** class using the Python language. Then, write a public function named **The_array_contains** in the **TAC** class to solve the following problem:\nProblem: Given a sorted integer array **nums** with no duplicate elements, return a list of the smallest sorted range intervals that exactly cover all the numbers in the array. In other words, each element in **nums** should be covered by exactly one range interval, and there should be no number **x** that belongs to a range interval but not to **nums**. Each range interval [a, b] in the list should be output in the following format:\n1. **a->b** if a != b;\n2. **a** if a == b.", "test_list": ["assert candidate([0,1,2,4,5,7])==[\"0->2\",\"4->5\",\"7\"]", "assert candidate([0,2,3,4,6,8,9])==[\"0\",\"2->4\",\"6\",\"8->9\"]"], "test_function": "def test_run(content1):\n    return TAC().The_array_contains(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class TAC\", \"def The_array_contains\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/77", "question": "First, implement the **GTAC** class using the Python language. Then, write a public function called **array_count** in the **GTAC** class to solve the following problem:\nProblem: Given an integer array of size **n**, find all elements that appear more than âŒŠn/3âŒ‹ times.", "test_list": ["assert candidate([3,2,3])==[3]", "assert candidate([1])==[1]", "assert candidate([1,2])==[1,2]"], "test_function": "def test_run(content1):\n    return GTAC().Get_the_array_count(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class GTAC\", \"def array_count\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/78", "question": "Question: Given an integer **n**, please find and return the n-th ugly number.\nPlease design a **ULYNB** class in Python language based on the above question. The class should have an instance attribute **n**, a private function **private_ugly_number**, and a public function **public_ugly_number**. In the private function **private_ugly_number**, find the n-th ugly number based on the instance attribute **n**. Finally, in the public function **public_ugly_number**, call the private function **private_ugly_number** and return the result.", "test_list": ["assert candidate(10)==12", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return ULYNB(content1).public_ugly_number()", "entry_point": "test_run", "test_matching": "assert candidate([['class ULYNB', 'def _private_ugly_number', 'def public_ugly_number'], ['class ULYNB', 'def __private_ugly_number', 'def public_ugly_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/79", "question": "First, design a **NAR** class using Python language, which has instance attributes **nums**, a private function **private_Number_array**, and a public function **public_Number_array**. Then, in the private function **private_Number_array**, return the numbers in the range [0, n] that do not appear in the array **nums**. Finally, in the public function **public_Number_array**, call the private function **private_Number_array** to return the result.", "test_list": ["assert candidate([3,0,1])==2", "assert candidate([0,1])==2", "assert candidate([9,6,4,2,3,5,7,0,1])==8", "assert candidate([0])==1"], "test_function": "def test_run(content1):\n    return NAR(content1).public_Number_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class NAR', 'def _private_Number_array', 'def public_Number_array'], ['class NAR', 'def __private_Number_array', 'def public_Number_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/80", "question": "First, design an **ERS** class using the Python language. The class should have an instance attribute called **num**, a private function called **private_rep**, and a public function called **public_rep**. In the private function **private_rep**, convert the non-negative integer **num** into its corresponding English representation. Finally, in the public function **public_rep**, call the private function **private_rep** and return the result.", "test_list": ["assert candidate(123)==\"One Hundred Twenty Three\"", "assert candidate(12345)==\"Twelve Thousand Three Hundred Forty Five\"", "assert candidate(1234567)==\"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\""], "test_function": "def test_run(content1):\n    return ERS(content1).public_English_representation()", "entry_point": "test_run", "test_matching": "assert candidate([['class ERS', 'def _private_rep', 'def public_rep'], ['class ERS', 'def __private_rep', 'def public_rep']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/81", "question": "First, design a **PCT** class using the Python language. The class should have instance attribute **citations**, a private function **private_Paper_cited**, and a public function **public_Paper_cited**. In the private function **private_Paper_cited**, which takes an integer array **citations** representing the number of times the researcher's i-th paper has been cited, return the researcher's h-index. Finally, in the public function **public_Paper_cited**, call the private function **private_Paper_cited** and return the result.", "test_list": ["assert candidate([3,0,6,1,5])==3", "assert candidate([1,3,1])==1"], "test_function": "def test_run(content1):\n    return PCT(content1).public_Paper_cited()", "entry_point": "test_run", "test_matching": "assert candidate([['class PCT', 'def _private_Paper_cited', 'def public_Paper_cited'], ['class PCT', 'def __private_Paper_cited', 'def public_Paper_cited']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/82", "question": "Question: Given an integer array **citations**, where citations[i] represents the number of times the i-th paper of a researcher has been cited, and **citations** are already sorted in ascending order. Calculate and return the researcher's h-index.\nPlease design an **AOD** class using Python language, which has an instance attribute **citations**, a private function **private_Paper_cited**, and a public function **public_ascend_order**. In the private function **private_Paper_cited**, return the researcher's h-index. Finally, in the public function **public_ascend_order**, call the private function **private_Paper_cited** and return the result.", "test_list": ["assert candidate([0,1,3,5,6])==3", "assert candidate([1,2,100])==2"], "test_function": "def test_run(content1):\n    return AOD(content1).public_ascend_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class AOD', 'def _private_ascend_order', 'def public_ascend_order'], ['class AOD', 'def __private_ascend_order', 'def public_ascend_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/83", "question": "First, design a class named **MQT** using the Python language. The class should have an instance attribute **n**, a private function named **private_Minimum_quantity**, and a public function named **public_Minimum_quantity**. In the private function **private_Minimum_quantity**, return the minimum number of perfect squares that add up to the integer **n**. Finally, in the public function **public_Minimum_quantity**, call the private function **private_Minimum_quantity** and return the result.", "test_list": ["assert candidate(12)==3", "assert candidate(13)==2"], "test_function": "def test_run(content1):\n    return MQT(content1).public_Minimum_quantity()", "entry_point": "test_run", "test_matching": "assert candidate([['class MQT', 'def _private_Minimum_quantity', 'def public_Minimum_quantity'], ['class MQT', 'def __private_Minimum_quantity', 'def public_Minimum_quantity']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/84", "question": "Question: Given a string **num** that only contains digits 0-9, add binary operators (+, -, *) between the digits to form expressions. Return all the expressions that evaluate to the target integer **target**. \nPlease design a **BOT** class in Python, which has instance attributes **num** and **target**, a private function **private_Binary_operator**, and a public function **public_Binary_operator**. The private function **private_Binary_operator** should return all the expressions that evaluate to the target integer. Finally, the public function **public_Binary_operator** should call the private function **private_Binary_operator** and return the result.", "test_list": ["assert candidate(\"123\",6)==[\"1+2+3\", \"1*2*3\"]", "assert candidate(\"232\",8)==[\"2*3+2\", \"2+3*2\"]", "assert candidate(\"3456237490\",9191)==[]"], "test_function": "def test_run(content1,content2):\n    return BOT(content1,content2).public_Binary_operator()", "entry_point": "test_run", "test_matching": "assert candidate([['class BOT', 'def _private_Binary_operator', 'def public_Binary_operator'], ['class BOT', 'def __private_Binary_operator', 'def public_Binary_operator']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/85", "question": "First, design a **ROE** class using the Python language. The class should have an instance attribute called **nums**, a private function called **private_relative_order**, and a public function called **public_relative_order**. In the private function **private_relative_order**, move all the zeros in the array **nums** to the end while maintaining the relative order of the non-zero elements. Finally, in the public function **public_relative_order**, call the private function **private_relative_order** and return the result.", "test_list": ["assert candidate([0,1,0,3,12])==[1,3,12,0,0]", "assert candidate([0])==[0]"], "test_function": "def test_run(content1):\n    return ROE(content1).public_relative_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class ROE', 'def _private_relative_order', 'def public_relative_order'], ['class ROE', 'def _private_relative_order', 'def public_relative_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/86", "question": "Question: Given an array **nums** containing n + 1 integers, where the numbers are within the range [1, n] (including 1 and n), it is known that at least one integer is duplicated. Assuming that **nums** only has one duplicated integer, return this duplicated number.\nPlease use Python to first design a class **NDC**, with an instance attribute **nums**, a private function **private_Number_duplicates**, and a public function **public_Number_duplicates**. Then, in the private function **private_Number_duplicates**, return this duplicated number. Finally, in the public function **public_Number_duplicates**, call the private function **private_Number_duplicates** to return the result.", "test_list": ["assert candidate([1,3,4,2,2])==2", "assert candidate([3,1,3,4,2])==3"], "test_function": "def test_run(content1):\n    return NDC(content1).public_Number_duplicates()", "entry_point": "test_run", "test_matching": "assert candidate([['class NDC', 'def _private_Number_duplicates', 'def public_Number_duplicates'], ['class NDC', 'def __private_Number_duplicates', 'def public_Number_duplicates']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/87", "question": "Firstly, design an **LSQ** class using Python language, which has an instance attribute **nums**, a private function **private_Longest_subsequence**, and a public function **public_Longest_subsequence**. Then, in the private function **private_Longest_subsequence**, return the length of the longest strictly increasing subsequence in the instance attribute integer array **nums**. Finally, in the public function **public_Longest_subsequence**, call the private function **private_Longest_subsequence** to return the result.", "test_list": ["assert candidate([10,9,2,5,3,7,101,18])==4", "assert candidate([0,1,0,3,2,3])==4", "assert candidate([7,7,7,7,7,7,7])==1"], "test_function": "def test_run(content1):\n    return LSQ(content1).public_Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class LSQ', 'def _private_Longest_subsequence', 'def public_Longest_subsequence'], ['class LSQ', 'def __private_Longest_subsequence', 'def public_Longest_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/88", "question": "Question: Given a string 's' composed of several brackets and letters, delete the minimum number of invalid brackets to make the input string valid, and return all possible results.\nPlease use Python language to first design a 'VSR' class, with an instance attribute 's', a private function 'private_Valid_string', and a public function 'public_Valid_string'. Then, in the private function 'private_Valid_string', return all possible results of the above problem. Finally, call the private function 'private_Valid_string' in the public function 'public_Valid_string' to return the results.", "test_list": ["assert candidate(\"()())()\")==[\"(())()\",\"()()()\"]", "assert candidate(\"(a)())()\")==[\"(a())()\",\"(a)()()\"]", "assert candidate(\")(\")==[\"\"]"], "test_function": "def test_run(content1):\n    return VSR(content1).public_Valid_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class VSR', 'def _private_Valid_string', 'def public_Valid_string'], ['class VSR', 'def __private_Valid_string', 'def public_Valid_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/89", "question": "Question: An accumulative number is a string, the numbers that make up it can form an accumulative sequence. A valid accumulative sequence must contain at least 3 numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of its previous two numbers. Given a string **s** that only contains digits '0'-'9', write an algorithm to determine whether the given input is an accumulative number. If it is, return True; otherwise, return False.\nPlease use Python language to first design an **ANB** class, which has an instance attribute **s**, a private function **private_Accumulated_number**, and a public function **public_Accumulated_number**; then in the private function **private_Accumulated_number**, determine whether the instance attribute **s** is an accumulative number, if it is, return True; otherwise, return False; finally, in the public function **public_Accumulated_number**, call the private function **private_Accumulated_number** to return the result.", "test_list": ["assert candidate(\"112358\")==True", "assert candidate(\"199100199\")==True"], "test_function": "def test_run(content1):\n    return ANB(content1).public_Accumulated_number()", "entry_point": "test_run", "test_matching": "assert candidate([['class ANB', 'def _private_Accumulated_number', 'def public_Accumulated_number'], ['class ANB', 'def __private_Accumulated_number', 'def public_Accumulated_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/90", "question": "Firstly, design an **MCS** class using the Python language, which has an instance attribute **nums**, a private function **private_Maximum_coins**, and a public function **public_Maximum_coins**. Then, implement the following problem in the private function **private_Maximum_coins**. Finally, call the private function **private_Maximum_coins** in the public function **public_Maximum_coins** to return the result.\nProblem: Given **n** balloons each marked with a number from 0 to n-1, these numbers are stored in the array **nums**. You need to burst all the balloons. If you burst the i-th balloon, you can get nums[i-1]*nums[i]*nums[i+1] coins. Return the maximum number of coins that can be obtained.", "test_list": ["assert candidate([3,1,5,8])==167", "assert candidate([1,5])==10"], "test_function": "def test_run(content1):\n    return MCS(content1).public_Maximum_coins()", "entry_point": "test_run", "test_matching": "assert candidate([['class MCS', 'def _private_Maximum_coins', 'def public_Maximum_coins'], ['class MCS', 'def __private_Maximum_coins', 'def public_Maximum_coins']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/91", "question": "Firstly, design a **SNE** class using Python language, which has instance attributes **n** and **primes**, a private function **private_Super_Number**, and a public function **public_Super_Number**. Then, return the nth super ugly number in the private function **private_Super_Number**. Finally, call the private function **private_Super_Number** in the public function **public_Super_Number** to return the result.", "test_list": ["assert candidate(12,[2,7,13,19])==32", "assert candidate(1,[2,3,5])==1"], "test_function": "def test_run(content1,content2):\n    return SNE(content1,content2).public_Super_Number()", "entry_point": "test_run", "test_matching": "assert candidate([['class SNE', 'def _private_Super_Number', 'def public_Super_Number'], ['class SNE', 'def __private_Super_Number', 'def public_Super_Number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/92", "question": "Firstly, design an **IAA** class using the Python language, which has an instance attribute **nums**, a private function **private_Integer_array**, and a public function **public_Integer_array**. Then, in the private function **private_Integer_array**, return a new array **counts** with the requirement that the value of counts[i] is the number of elements to the right of nums[i] that are less than nums[i]. Finally, call the private function **private_Integer_array** in the public function **public_Integer_array** to return the result.", "test_list": ["assert candidate([5,2,6,1])==[2,1,1,0]", "assert candidate([-1])==[0]", "assert candidate([-1,-1])==[0,0]"], "test_function": "def test_run(content1):\n    return IAA(content1).public_Integer_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class IAA', 'def _private_Integer_array', 'def public_Integer_array'], ['class IAA', 'def __private_Integer_array', 'def public_Integer_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/93", "question": "Firstly, design a **DMM** class using Python language, which has an instance attribute **s**, a private function **private_Dictionary_minimum**, and a public function **public_Dictionary_minimum**. Then, in the private function **private_Dictionary_minimum**, remove the duplicate letters in the string **s** so that each letter only appears once, and return the result with the smallest lexicographic order. Finally, in the public function **public_Dictionary_minimum**, call the private function **private_Dictionary_minimum** to return the result.", "test_list": ["assert candidate(\"bcabc\")==\"abc\"", "assert candidate(\"cbacdcbc\")==\"acdb\""], "test_function": "def test_run(content1):\n    return DMM(content1).public_Dictionary_minimum()", "entry_point": "test_run", "test_matching": "assert candidate([['class DMM', 'def _private_Dictionary_minimum', 'def public_Dictionary_minimum'], ['class DMM', 'def __private_Dictionary_minimum', 'def public_Dictionary_minimum']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/94", "question": "Firstly, design a **CLS** class using the Python language, which has an instance attribute **words**, a private function **private_Common_letters**, and a public function **public_Common_letters**. Then, in the private function **private_Common_letters**, return the maximum value of length(words[i])*length(words[j]). Finally, in the public function **public_Common_letters**, call the private function **private_Common_letters** to return the result.", "test_list": ["assert candidate([\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"])==16", "assert candidate([\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"])==4", "assert candidate([\"a\",\"aa\",\"aaa\",\"aaaa\"])==0"], "test_function": "def test_run(content1):\n    return CLS(content1).public_Common_letters()", "entry_point": "test_run", "test_matching": "assert candidate([['class CLS', 'def _private_Common_letters', 'def public_Common_letters'], ['class CLS', 'def __private_Common_letters', 'def public_Common_letters']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/95", "question": "Firstly, design a class named **ROD** using Python language, which has instance attributes **nums1**, **nums2**, and **k**, a private function **private_relative_order**, and a public function **public_relative_order**. Then, implement the following problem in the private function **private_relative_order**. Finally, call the private function **private_relative_order** in the public function **public_relative_order** to return the result.\nProblem: Select **k** (k<=m+n) numbers from two given arrays of length **m** and **n** respectively to form a new number. The numbers taken from the same array should maintain their relative order in the original array. Return an array of length **k** representing the maximum number.", "test_list": ["assert candidate([3, 4, 6, 5],[9, 1, 2, 5, 8, 3],5)==[9, 8, 6, 5, 3]", "assert candidate([6, 7],[6, 0, 4],5)==[6, 7, 6, 0, 4]", "assert candidate([3, 9],[8, 9],3)==[9, 8, 9]"], "test_function": "def test_run(content1,content2,content3):\n    return ROD(content1,content2,content3).public_relative_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class ROD', 'def _private_relative_order', 'def public_relative_order'], ['class ROD', 'def __private_relative_order', 'def public_relative_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/96", "question": "Firstly, design a **TAU** class using Python language, which has instance attributes **coins** and **amount**, a private function **private_Total_amount**, and a public function **public_Total_amount**. Then, in the private function **private_Total_amount**, provide an integer array **coins** representing different denominations of coins and an integer **amount** representing the total amount, and return the minimum number of coins required to make up the total amount. Finally, call the private function **private_Total_amount** in the public function **public_Total_amount** to return the result.", "test_list": ["assert candidate([1, 2, 5],11)==3", "assert candidate([2],3)==-1", "assert candidate([1],0)==0"], "test_function": "def test_run(content1,content2):\n    return TAU(content1,content2).public_Total_amount()", "entry_point": "test_run", "test_matching": "assert candidate([['class TAU', 'def _private_Total_amount', 'def public_Total_amount'], ['class TAU', 'def __private_Total_amount', 'def public_Total_amount']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/97", "question": "Firstly, design a **ROR** class using Python language, which has an instance attribute **nums**, a private function **private_Rearranged_order**, and a public function **public_Rearranged_order**. Then, in the private function **private_Rearranged_order**, rearrange the integer array **nums** into the order of nums[0]<nums[1]>nums[2]<nums[3]... Finally, call the private function **private_Rearranged_order** in the public function **public_Rearranged_order** to return the result.", "test_list": ["assert candidate([1,5,1,1,6,4])==[1,6,1,5,1,4]", "assert candidate([1,3,2,2,3,1])==[2,3,1,3,1,2]"], "test_function": "def test_run(content1):\n    return ROR(content1).public_Rearranged_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class ROR', 'def _private_Rearranged_order', 'def public_Rearranged_order'], ['class ROR', 'def __private_Rearranged_order', 'def public_Rearranged_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/98", "question": "Firstly, design an **IAN** class using the Python language, which has instance attributes **nums**, **lower**, and **upper**, a private function **private_Interval_and**, and a public function **public_Interval_and**. Then, in the private function **private_Interval_and**, return the count of interval sums within the range [lower, upper] (inclusive of **lower** and **upper**) from the integer array **nums**. Finally, in the public function **public_Interval_and**, call the private function **private_Interval_and** to return the result.", "test_list": ["assert candidate([-2,5,-1],-2,2)==3", "assert candidate([0],0,0)==1"], "test_function": "def test_run(content1,content2,content3):\n    return IAN(content1,content2,content3).public_Interval_and()", "entry_point": "test_run", "test_matching": "assert candidate([['class IAN', 'def _private_Interval_and', 'def public_Interval_and'], ['class IAN', 'def __private_Interval_and', 'def public_Interval_and']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/99", "question": "Firstly, design a class named **LIM** using Python language, which has an instance attribute **matrix**, a private function **private_Longest_Incremental**, and a public function **public_Longest_Incremental**. Then, in the private function **private_Longest_Incremental**, return the length of the longest incremental path in the given m x n integer **matrix**. Finally, call the private function **private_Longest_Incremental** in the public function **public_Longest_Incremental** to return the result.", "test_list": ["assert candidate([[9,9,4],[6,6,8],[2,1,1]])==4", "assert candidate([[3,4,5],[3,2,6],[2,2,1]])==4", "assert candidate([[1]])==1"], "test_function": "def test_run(content1):\n    return LIM(content1).public_Longest_Incremental()", "entry_point": "test_run", "test_matching": "assert candidate([['class LIM', 'def _private_Longest_Incremental', 'def public_Longest_Incremental'], ['class LIM', 'def __private_Longest_Incremental', 'def public_Longest_Incremental']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/100", "question": "Question: Given a sorted array of positive integers **nums**, and a positive integer **n**. Select any number from the interval [1, n] to supplement to **nums**, so that any number in the interval [1, n] can be represented by the sum of several numbers in **nums**. Please return the minimum number of numbers that need to be supplemented to meet the above requirements.\nPlease use Python language to design an **NDT** class first, with instance attributes **nums** and **n**, a private function **private_Number_digits**, and a public function **public_Number_digits**; then return the minimum number of numbers that need to be supplemented in the private function **private_Number_digits**; finally, call the private function **private_Number_digits** in the public function **public_Number_digits** to return the result.", "test_list": ["assert candidate([1,3],6)==1", "assert candidate([1,5,10],20)==2", "assert candidate([1,2,2],5)==0"], "test_function": "def test_run(content1,content2):\n    return NDT(content1,content2).public_Number_digits()", "entry_point": "test_run", "test_matching": "assert candidate([['class NDT', 'def _private_Number_digits', 'def public_Number_digits'], ['class NDT', 'def __private_Number_digits', 'def public_Number_digits']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/101", "question": "Question: Given an integer array **nums**, determine whether there exists a length-3 increasing subsequence in this array. If there exists such a triplet index (i, j, k) and satisfies i < j < k, such that nums[i] < nums[j] < nums[k], return True; otherwise, return False.\nPlease use Python language to first design a **LSU** class, with instance attribute **nums**, private function **private_Longest_subsequence** and public function **public_Longest_subsequence**; then in the private function **private_Longest_subsequence**, determine whether there exists a length-3 increasing subsequence in the integer array **nums**, if it exists, return True; otherwise, return False; finally, in the public function **public_Longest_subsequence**, call the private function **private_Longest_subsequence** to return the result.", "test_list": ["assert candidate([1,2,3,4,5])==True", "assert candidate([5,4,3,2,1])==False", "assert candidate([2,1,5,0,4,6])==True"], "test_function": "def test_run(content1):\n    return LSU(content1).public_Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class LSU', 'def _private_Longest_subsequence', 'def public_Longest_subsequence'], ['class LSU', 'def __private_Longest_subsequence', 'def public_Longest_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/102", "question": "Firstly, design a class **CVA** using the Python language, which has an instance attribute **distance**, a private function **private_Counterclockwise_variation**, and a public function **public_Counterclockwise_variation**. Then, implement the following problem in the private function **private_Counterclockwise_variation**. Finally, call the private function **private_Counterclockwise_variation** in the public function **public_Counterclockwise_variation** to return the result.\n\nProblem: Given an integer array **distance**. Starting from the point (0,0) on the X-Y plane, each time a move is made with a counterclockwise change in direction, determine whether the path crossed. If it intersects, return True; otherwise, return False.", "test_list": ["assert candidate([2,1,1,2])==True", "assert candidate([1,2,3,4])==False", "assert candidate([1,1,1,1])==True"], "test_function": "def test_run(content1):\n    return CVA(content1).public_Counterclockwise_variation()", "entry_point": "test_run", "test_matching": "assert candidate([['class CVA', 'def _private_Counterclockwise_variation', 'def public_Counterclockwise_variation'], ['class CVA', 'def __private_Counterclockwise_variation', 'def public_Counterclockwise_variation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/103", "question": "Firstly, design a **USI** class using Python language, which has an instance attribute **words**, a private function **private_Unique_String**, and a public function **public_Unique_String**. Then, in the private function **private_Unique_String**, return an array of strings from **words** that satisfy the palindrome pair condition, which is composed of unique strings in a 0-indexed array. Finally, call the private function **private_Unique_String** in the public function **public_Unique_String** to return the result.", "test_list": ["assert candidate([\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"])==[[0,1],[1,0],[3,2],[2,4]]", "assert candidate([\"bat\",\"tab\",\"cat\"])==[[0,1],[1,0]]", "assert candidate([\"a\",\"\"])==[[0,1],[1,0]]"], "test_function": "def test_run(content1):\n    return USI(content1).public_Unique_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class USI', 'def _private_Unique_String', 'def public_Unique_String'], ['class USI', 'def __private_Unique_String', 'def public_Unique_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/104", "question": "Firstly, design a **PMM** class using Python language, which has an instance attribute **n**, a private function **private_Product_maximization**, and a public function **public_Product_maximization**. Then, in the private function **private_Product_maximization**, decompose the positive integer **n** into the sum of **k** positive integers (k>=2), and maximize the product of these integers, returning the maximum product that can be obtained. Finally, call the private function **private_Product_maximization** in the public function **public_Product_maximization** to return the result.", "test_list": ["assert candidate(2)==1", "assert candidate(10)==36"], "test_function": "def test_run(content1):\n    return PMM(content1).public_Product_maximization()", "entry_point": "test_run", "test_matching": "assert candidate([['class PMM', 'def _private_Product_maximization', 'def public_Product_maximization'], ['class PMM', 'def __private_Product_maximization', 'def public_Product_maximization']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/105", "question": "Firstly, design an **RSI** class using Python language, which has an instance attribute **s**, a private function **private_Result_String**, and a public function **public_Result_String**. Then, in the private function **private_Result_String**, reverse all the vowel letters in the string **s** and return the result string. Finally, in the public function **public_Result_String**, call the private function **private_Result_String** to return the result.", "test_list": ["assert candidate(\"hello\")==\"holle\"", "assert candidate(\"leetcode\")==\"leotcede\""], "test_function": "def test_run(content1):\n    return RSI(content1).public_Result_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class RSI', 'def _private_Result_String', 'def public_Result_String'], ['class RSI', 'def __private_Result_String', 'def public_Result_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/106", "question": "Firstly, design an **AOER** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Any_order**, and a public function **public_Any_order**. Then, in the private function **private_Any_order**, return the top k most frequent elements in the integer array **nums**. Finally, in the public function **public_Any_order**, call the private function **private_Any_order** to return the result.", "test_list": ["assert candidate([1,1,1,2,2,3],2)==[1,2]", "assert candidate([1],1)==[1]"], "test_function": "def test_run(content1,content2):\n    return AOER(content1,content2).public_Any_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class AOER', 'def _private_Any_order', 'def public_Any_order'], ['class AOER', 'def __private_Any_order', 'def public_Any_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/107", "question": "First, design a **TIE** class using the Python language, which has instance attributes **nums1** and **nums2**, a private function **private_Their_intersection**, and a public function **public_Their_intersection**. Then, in the private function **private_Their_intersection**, return the intersection between the arrays **nums1** and **nums2**. Finally, in the public function **public_Their_intersection**, call the private function **private_Their_intersection** to return the result.", "test_list": ["assert candidate([1,2,2,1],[2,2])==[2]", "assert candidate([4,9,5],[9,4,9,8,4])==[9,4]"], "test_function": "def test_run(content1,content2):\n    return TIE(content1,content2).public_Their_intersection()", "entry_point": "test_run", "test_matching": "assert candidate([['class TIE', 'def _private_Their_intersection', 'def public_Their_intersection'], ['class TIE', 'def __private_Their_intersection', 'def public_Their_intersection']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/108", "question": "Question: Given two integer arrays **nums1** and **nums2**, please return the intersection of the two arrays in the form of an array. The number of times each element appears in the return result should be consistent with the number of times the element appears in both arrays (if the number of appearances is inconsistent, consider taking the smaller value).\nUsing Python language, first design an **ORU** class, which has instance attributes **nums1** and **nums2**, a private function **private_Order_results**, and a public function **public_Order_results**. Then, implement the above problem in the private function **private_Order_results**. Finally, call the private function **private_Order_results** in the public function **public_Order_results** to return the result.", "test_list": ["assert candidate([1,2,2,1],[2,2])==[2,2]", "assert candidate([4,9,5],[9,4,9,8,4])==[4,9]"], "test_function": "def test_run(content1,content2):\n    return ORU(content1,content2).public_Order_results()", "entry_point": "test_run", "test_matching": "assert candidate([['class ORU', 'def _private_Order_results', 'def public_Order_results'], ['class ORU', 'def __private_Order_results', 'def public_Order_results']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/109", "question": "Firstly, design an **RDL** class using the Python language, which has an instance attribute **envelopes**, a private function **private_Russian_dolls**, and a public function **public_Russian_dolls**. Then, implement the following problem in the private function **private_Russian_dolls**. Finally, call the private function **private_Russian_dolls** in the public function **public_Russian_dolls** to return the result.\nProblem: Given a two-dimensional integer array envelopes[i]=[w_i,h_i] representing the width and height of the i-th envelope, return the maximum number of envelopes that can form a set of **Russian nesting dolls**.", "test_list": ["assert candidate([[5,4],[6,4],[6,7],[2,3]])==3", "assert candidate([[1,1],[1,1],[1,1]])==1"], "test_function": "def test_run(content1):\n    return RDL(content1).public_Russian_dolls()", "entry_point": "test_run", "test_matching": "assert candidate([['class RDL', 'def _private_Russian_dolls', 'def public_Russian_dolls'], ['class RDL', 'def __private_Russian_dolls', 'def public_Russian_dolls']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/110", "question": "Firstly, design an **NDE** class using Python language, which has an instance attribute **n**, a private function **private_Numbers_different**, and a public function **public_Numbers_different**. Then, implement the following problem in the private function **private_Numbers_different**. Finally, call the private function **private_Numbers_different** in the public function **public_Numbers_different** to return the result.\nProblem: Given an integer **n**, you need to return the count of numbers **x** where all digits are different, and 0<=x<10^n.", "test_list": ["assert candidate(2)==91", "assert candidate(0)==1"], "test_function": "def test_run(content1):\n    return NDE(content1).public_Numbers_different()", "entry_point": "test_run", "test_matching": "assert candidate([['class NDE', 'def _private_Numbers_different', 'def public_Numbers_different'], ['class NDE', 'def __private_Numbers_different', 'def public_Numbers_different']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/111", "question": "Firstly, design a class named **MVL** using Python language, which has instance attributes **matrix** and **k**, a private function **private_Maximum_value**, and a public function **public_Maximum_value**. Then, in the private function **private_Maximum_value**, return the maximum sum of values within the rectangular area of the m x n **matrix** that does not exceed **k**. Finally, in the public function **public_Maximum_value**, call the private function **private_Maximum_value** to return the result.", "test_list": ["assert candidate([[1,0,1],[0,-2,3]],2)==2", "assert candidate([[2,2,-1]],3)==3"], "test_function": "def test_run(content1,content2):\n    return MVL(content1,content2).public_Maximum_value()", "entry_point": "test_run", "test_matching": "assert candidate([['class MVL', 'def _private_Maximum_value', 'def public_Maximum_value'], ['class MVL', 'def __private_Maximum_value', 'def public_Maximum_value']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/112", "question": "Firstly, design a **DSS** class using Python language, which has an instance attribute **nums**, a private function **private_Divisible_subset**, and a public function **public_Divisible_subset**. Then, in the private function **private_Divisible_subset**, given a set **nums** composed of non-repetitive positive integers, return the largest divisible subset **answer**. Finally, in the public function **public_Divisible_subset**, call the private function **private_Divisible_subset** to return the result.", "test_list": ["assert candidate([1,2,3])==[1,2]", "assert candidate([1,2,4,8])==[1,2,4,8]"], "test_function": "def test_run(content1):\n    return DSS(content1).public_Divisible_subset()", "entry_point": "test_run", "test_matching": "assert candidate([['class DSS', 'def _private_Divisible_subset', 'def public_Divisible_subset'], ['class DSS', 'def __private_Divisible_subset', 'def public_Divisible_subset']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/113", "question": "Question: Calculate **a^b mod 1337**, where **a** is a positive integer and **b** is a very large positive integer given in the form of an array.\nUse Python language to first design a **PIT** class, with instance attributes **a** and **b**, a private function **private_positive_integer**, and a public function **public_positive_integer**. Then, calculate the above problem in the private function **private_positive_integer**. Finally, call the private function **private_positive_integer** in the public function **public_positive_integer** to return the result.", "test_list": ["assert candidate(2,[3])==8", "assert candidate(2,[1,0])==1024", "assert candidate(1,[4,3,3,8,5,2])==1", "assert candidate(2147483647,[2,0,0])==1198"], "test_function": "def test_run(content1,content2):\n    return PIT(content1,content2).public_positive_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class PIT', 'def _private_positive_integer', 'def public_positive_integer'], ['class PIT', 'def __private_positive_integer', 'def public_positive_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/114", "question": "Question: Given two integer arrays **nums1** and **nums2** sorted in non-decreasing order, and an integer **k**. Define a pair of values (u, v), where the first element comes from **nums1** and the second element comes from **nums2**. Please find the pairs with the smallest sum (u1, v1), (u2, v2)...(uk, vk) for the first **k** pairs.\nPlease use Python to first design a **DAG** class, with instance attributes **nums1**, **nums2** and **k**, a private function **private_decreasing_arrangement**, and a public function **public_decreasing_arrangement**. Then, implement the above problem in the private function **private_decreasing_arrangement**. Finally, call the private function **private_decreasing_arrangement** in the public function **public_decreasing_arrangement** to return the result.", "test_list": ["assert candidate([1,7,11],[2,4,6],3)==[1,2],[1,4],[1,6]", "assert candidate([1,1,2],[1,2,3],2)==[1,1],[1,1]", "assert candidate([1,2],[3],3)==[1,3],[2,3]"], "test_function": "def test_run(content1,content2,content3):\n    return DAG(content1,content2,content3).public_decreasing_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([['class DAG', 'def _private_decreasing_arrangement', 'def public_decreasing_arrangement'], ['class DAG', 'def __private_decreasing_arrangement', 'def public_decreasing_arrangement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/115", "question": "First, design an **NBGG** class using the Python language, which has an instance attribute **n**, a private function **private_Guessing_Game**, and a public function **public_Guessing_Game**. Then, call the private function **private_ugly_number** in the public function **public_Guessing_Game** to return the result. The following problem is implemented in the private function **private_Guessing_Game**.\nProblem: Choose a number between 1 and **n** for a guessing game. If you guess the correct number, you win the game; otherwise, you will be told that the current number I chose is larger or smaller, and you continue to guess. When you guess the number **x** and get it wrong, you need to pay cash equal to **x**. If you run out of money, you lose the game. Given a specific number **n**, return the minimum amount of cash that can ensure victory.", "test_list": ["assert candidate(10)==16", "assert candidate(1)==0", "assert candidate(2)==1"], "test_function": "def test_run(content1):\n    return NBGG(content1).public_Guessing_Game()", "entry_point": "test_run", "test_matching": "assert candidate([['class NBGG', 'def _private_Guessing_Game', 'def public_Guessing_Game'], ['class NBGG', 'def __private_Guessing_Game', 'def public_Guessing_Game']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/116", "question": "Firstly, design an **LSS** class using Python language, which has an instance attribute **nums**, a private function **private_Longest_subsequence**, and a public function **public_Longest_subsequence**. Then, in the private function **private_Longest_subsequence**, return the length of the longest subsequence in the integer array **nums** that serves as a wiggle sequence. Finally, in the public function **public_Longest_subsequence**, call the private function **private_Longest_subsequence** to return the result.", "test_list": ["assert candidate([1,7,4,9,2,5])==6", "assert candidate([1,17,5,10,13,15,10,5,16,8])==7", "assert candidate([1,2,3,4,5,6,7,8,9])==2"], "test_function": "def test_run(content1):\n    return LSS(content1).public_Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class LSS', 'def _private_Longest_subsequence', 'def public_Longest_subsequence'], ['class LSS', 'def __private_Longest_subsequence', 'def public_Longest_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/117", "question": "Question: Given an array **nums** composed of distinct integers and a target integer **target**, please find and return the number of combinations in **nums** that sum up to **target**. \nPlease use Python language to first design an **EAC** class, with instance attributes **nums** and **target**, a private function **private_element_association**, and a public function **public_element_association**. Then, implement the above problem in the private function **private_element_association**. Finally, call the private function **private_element_association** in the public function **public_element_association** to return the result.", "test_list": ["assert candidate([1,2,3],4)==7", "assert candidate([9],3)==0"], "test_function": "def test_run(content1,content2):\n    return EAC(content1,content2).public_element_association()", "entry_point": "test_run", "test_matching": "assert candidate([['class EAC', 'def _private_element_association', 'def public_element_association'], ['class EAC', 'def __private_element_association', 'def public_element_association']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/118", "question": "Question: Given an n x n matrix **matrix**, where each row and column elements are sorted in ascending order, find the k-th smallest element in the matrix.\nPlease use Python to first design a **SAS** class, with instance attributes **matrix** and **k**, a private function **private_Sort_ascending**, and a public function **public_Sort_ascending**. Then, implement the above problem in the private function **private_Sort_ascending**. Finally, call the private function **private_Sort_ascending** in the public function **public_Sort_ascending** to return the result.", "test_list": ["assert candidate([[1,5,9],[10,11,13],[12,13,15]],8)==13", "assert candidate([[-5]],1)==-5"], "test_function": "def test_run(content1,content2):\n    return SAS(content1,content2).public_Sort_ascending()", "entry_point": "test_run", "test_matching": "assert candidate([['class SAS', 'def _private_Sort_ascending', 'def public_Sort_ascending'], ['class SAS', 'def __private_Sort_ascending', 'def public_Sort_ascending']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/119", "question": "Question: Given a string **s** representing a **NestedInteger** of integers, implement a parser to parse it and return the parsed result as **NestedInteger**. \nPlease use Python to first design an **INT** class, which has an instance attribute **s**, a private function **private_Integer_nesting**, and a public function **public_Integer_nesting**. Then, implement the above problem in the private function **private_Integer_nesting**. Finally, call the private function **private_Integer_nesting** in the public function **public_Integer_nesting** to return the result.", "test_list": ["assert candidate(\"324\")==324", "assert candidate(\"[123,[456,[789]]]\")==[123,[456,[789]]]"], "test_function": "def test_run(content1):\n    return INT(content1).public_Integer_nesting()", "entry_point": "test_run", "test_matching": "assert candidate([['class INT', 'def _private_Integer_nesting', 'def public_Integer_nesting'], ['class INT', 'def _private_Integer_nesting', 'def public_Integer_nesting']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/120", "question": "Firstly, design a class named **DOD** using Python language, which has an instance attribute **n**, a private function **private_Dictionary_order**, and a public function **public_Dictionary_order**. Then, in the private function **private_Dictionary_order**, return all integers within the range [1, n] in dictionary order. Finally, in the public function **public_Dictionary_order**, call the private function **private_Dictionary_order** to return the result.", "test_list": ["assert candidate(13)==[1,10,11,12,13,2,3,4,5,6,7,8,9]", "assert candidate(2)==[1,2]"], "test_function": "def test_run(content1):\n    return DOD(content1).public_Dictionary_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class DOD', 'def _private_Dictionary_order', 'def public_Dictionary_order'], ['class DOD', 'def __private_Dictionary_order', 'def public_Dictionary_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/121", "question": "Question: Given two strings **s** and **t**, they only contain lowercase letters. String **t** is randomly rearranged from string **s**, and then a letter is added at a random position. Please find the letter added in **t**.\nPlease use Python language to first design a **RAI** class, with instance attributes **s** and **t**, a private function **private_Random_addition**, and a public function **public_Random_addition**; then implement the above problem in the private function **private_Random_addition**; finally, call the private function **private_Random_addition** in the public function **public_Random_addition** to return the result.", "test_list": ["assert candidate(\"abcd\",\"abcde\")==\"e\"", "assert candidate(\"\",\"y\")==\"y\""], "test_function": "def test_run(content1,content2):\n    return RAI(content1,content2).public_Random_addition()", "entry_point": "test_run", "test_matching": "assert candidate([['class RAI', 'def _private_Random_addition', 'def public_Random_addition'], ['class RAI', 'def __private_Random_addition', 'def public_Random_addition']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/122", "question": "Firstly, design an **RNE** class using Python language, which has an instance attribute **n**, a private function **private_remaining_numbers**, and a public function **public_remaining_numbers**. Then, implement the following problem in the private function **private_remaining_numbers**. Finally, call the private function **private_remaining_numbers** in the public function **public_remaining_numbers** to return the result.\nProblem: The given list **arr** consists of all integers in the range [1, n] and is strictly sorted in ascending order. You need to delete the first number of **arr** from left to right, then delete a number every other number until you reach the end of the list, then repeat the above steps from right to left. Keep repeating these two steps until only one number is left. Given an integer **n**, you are required to return the last remaining number in **arr**.", "test_list": ["assert candidate(9)==6", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return RNE(content1).public_remaining_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class RNE', 'def _private_remaining_numbers', 'def public_remaining_numbers'], ['class RNE', 'def __private_remaining_numbers', 'def public_remaining_numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/123", "question": "Firstly, design a **PCN** class using Python language, which has an instance attribute **rectangles**, a private function **private_Parallel_coordinate**, and a public function **public_Parallel_coordinate**. Then, implement the following problem in the private function **private_Parallel_coordinate**. Finally, call the private function **private_Parallel_coordinate** in the public function **public_Parallel_coordinate** to return the result.\nProblem: Given an array rectangles[i] = [x_i, y_i, a_i, b_i] representing a rectangle parallel to the coordinate axis, where the lower left vertex is (x_i, y_i) and the upper right vertex is (a_i, b_i), determine whether all rectangles together exactly cover a certain rectangular area. If so, return **True**; otherwise, return **False**.", "test_list": ["assert candidate([[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]])==True", "assert candidate([[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]])==False", "assert candidate([[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]])==False"], "test_function": "def test_run(content1):\n    return PCN(content1).public_Parallel_coordinate()", "entry_point": "test_run", "test_matching": "assert candidate([['class PCN', 'def _private_Parallel_coordinate', 'def public_Parallel_coordinate'], ['class PCN', 'def __private_Parallel_coordinate', 'def public_Parallel_coordinate']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/124", "question": "Firstly, design a **VED** class using Python language, which has an instance attribute **data**, a private function **private_Valid_encoding**, and a public function **public_Valid_encoding**. Then, implement the following problem in the private function **private_Valid_encoding**. Finally, call the private function **private_Valid_encoding** in the public function **public_Valid_encoding** to return the result.\nProblem: Given an integer array **data** representing data, return whether it is a valid UTF-8 encoding. Characters in UTF-8 need to follow the following rules: For a 1-byte character, the first bit of the byte is set to 0, and the following 7 bits are the unicode code of this symbol. For an n-byte character (n>1), the first n bits of the first byte are all set to 1, the n+1 bit is set to 0, and the first two bits of the following bytes are all set to 10. The remaining unmentioned binary bits are all the unicode code of this symbol.", "test_list": ["assert candidate([197,130,1])==True", "assert candidate([235,140,4])==False"], "test_function": "def test_run(content1):\n    return VED(content1).public_Valid_encoding()", "entry_point": "test_run", "test_matching": "assert candidate([['class VED', 'def _private_Valid_encoding', 'def public_Valid_encoding'], ['class VED', 'def __private_Valid_encoding', 'def public_Valid_encoding']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/125", "question": "Firstly, design a class **LST** using the Python language, which has instance attributes **s** and **k**, a private function **private_Longest_substring**, and a public function **public_Longest_substring**. Then, in the private function **private_Longest_substring**, return the length of the longest substring in the string **s** where each character appears no less than **k** times. Finally, in the public function **public_Longest_substring**, call the private function **private_Longest_substring** to return the result.", "test_list": ["assert candidate(\"aaabb\",3)==3", "assert candidate(\"ababbc\",2)==5"], "test_function": "def test_run(content1,content2):\n    return LST(content1,content2).public_Longest_substring()", "entry_point": "test_run", "test_matching": "assert candidate([['class LST', 'def _private_Longest_substring', 'def public_Longest_substring'], ['class LST', 'def __private_Longest_substring', 'def public_Longest_substring']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/126", "question": "Firstly, design a **CRT** class using Python language, which has an instance attribute **nums**, a private function **private_clockwise_rotation**, and a public function **public_clockwise_rotation**. Then, implement the following problem in the private function **private_clockwise_rotation**. Finally, call the private function **private_clockwise_rotation** in the public function **public_clockwise_rotation** to return the result.\nProblem: Suppose **arrk** is the array after the integer array **nums** of length **n** is rotated **k** positions clockwise, we define the rotation function **F** of **nums** as: F(k)=0*arrk[0]+1*arrk[1]+...+(n-1)*arrk[n-1]. You need to return the maximum value among F(0), F(1), ..., F(n-1).", "test_list": ["assert candidate([4,3,2,6])==26", "assert candidate([100])==0"], "test_function": "def test_run(content1):\n    return CRT(content1).public_clockwise_rotation()", "entry_point": "test_run", "test_matching": "assert candidate([['class CRT', 'def _private_clockwise_rotation', 'def public_clockwise_rotation'], ['class CRT', 'def __private_clockwise_rotation', 'def public_clockwise_rotation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/127", "question": "Firstly, design an **MRC** class using Python language, which has an instance attribute **n**, a private function **private_Minimum_replacements**, and a public function **public_Minimum_replacements**. Then, in the private function **private_Minimum_replacements**, given a positive integer **n**, if **n** is even, replace **n** with **n/2**. If **n** is odd, replace **n** with **n+1** or **n-1**. Return the minimum number of replacements required for **n** to become 1. Finally, in the public function **public_Minimum_replacements**, call the private function **private_Minimum_replacements** to return the result.", "test_list": ["assert candidate(8)==3", "assert candidate(7)==4", "assert candidate(4)==2"], "test_function": "def test_run(content1):\n    return MRC(content1).public_Minimum_replacements()", "entry_point": "test_run", "test_matching": "assert candidate([['class MRC', 'def _private_Minimum_replacements', 'def public_Minimum_replacements'], ['class MRC', 'def __private_Minimum_replacements', 'def public_Minimum_replacements']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/128", "question": "Firstly, design an **IIG** class using Python language, which has an instance attribute **n**, a private function **private_Infinite_integers**, and a public function **public_Infinite_integers**. Then, in the private function **private_Infinite_integers**, return the number at the n-th position in the infinite integer sequence [1,2,3,4,5,6,7,8,9,10,11,...]. Finally, call the private function **private_Infinite_integers** in the public function **public_Infinite_integers** to return the result.", "test_list": ["assert candidate(3)==3", "assert candidate(11)==0"], "test_function": "def test_run(content1):\n    return IIG(content1).public_Infinite_integers()", "entry_point": "test_run", "test_matching": "assert candidate([['class IIG', 'def _private_Infinite_integers', 'def public_Infinite_integers'], ['class IIG', 'def __private_Infinite_integers', 'def public_Infinite_integers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/129", "question": "Question: Given a non-negative integer **num** represented as a string and an integer **k**, remove **k** digits from the number so that the remaining number is the smallest. Please return this smallest number in string form.\nUsing Python, first design a **SNU** class, which has instance attributes **num** and **k**, a private function **private_smallest_number**, and a public function **public_smallest_number**. Then implement the above problem in the private function **private_smallest_number**. Finally, call the private function **private_smallest_number** in the public function **public_smallest_number** to return the result.", "test_list": ["assert candidate(\"1432219\",3)==\"1219\"", "assert candidate(\"10200\",1)==\"200\"", "assert candidate(\"10\",2)==\"0\""], "test_function": "def test_run(content1,content2):\n    return SNU(content1,content2).public_smallest_number()", "entry_point": "test_run", "test_matching": "assert candidate([['class SNU', 'def _private_smallest_number', 'def public_smallest_number'], ['class SNU', 'def __private_smallest_number', 'def public_smallest_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/130", "question": "First, design an **RQU** class using the Python language, which has an instance attribute **people**, a private function **private_Rank_queue**, and a public function **public_Rank_queue**. Then, implement the following problem in the private function **private_Rank_queue**. Finally, call the private function **private_Rank_queue** in the public function **public_Rank_queue** to return the result.\nProblem: Assume there is a group of people standing in a queue in a disordered order. The array **people[i]=[h_i,k_i]** indicates that the height of the i-th person is **h_i**, and there are exactly **k_i** people in front of him who are taller or equal to **h_i**. The requirement is to return the queue represented by the input array **people**.", "test_list": ["assert candidate([[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]])==[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]", "assert candidate([[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]])==[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]"], "test_function": "def test_run(content1):\n    return RQU(content1).public_Rank_queue()", "entry_point": "test_run", "test_matching": "assert candidate([['class RQU', 'def _private_Rank_queue', 'def public_Rank_queue'], ['class RQU', 'def __private_Rank_queue', 'def public_Rank_queue']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/131", "question": "Question: Given a non-negative integer array **nums** and an integer **m**, you need to divide this array into **m** non-empty continuous subarrays. Design an algorithm to make the maximum value of the sum of these **m** subarrays the smallest.\nPlease use Python language to first design a **CSR** class, with instance attributes **nums** and **m**, a private function **private_Continuous_subarray**, and a public function **public_Continuous_subarray**; then implement the above problem in the private function **private_Continuous_subarray**; finally, call the private function **private_Continuous_subarray** in the public function **public_Continuous_subarray** to return the result.", "test_list": ["assert candidate([7,2,5,10,8],2)==18", "assert candidate([1,2,3,4,5],2)==9", "assert candidate([1,4,4],3)==4"], "test_function": "def test_run(content1,content2):\n    return CSR(content1,content2).public_Continuous_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class CSR', 'def _private_Continuous_subarray', 'def public_Continuous_subarray'], ['class CSR', 'def __private_Continuous_subarray', 'def public_Continuous_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/132", "question": "Firstly, design an **EAY** class using the Python language, which has an instance attribute **nums**, a private function **private_Equidistant_array**, and a public function **public_Equidistant_array**. Then, in the private function **private_Equidistant_array**, provide an integer array **nums** and return the number of sub-arrays in **nums** that are arithmetic arrays. Finally, in the public function **public_Equidistant_array**, call the private function **private_Equidistant_array** to return the result.", "test_list": ["assert candidate([1,2,3,4])==3", "assert candidate([1])==0"], "test_function": "def test_run(content1):\n    return EAY(content1).public_Equidistant_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class EAY', 'def _private_Equidistant_array', 'def public_Equidistant_array'], ['class EAY', 'def __private_Equidistant_array', 'def public_Equidistant_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/133", "question": "Firstly, design an **SSB** class using the Python language, which has an instance attribute **nums**, a private function **private_split_subset**, and a public function **public_split_subset**. Then, in the private function **private_split_subset**, determine whether the non-empty array **nums**, which only contains positive integers, can be split into two subsets so that the sum of the elements in the two subsets is equal. Finally, in the public function **public_split_subset**, call the private function **private_split_subset** to return the result.", "test_list": ["assert candidate([1,5,11,5])==True", "assert candidate([1,2,3,5])==False"], "test_function": "def test_run(content1):\n    return SSB(content1).public_split_subset()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSB', 'def _private_split_subset', 'def public_split_subset'], ['class SSB', 'def __private_split_subset', 'def public_split_subset']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/134", "question": "Question: Given a m x n matrix **board** representing a deck, where each cell can be a battleship 'X' or an empty spot '.', return the number of battleships placed on the board.\nPlease use Python to first design a **PBI** class, with an instance attribute **board**, a private function **private_Placed_battleships**, and a public function **public_Placed_battleships**. Then implement the above problem in the private function **private_Placed_battleships**. Finally, call the private function **private_Placed_battleships** in the public function **public_Placed_battleships** to return the result.", "test_list": ["assert candidate([[\"X\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"],[\".\",\".\",\".\",\"X\"]])==2", "assert candidate([[\".\"]])==0"], "test_function": "def test_run(content1):\n    return PBI(content1).\",\"()", "entry_point": "test_run", "test_matching": "assert candidate([['class PBI', 'def _private_Placed_battleships', 'def public_Placed_battleships'], ['class PBI', 'def __private_Placed_battleships', 'def public_Placed_battleships']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/135", "question": "First, design an **MRU** class using the Python language, which has an instance attribute **nums**, a private function **private_Maximum_result**, and a public function **public_Maximum_result**. Then, in the private function **private_Maximum_result**, return the maximum operation result of nums[i] XOR nums[j], where 0â‰¤iâ‰¤j<n. Finally, in the public function **public_Maximum_result**, call the private function **private_Maximum_result** to return the result.", "test_list": ["assert candidate([3,10,5,25,2,8])==28", "assert candidate([14,70,53,83,49,91,36,80,92,51,66,70])==127"], "test_function": "def test_run(content1):\n    return MRU(content1).public_Maximum_result()", "entry_point": "test_run", "test_matching": "assert candidate([['class MRU', 'def _private_Maximum_result', 'def public_Maximum_result'], ['class MRU', 'def __private_Maximum_result', 'def public_Maximum_result']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/136", "question": "Question: Given a string **s**, which contains several numbers (0-9) represented by scrambled English words, return the original numbers in ascending order.\nUsing Python language, first design a **DOR** class, with instance attribute **s**, private function **private_Disordered_order** and public function **public_Disordered_order**; then implement the above problem in the private function **private_Disordered_order**; finally, call the private function **private_Disordered_order** in the public function **public_Disordered_order** to return the result.", "test_list": ["assert candidate(\"owoztneoer\")==\"012\"", "assert candidate(\"fviefuro\")==\"45\""], "test_function": "def test_run(content1):\n    return DOR(content1).public_Disordered_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class DOR', 'def _private_Disordered_order', 'def public_Disordered_order'], ['class DOR', 'def __private_Disordered_order', 'def public_Disordered_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/137", "question": "Firstly, design an **LSR** class using Python language, which has instance attributes **s** and **k**, a private function **private_Longest_substring**, and a public function **public_Longest_substring**. Then, in the private function **private_Longest_substring**, change any character in the string **s** to any other uppercase English character up to **k** times, and return the length of the longest substring containing the same letter. Finally, in the public function **public_Longest_substring**, call the private function **private_Longest_substring** to return the result.", "test_list": ["assert candidate(\"ABAB\",2)==4", "assert candidate(\"AABABBA\",1)==4"], "test_function": "def test_run(content1,content2):\n    return LSR(content1,content2).public_Longest_substring()", "entry_point": "test_run", "test_matching": "assert candidate([['class LSR', 'def _private_Longest_substring', 'def public_Longest_substring'], ['class LSR', 'def _private_Longest_substring', 'def public_Longest_substring']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/138", "question": "Firstly, design a class **GS** using Python language, which has instance attributes **start**, **end**, and **bank**, a private function **private_gene_sequence**, and a public function **public_gene_sequence**. Then, implement the following problem in the private function **private_gene_sequence**. Finally, call the private function **private_gene_sequence** in the public function **public_gene_sequence** to return the result.\nProblem: A gene sequence is represented by a string composed of 8 characters, each of which is one of 'A', 'C', 'G', and 'T'. Suppose we need to investigate the gene changes that occur when the gene sequence **start** changes to **end**. Gene changes mean that the characters have changed. Given a gene bank **bank** that records all valid gene changes, return the minimum number of changes required to change **start** to **end**. If this gene change cannot be completed, return -1.", "test_list": ["assert candidate(\"AACCGGTT\", \"AACCGGTA\", [\"AACCGGTA\"])==1", "assert candidate(\"AACCGGTT\", \"AAACGGTA\", [\"AACCGGTA\",\"AACCGCTA\",\"AAACGGTA\"])==2", "assert candidate(\"AAAAACCC\", \"AACCCCCC\", [\"AAAACCCC\",\"AAACCCCC\",\"AACCCCCC\"])==3"], "test_function": "def test_run(content1,content2,content3):\n    return GS(content1,content2,content3).public_gene_sequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class GS', 'def _private_gene_sequence', 'def public_gene_sequence'], ['class GS', 'def __private_gene_sequence', 'def public_gene_sequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/139", "question": "Question: Given a collection of **intervals** where intervals[i] = [start_i, end_i]. Return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\nPlease use Python to first design a **SIL** class, with instance attribute **intervals**, a private function **private_Set_intervals**, and a public function **public_Set_intervals**. Then, implement the above problem in the private function **private_Set_intervals**. Finally, call the private function **private_Set_intervals** in the public function **public_Set_intervals** to return the result.", "test_list": ["assert candidate([[1,2],[2,3],[3,4],[1,3]])==1", "assert candidate([[1,2], [1,2], [1,2]])==2", "assert candidate([[1,2], [2,3]])==0"], "test_function": "def test_run(content1):\n    return SIL(content1).public_Set_intervals()", "entry_point": "test_run", "test_matching": "assert candidate([['class SIL', 'def _private_Set_intervals', 'def public_Set_intervals'], ['class SIL', 'def __private_Set_intervals', 'def public_Set_intervals']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/140", "question": "Firstly, design an **RSC** class using Python language, which has an instance attribute **intervals**, a private function **private_Right_section**, and a public function **public_Right_section**. Then, implement the following problem in the private function **private_Right_section**. Finally, call the private function **private_Right_section** in the public function **public_Right_section** to return the result.\nProblem: Given an interval array **intervals**, where intervals[i] = [start_i, end_i], and each **start_i** is different. The right section of interval **i** can be denoted as interval **j**, satisfying **start_j >= end_i**, and **start_j** is minimized. Return an array composed of the indices of the right section of each interval **i** in **intervals**. If there is no corresponding right section for a certain interval **i**, the value at index **i** is set to -1.", "test_list": ["assert candidate([[1,2]])==[-1]", "assert candidate([[3,4],[2,3],[1,2]])==[-1,0,1]", "assert candidate([[1,4],[2,3],[3,4]])==[-1,2,-1]"], "test_function": "def test_run(content1):\n    return RSC(content1).public_Right_section()", "entry_point": "test_run", "test_matching": "assert candidate([['class RSC', 'def _private_Right_section', 'def public_Right_section'], ['class RSC', 'def __private_Right_section', 'def public_Right_section']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/141", "question": "Question: Given two strings **s** and **p**, find all the anagrams of **p** in **s**, and return the starting indices of these substrings. An anagram is a string formed by rearranging the same letters (including the same string).\nPlease use Python to first design a **SIN** class, with instance attributes **s** and **p**, a private function **private_start_index**, and a public function **public_start_index**; then implement the above problem in the private function **private_start_index**; finally, call the private function **private_start_index** in the public function **public_start_index** to return the result.", "test_list": ["assert candidate(\"cbaebabacd\",\"abc\")==[0,6]", "assert candidate(\"abab\",\"ab\")==[0,1,2]"], "test_function": "def test_run(content1,content2):\n    return SIN(content1,content2).public_start_index()", "entry_point": "test_run", "test_matching": "assert candidate([['class SIN', 'def _private_start_index', 'def public_start_index'], ['class SIN', 'def __private_start_index', 'def public_start_index']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/142", "question": "Firstly, design a **DOE** class using Python language, which has instance attributes **n** and **k**, a private function **private_Dictionary_order**, and a public function **public_Dictionary_order**. Then, return the **k-th** smallest number in the dictionary order of [1, n] in the private function **private_Dictionary_order**. Finally, call the private function **private_Dictionary_order** in the public function **public_Dictionary_order** to return the result.", "test_list": ["assert candidate(13,2)==10", "assert candidate(1,1)==1"], "test_function": "def test_run(content1,content2):\n    return DOE(content1,content2).public_Dictionary_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class DOE', 'def _private_Dictionary_order', 'def public_Dictionary_order'], ['class DOE', 'def __private_Dictionary_order', 'def public_Dictionary_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/143", "question": "Question: There are a total of **n** coins, and the plan is to arrange them in a staircase shape. For a staircase composed of **k** rows, the i-th row must have exactly **i** coins. The last row of the staircase may be incomplete. Given a number **n**, calculate and return the total number of rows that can form a complete staircase.\nPlease use the Python language to first design a **CLA** class, with an instance attribute **n**, a private function **private_Complete_ladder**, and a public function **public_Complete_ladder**; then implement the above problem in the private function **private_Complete_ladder**; finally, call the private function **private_Complete_ladder** in the public function **public_Complete_ladder** to return the result.", "test_list": ["assert candidate(5)==2", "assert candidate(8)==3"], "test_function": "def test_run(content1):\n    return CLA(content1).public_Complete_ladder()", "entry_point": "test_run", "test_matching": "assert candidate([['class CLA', 'def _private_Complete_ladder', 'def public_Complete_ladder'], ['class CLA', 'def __private_Complete_ladder', 'def public_Complete_ladder']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/144", "question": "Question: Given an integer array **nums** of length **n**, where all integers in **nums** are within the range [1, n] and each integer appears once or twice. Please find all integers that appear twice and return them in the form of an array.\nPlease use Python to first design a class **AFO** with instance attribute **nums**, private function **private_Array_form** and public function **public_Array_form**; then implement the above problem in the private function **private_Array_form**; finally, call the private function **private_Array_form** in the public function **public_Array_form** to return the result.", "test_list": ["assert candidate([4,3,2,7,8,2,3,1])==[2,3]", "assert candidate([1,1,2])==[1]", "assert candidate([1])==[]"], "test_function": "def test_run(content1):\n    return AFO(content1).public_Array_form()", "entry_point": "test_run", "test_matching": "assert candidate([['class AFO', 'def _private_Array_form', 'def public_Array_form'], ['class AFO', 'def __private_Array_form', 'def public_Array_form']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/145", "question": "Firstly, design an **ISAR** class using the Python language, which has instance attributes **chars**, a private function **private_Input_sarray**, and a public function **public_Input_sarray**. Then, implement the following problem in the private function **private_Input_sarray**. Finally, call the private function **private_Input_sarray** in the public function **public_Input_sarray** to return the result.\nProblem: Given a character array **chars**, compress the array according to the following requirements: Starting from an empty string **s**, for each group of consecutive repeating characters in **chars**, if the length of the group is 1, append the character to **s**. Otherwise, append the character to **s**, followed by the length of the group. The requirement is to return the new length of the array after modifying the input array.", "test_list": ["assert candidate([\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"])==[\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]", "assert candidate([\"a\"])==[\"a\"]", "assert candidate([\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"])==[\"a\",\"b\",\"1\",\"2\"]"], "test_function": "def test_run(content1):\n    return ISAR(content1).public_Input_sarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class ISAR', 'def _private_Input_sarray', 'def public_Input_sarray'], ['class ISAR', 'def __private_Input_sarray', 'def public_Input_sarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/146", "question": "Firstly, design an **ESQ** class using Python language, which has an instance attribute **nums**, a private function **private_Equidistant_subsequence**, and a public function **public_Equidistant_subsequence**. Then, in the private function **private_Equidistant_subsequence**, return the number of all equidistant subsequences in the integer array **nums**. Finally, in the public function **public_Equidistant_subsequence**, call the private function **private_Equidistant_subsequence** to return the result.", "test_list": ["assert candidate([2,4,6,8,10])==7", "assert candidate([7,7,7,7,7])==16"], "test_function": "def test_run(content1):\n    return ESQ(content1).public_Equidistant_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class ESQ', 'def _private_Equidistant_subsequence', 'def public_Equidistant_subsequence'], ['class ESQ', 'def __private_Equidistant_subsequence', 'def public_Equidistant_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/147", "question": "Firstly, design an **EDA** class using Python language, which has an instance attribute **points**, a private function **private_Euclidean_distance**, and a public function **public_Euclidean_distance**. Then, implement the following problem in the private function **private_Euclidean_distance**. Finally, call the private function **private_Euclidean_distance** in the public function **public_Euclidean_distance** to return the result.\nProblem: Given **n** pairs of distinct points on the plane points[i]=[x_i,y_i], a point (i,j,k) represents a boomerang, where the distance between **i** and **j** is equal to the Euclidean distance between **i** and **k** (considering the order of the tuple), return the number of all boomerangs on the plane.", "test_list": ["assert candidate([[0,0],[1,0],[2,0]])==2", "assert candidate([[1,1],[2,2],[3,3]])==2", "assert candidate([[1,1]])==0"], "test_function": "def test_run(content1):\n    return EDA(content1).public_Euclidean_distance()", "entry_point": "test_run", "test_matching": "assert candidate([['class EDA', 'def _private_Euclidean_distance', 'def public_Euclidean_distance'], ['class EDA', 'def __private_Euclidean_distance', 'def public_Euclidean_distance']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/148", "question": "Question: Given a string **s**, sort it in decreasing order based on the frequency of characters. The frequency of a character is the number of times it appears in the string. Return the sorted string.\nPlease use Python to first design a **DODE** class, with an instance attribute **s**, a private function **private_descending_order**, and a public function **public_descending_order**; then implement the above problem in the private function **private_descending_order**; finally, call the private function **private_descending_order** in the public function **public_descending_order** to return the result.", "test_list": ["assert candidate(\"tree\")==\"eert\"", "assert candidate(\"cccaaa\")==\"cccaaa\"", "assert candidate(\"Aabb\")==\"bbAa\""], "test_function": "def test_run(content1):\n    return DODE(content1).public_descending_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class DODE', 'def _private_descending_order', 'def public_descending_order'], ['class DODE', 'def __private_descending_order', 'def public_descending_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/149", "question": "Question: Given an integer array of length n, each operation will increase n - 1 elements by 1. Return the minimum number of operations to make all elements in the array equal.\nPlease design an **EEL** class in Python first, with instance attribute **nums**, a private function **private_Element_equality**, and a public function **public_Element_equality**. Then, implement the above problem in the private function **private_Element_equality**. Finally, call the private function **private_Element_equality** in the public function **public_Element_equality** to return the result.", "test_list": ["assert candidate([1,2,3])==3", "assert candidate([1,1,1])==0"], "test_function": "def test_run(content1):\n    return EEL(content1).public_Element_equality()", "entry_point": "test_run", "test_matching": "assert candidate([['class EEL', 'def _private_Element_equality', 'def public_Element_equality'], ['class EEL', 'def __private_Element_equality', 'def public_Element_equality']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/150", "question": "Question: Given four integer arrays **nums1**, **nums2**, **nums3**, and **nums4**, all of the same length **n**, calculate how many tuples (i, j, k, l) can satisfy: 0 <= i, j, k, l < n and nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0.\nPlease use Python to first design an **AST** class, with instance attributes **nums1**, **nums2**, **nums3**, and **nums4**, a private function **private_Array_stlength**, and a public function **public_Array_stlength**. Then, implement the above problem in the private function **private_Array_stlength**. Finally, call the private function **private_Array_stlength** in the public function **public_Array_stlength** to return the result.", "test_list": ["assert candidate([1,2],[-2,-1],[-1,2],[0,2])==2", "assert candidate([0],[0],[0],[0])==1"], "test_function": "def test_run(content1,content2,content3,content4):\n    return AST(content1,content2,content3,content4).public_Array_stlength()", "entry_point": "test_run", "test_matching": "assert candidate([['class AST', 'def _private_Array_stlength', 'def public_Array_stlength'], ['class AST', 'def __private_Array_stlength', 'def public_Array_stlength']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/151", "question": "Question: Given an integer array **nums** with **n** integers. A 132 pattern subsequence is a three-element sequence nums[i], nums[j], and nums[k] that satisfies: i<j<k and nums[i]<nums[k]<nums[j]. If there is a 132 pattern subsequence in **nums**, return True; otherwise, return False.\nPlease design a **SPAR** class in Python first, with an instance attribute **nums**, a private function **private_Subsequences_patterns**, and a public function **public_Subsequences_patterns**; then implement the above problem in the private function **private_Subsequences_patterns**; finally, call the private function **private_Subsequences_patterns** in the public function **public_Subsequences_patterns** to return the result.", "test_list": ["assert candidate([1,2,3,4])==False", "assert candidate([3,1,4,2])==True", "assert candidate([-1,3,2,0])==True"], "test_function": "def test_run(content1):\n    return SPAR(content1).public_Subsequences_patterns()", "entry_point": "test_run", "test_matching": "assert candidate([['class SPAR', 'def _private_Subsequences_patterns', 'def public_Subsequences_patterns'], ['class SPAR', 'def __private_Subsequences_patterns', 'def public_Subsequences_patterns']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/152", "question": "Firstly, design an **SPR** class using Python language, which has an instance attribute **nums**, a private function **private_Suences_patterns**, and a public function **public_Suences_patterns**. Then, implement the following problem in the private function **private_Suences_patterns**. Finally, call the private function **private_Suences_patterns** in the public function **public_Suences_patterns** to return the result.\nProblem: Given a circular array nums[i] without 0, which represents the number of indices that the character at index **i** should move forward or backward. If it is a positive number, move forward (in the direction of index increment) by |nums[i]| steps, otherwise, move backward (in the direction of index decrement) by |nums[i]| steps. Because the array is circular, it can be assumed that moving one step forward from the last element will reach the first element, and moving one step backward from the first element will reach the last element. The cycle in the array is identified by an index sequence **seq** of length k: following the above movement rules will lead to a group of repeated index sequences seq[0]->seq[1]->...->seq[k-1]->seq[0]->...; all nums[seq[j]] should be either all positive or all negative. Determine whether there is a cycle in **nums**, if it exists, return True; otherwise, return False.", "test_list": ["assert candidate([2,-1,1,2,2])==True", "assert candidate([-1,2])==False", "assert candidate([-2,1,-1,-2,-2])==False"], "test_function": "def test_run(content1):\n    return SPR(content1).public_Suences_patterns()", "entry_point": "test_run", "test_matching": "assert candidate([['class SPR', 'def _private_Suences_patterns', 'def public_Suences_patterns'], ['class SPR', 'def __private_Suences_patterns', 'def public_Suences_patterns']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/153", "question": "Question: Given an integer array **nums** of length **n**, return the minimum number of operations required to make all elements of the array equal. In one operation, you can increase or decrease an element of the array by one.\nPlease use Python to first design an **OOA** class, with instance attribute **nums**, a private function **private_One_operation**, and a public function **public_One_operation**. Then, implement the above problem in the private function **private_One_operation**. Finally, call the private function **private_One_operation** in the public function **public_One_operation** to return the result.", "test_list": ["assert candidate([1,2,3])==2", "assert candidate([1,10,2,9])==16"], "test_function": "def test_run(content1):\n    return OOA(content1).public_One_operation()", "entry_point": "test_run", "test_matching": "assert candidate([['class OOA', 'def _private_One_operation', 'def public_One_operation'], ['class OOA', 'def __private_One_operation', 'def public_One_operation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/154", "question": "Firstly, design a class **PIGE** using Python language, which has instance attributes **maxChoosableInteger** and **desiredTotal**, a private function **private_Public_integer**, and a public function **public_Public_integer**. Then, implement the following problem in the private function **private_Public_integer**. Finally, call the private function **private_Public_integer** in the public function **public_Public_integer** to return the result.\nProblem: Now, we are playing the **100game**. Two players take turns to choose any integer from 1 to 10, accumulate the sum of integers. The player who first reaches or exceeds 100 and cannot reuse integers is the winner. Given two integers, **maxChoosableInteger** (the maximum number that can be chosen from the integer pool) and **desiredTotal** (the accumulated sum), determine whether the first player can win stably. If so, return True, otherwise return False.", "test_list": ["assert candidate(10,11)==False", "assert candidate(10,0)==True", "assert candidate(10,1)==True"], "test_function": "def test_run(content1,content2):\n    return PIGE(content1,content2).public_Public_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class PIGE', 'def _private_Public_integer', 'def public_Public_integer'], ['class PIGE', 'def __private_Public_integer', 'def public_Public_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/155", "question": "Firstly, design an **IIFI** class using Python language, which has instance attributes **s1**, **n1**, **s2**, and **n2**, a private function **private_Italic_tion**, and a public function **public_Italic_tion**. Then, implement the following problem in the private function **private_Italic_tion**. Finally, call the private function **private_Italic_tion** in the public function **public_Italic_tion** to return the result.\nProblem: Given str=[s,n] indicates that **str** is composed of **n** strings **s** concatenated together. If some characters can be deleted from **s2** to become **s1**, then it is said that the string **s1** can be obtained from the string **s2**. You need to construct two strings **s1** and **s2** and two integers **n1** and **n2** to get two strings str1=[s1,n1] and str2=[s2,n2]. The requirement is to return a maximum integer **m**, to satisfy that str=[str2,m] can be obtained from **str1**.", "test_list": ["assert candidate(\"acb\",4,\"ab\",2)==2", "assert candidate(\"acb\",1,\"acb\",1)==1"], "test_function": "def test_run(content1,content2,content3,content4):\n    return IIFI(content1,content2,content3,content4).public_Italic_tion()", "entry_point": "test_run", "test_matching": "assert candidate([['class IIFI', 'def _private_Italic_tion', 'def public_Italic_tion'], ['class IIFI', 'def __private_Italic_tion', 'def public_Italic_tion']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/156", "question": "Question: Define a string base as an infinitely wrapped \"abcdefghijklmnopqrstuvwxyz\", so the base looks like this: \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\". Given a string s, please count and return how many different non-empty substrings appear in the base.\nPlease use Python to first design an **IZOE** class, with instance attribute **s**, private function **private_Infinity_Zone**, and public function **public_Infinity_Zone**; then implement the above problem in the private function **private_Infinity_Zone**; finally, call the private function **private_Infinity_Zone** in the public function **public_Infinity_Zone** to return the result.", "test_list": ["assert candidate(\"a\")==1", "assert candidate(\"cac\")==2", "assert candidate(\"zab\")==6"], "test_function": "def test_run(content1):\n    return IZOE(content1).public_Infinity_Zone()", "entry_point": "test_run", "test_matching": "assert candidate([['class IZOE', 'def _private_Infinity_Zone', 'def public_Infinity_Zone'], ['class IZOE', 'def __private_Infinity_Zone', 'def public_Infinity_Zone']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/157", "question": "Firstly, design an **EDC** class using Python language, which has an instance attribute **words**, a private function **private_Excluding_Duplicates**, and a public function **public_Excluding_Duplicates**. Then, in the private function **private_Excluding_Duplicates**, provide a string array **words** that does not contain duplicate words, and it is required to return all the conjunctions in **words**. Finally, call the private function **private_Excluding_Duplicates** in the public function **public_Excluding_Duplicates** to return the result.", "test_list": ["assert candidate([\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"])==[\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]", "assert candidate([\"cat\",\"dog\",\"catdog\"])==[\"catdog\"]"], "test_function": "def test_run(content1):\n    return EDC(content1).public_Excluding_Duplicates()", "entry_point": "test_run", "test_matching": "assert candidate([['class EDC', 'def _private_Excluding_Duplicates', 'def public_Excluding_Duplicates'], ['class EDC', 'def __private_Excluding_Duplicates', 'def public_Excluding_Duplicates']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/158", "question": "Firstly, design an **EMSP** class using Python language, which has an instance attribute **matchsticks**, a private function **private_Each_matchstick**, and a public function **public_Each_matchstick**. Then, implement the following problem in the private function **private_Each_matchstick**. Finally, call the private function **private_Each_matchstick** in the public function **public_Each_matchstick** to return the result.\nProblem: Given an integer array, matchsticks[i] is the length of the i-th matchstick. The requirement is to form a square with all the matchsticks (they can be connected together), but no matchstick can be broken and each matchstick must be used once. Determine whether it is possible to form this square. If it is possible, return True, otherwise return False.", "test_list": ["assert candidate([1,1,2,2,2])==True", "assert candidate([3,3,3,3,4])==False"], "test_function": "def test_run(content1):\n    return EMSP(content1).public_Each_matchstick()", "entry_point": "test_run", "test_matching": "assert candidate([['class EMSP', 'def _private_Each_matchstick', 'def public_Each_matchstick'], ['class EMSP', 'def __private_Each_matchstick', 'def public_Each_matchstick']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/159", "question": "Question: Given a binary string array **strs** and two integers **m** and **n**. Please find and return the length of the maximum subset of **strs**, which has at most **m** zeros and **n** ones. If all elements of **x** are also elements of **y**, set **x** is a subset of set **y**.\nPlease use Python language to first design a **MSBS** class, with instance attributes **strs**, **m** and **n**, a private function **private_Maximum_subset** and a public function **public_Maximum_subset**; then implement the above problem in the private function **private_Maximum_subset**; finally, call the private function **private_Maximum_subset** in the public function **public_Maximum_subset** to return the result.", "test_list": ["assert candidate([\"10\", \"0001\", \"111001\", \"1\", \"0\"],5,3)==4", "assert candidate([\"10\", \"0\", \"1\"],1,1)==2"], "test_function": "def test_run(content1,content2,content3):\n    return MSBS(content1,content2,content3).public_Maximum_subset()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSBS', 'def _private_Maximum_subset', 'def public_Maximum_subset'], ['class MSBS', 'def __private_Maximum_subset', 'def public_Maximum_subset']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/160", "question": "Firstly, design a class named **ANUB** using Python language, which has an instance attribute **nums**, a private function **private_Any_numbers**, and a public function **public_Any_numbers**. Then, in the private function **private_Any_numbers**, return the total Hamming distance between any two numbers in the integer array **nums**. Finally, in the public function **public_Any_numbers**, call the private function **private_Any_numbers** to return the result.", "test_list": ["assert candidate([4,14,2])==6", "assert candidate([4,14,4])==4"], "test_function": "def test_run(content1):\n    return ANUB(content1).public_Any_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class ANUB', 'def _private_Any_numbers', 'def public_Any_numbers'], ['class ANUB', 'def __private_Any_numbers', 'def public_Any_numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/161", "question": "Firstly, design an **MPRD** class using the Python language, which has an instance attribute **n**, a private function **private_Maximum_palindrome**, and a public function **public_Maximum_palindrome**. Then, in the private function **private_Maximum_palindrome**, return the maximum palindrome integer that can be represented as the product of two n-digit integers. Finally, in the public function **public_Maximum_palindrome**, call the private function **private_Maximum_palindrome** to return the result.", "test_list": ["assert candidate(2)==987", "assert candidate(1)==9"], "test_function": "def test_run(content1):\n    return MPRD(content1).public_Maximum_palindrome()", "entry_point": "test_run", "test_matching": "assert candidate([['class MPRD', 'def _private_Maximum_palindrome', 'def public_Maximum_palindrome'], ['class MPRD', 'def __private_Maximum_palindrome', 'def public_Maximum_palindrome']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/162", "question": "Firstly, design an **MSRI** class using the Python language, which has an instance attribute **n**, a private function **private_Magic_String**, and a public function **public_Magic_String**. Then, implement the following problem in the private function **private_Magic_String**. Finally, call the private function **private_Magic_String** in the public function **public_Magic_String** to return the result.\n\nProblem: The magical string **s** is composed only of '1' and '2', and the consecutive occurrences of '1' and '2' can generate this string. The first few elements of **s** are s = '1221121221221121122â€¦â€¦'. If you group consecutive 1s and 2s in **s**, you can get \"1221121221221121122......\". The number of times 1 or 2 appears in each group is \"122112122122......\". The above occurrence times are exactly **s** itself. Given an integer **n**, return the number of 1s in the first **n** digits of the magical string **s**.", "test_list": ["assert candidate(6)==3", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return MSRI(content1).public_Magic_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSRI', 'def _private_Magic_String', 'def public_Magic_String'], ['class MSRI', 'def __private_Magic_String', 'def public_Magic_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/163", "question": "Firstly, design an **MBS** class using the Python language, which has an instance attribute **n**, a private function **private_Minimum_base**, and a public function **public_Minimum_base**. Then, in the private function **private_Minimum_base**, it is required to return the minimum good base of **n** in the form of a string. The definition of the minimum good base is as follows: if all digits of the **k** (k>=2) base number of **n** are 1, then **k** (k>=2) is considered a good base for **n**. Finally, the private function **private_Minimum_base** is called in the public function **public_Minimum_base** to return the result.", "test_list": ["assert candidate(\"13\")==\"3\"", "assert candidate(\"4681\")==\"8\"", "assert candidate(\"1000000000000000000\")==\"999999999999999999\""], "test_function": "def test_run(content1):\n    return MBS(content1).public_Minimum_base()", "entry_point": "test_run", "test_matching": "assert candidate([['class MBS', 'def _private_Minimum_base', 'def public_Minimum_base'], ['class MBS', 'def __private_Minimum_base', 'def public_Minimum_base']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/164", "question": "Question: Given an integer array **nums**, find and return all the distinct increasing sub-sequences in this array, where each sub-sequence must contain at least two elements.\nPlease design an **ISQE** class in Python, which has an instance attribute **nums**, a private function **private_increasing_subsequence**, and a public function **public_increasing_subsequence**. Then, implement the above problem in the private function **private_increasing_subsequence**. Finally, call the private function **private_increasing_subsequence** in the public function **public_increasing_subsequence** to return the result.", "test_list": ["assert candidate([4,6,7,7])==[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]", "assert candidate([4,4,3,2,1])==[[4,4]]"], "test_function": "def test_run(content1):\n    return ISQE(content1).public_increasing_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class ISQE', 'def _private_increasing_subsequence', 'def public_increasing_subsequence'], ['class ISQE', 'def __private_increasing_subsequence', 'def public_increasing_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/165", "question": "Question: Given an array **nums**, if i<j and nums[i]>2*nums[j], we call (i, j) an important reverse pair. You need to return the number of **important reverse pairs** in the given array.\nPlease use Python to first design an **IFIP** class, with instance attribute **nums**, private function **private_Important_flipping** and public function **public_Important_flipping**; then implement the above problem in the private function **private_Important_flipping**; finally, call the private function **private_Important_flipping** in the public function **public_Important_flipping** to return the result.", "test_list": ["assert candidate([1,3,2,3,1])==2", "assert candidate([2,4,3,5,1])==3"], "test_function": "def test_run(content1):\n    return IFIP(content1).public_Important_flipping()", "entry_point": "test_run", "test_matching": "assert candidate([['class IFIP', 'def _private_Important_flipping', 'def public_Important_flipping'], ['class IFIP', 'def __private_Important_flipping', 'def public_Important_flipping']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/166", "question": "Question: Given a non-negative integer array **nums** and an integer **target**. By adding '+' or '-' in front of each integer in the array and then concatenating all the integers, an expression can be constructed. Return the number of different expressions that can be constructed in the above way and the calculation result is equal to **target**.\nPlease use Python language to first design a **DESI** class, with instance attributes **nums** and **target**, a private function **private_Different_expressions**, and a public function **public_Different_expressions**; then implement the above problem in the private function **private_Different_expressions**; finally, call the private function **private_Different_expressions** in the public function **public_Different_expressions** to return the result.", "test_list": ["assert candidate([1,1,1,1,1],3)==5", "assert candidate([1],1)==1"], "test_function": "def test_run(content1,content2):\n    return DESI(content1,content2).public_Different_expressions()", "entry_point": "test_run", "test_matching": "assert candidate([['class DESI', 'def _private_Different_expressions', 'def public_Different_expressions'], ['class DESI', 'def __private_Different_expressions', 'def public_Different_expressions']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/167", "question": "Firstly, design a **DTVL** class using Python language, which has an instance attribute **mat**, a private function **private_Diagonal_traversal**, and a public function **public_Diagonal_traversal**. Then, in the private function **private_Diagonal_traversal**, return all the elements in the m x n matrix **mat** in the order of diagonal traversal using an array. Finally, in the public function **public_Diagonal_traversal**, call the private function **private_Diagonal_traversal** to return the result.", "test_list": ["assert candidate([[1,2,3],[4,5,6],[7,8,9]])==[1,2,4,7,5,3,6,8,9]", "assert candidate([[1,2],[3,4]])==[1,2,3,4]"], "test_function": "def test_run(content1):\n    return DTVL(content1).public_Diagonal_traversal()", "entry_point": "test_run", "test_matching": "assert candidate([['class DTVL', 'def _private_Diagonal_traversal', 'def public_Diagonal_traversal'], ['class DTVL', 'def __private_Diagonal_traversal', 'def public_Diagonal_traversal']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/168", "question": "Question: Given a circular array **nums** (the next element of nums[nums.length-1] is nums[0]), return the next greater element for each element in **nums**. The next greater element of a number **x** is the first number that is larger than it following the array traversal order, which means you should search for its next greater number in a circular manner. If it does not exist, output -1.\nPlease use Python to first design an **ATSA** class, with an instance attribute **nums**, a private function **private_Array_traversal**, and a public function **public_Array_traversal**; then implement the above problem in the private function **private_Array_traversal**; finally, call the private function **private_Array_traversal** in the public function **public_Array_traversal** to return the result.", "test_list": ["assert candidate([1,2,1])==[2,-1,2]", "assert candidate([1,2,3,4,3])==[2,3,4,-1,4]"], "test_function": "def test_run(content1):\n    return ATSA(content1).public_Array_traversal()", "entry_point": "test_run", "test_matching": "assert candidate([['class ATSA', 'def _private_Array_traversal', 'def public_Array_traversal'], ['class ATSA', 'def __private_Array_traversal', 'def public_Array_traversal']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/169", "question": "Firstly, design an **RL** class using the Python language, which has an instance attribute **s**, a private function **private_Return_length**, and a public function **public_Return_length**. Then, in the private function **private_Return_length**, return the length of the longest palindromic subsequence in the string **s**. Finally, in the public function **public_Return_length**, call the private function **private_Return_length** to return the result.", "test_list": ["assert candidate(\"bbbab\")==4", "assert candidate(\"cbbd\")==2"], "test_function": "def test_run(content1):\n    return RL(content1).public_Return_length()", "entry_point": "test_run", "test_matching": "assert candidate([['class RL', 'def _private_Return_length', 'def public_Return_length'], ['class RL', 'def __private_Return_length', 'def public_Return_length']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/170", "question": "First, design an **NCC** class using the Python language, which has instance attributes **amount** and **coins**, a private function **coin_combinations**, and a public function **public_combinations**. Then, in the private function **coin_combinations**, return the number of coin combinations that can make up the total amount. Finally, in the public function **public_combinations**, call the private function **coin_combinations** to return the result.", "test_list": ["assert candidate([1, 2, 5])==4", "assert candidate([2])==0", "assert candidate([10])==1"], "test_function": "def test_run(content1):\n    return NCC(content1).public_combinations()", "entry_point": "test_run", "test_matching": "assert candidate([['class NCC', 'def _coin_combinations', 'def public_combinations'], ['class NCC', 'def __coin_combinations', 'def public_combinations']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/171", "question": "Firstly, design an **ML** class using Python language, which has an instance attribute **strs**, a private function **private_Maximum_length**, and a public function **public_Maximum_length**. Then, in the private function **private_Maximum_length**, return the length of the longest special sequence in the string list **strs**. If the longest special sequence does not exist, return -1. Finally, in the public function **public_Maximum_length**, call the private function **private_Maximum_length** to return the result.", "test_list": ["assert candidate([\"aba\",\"cdc\",\"eae\"])==3", "assert candidate([\"aaa\",\"aaa\",\"aa\"])==-1"], "test_function": "def test_run(content1):\n    return ML(content1).public_Maximum_length()", "entry_point": "test_run", "test_matching": "assert candidate([['class ML', 'def _private_Maximum_length', 'def public_Maximum_length'], ['class ML', 'def __private_Maximum_length', 'def public_Maximum_length']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/172", "question": "First, design an **LS** class using the Python language, which has instance attributes **s** and **dictionary**, a private function **private_Longest_string**, and a public function **public_Longest_string**. Then, in the private function **private_Longest_string**, return the longest string in the **dictionary**, which can be obtained by deleting some characters in **s**. If there is more than one answer, return the string with the longest length and the smallest lexicographical order. If there is no answer, return an empty string. Finally, in the public function **public_Longest_string**, call the private function **private_Longest_string** to return the result.", "test_list": ["assert candidate(\"abpcplea\",[\"ale\",\"apple\",\"monkey\",\"plea\"])==\"apple\"", "assert candidate(\"abpcplea\",[\"a\",\"b\",\"c\"])==\"a\""], "test_function": "def test_run(content1,content2):\n    return LS(content1,content2).public_Longest_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class LS', 'def _private_Longest_string', 'def public_Longest_string'], ['class LS', 'def __private_Longest_string', 'def public_Longest_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/173", "question": "Firstly, design an **AL** class using Python language, which has an instance attribute **nums**, a private function **private_Array_length**, and a public function **public_Array_length**. Then, find the longest consecutive subarray with the same number of 0 and 1 in the private function **private_Array_length**, and return the length of this subarray. Finally, call the private function **private_Array_length** in the public function **public_Array_length** to return the result.", "test_list": ["assert candidate([0,1])==2", "assert candidate([0,1,0])==2"], "test_function": "def test_run(content1):\n    return AL(content1).public_Array_length()", "entry_point": "test_run", "test_matching": "assert candidate([['class AL', 'def _private_Array_length', 'def public_Array_length'], ['class AL', 'def __private_Array_length', 'def public_Array_length']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/174", "question": "Firstly, design a class **CQ** using the Python language, which has an instance attribute **n**, a private function **private_Construction_quantity**, and a public function **public_Construction_quantity**. Then, in the private function **private_Construction_quantity**, return the number of beautiful arrangements that can be constructed. Finally, in the public function **public_Construction_quantity**, call the private function **private_Construction_quantity** to return the result.\n\nThe condition for a beautiful arrangement is: suppose there are **n** integers from 1 to **n**. Construct an array **perm** (index starts from 1) with these integers. As long as one of the following conditions is met, the array is a beautiful arrangement: 1. perm[i] can be divided by **i**; 2. **i** can be divided by perm[i].", "test_list": ["assert candidate(2)==2", "assert candidate(1)==1"], "test_function": "def test_run(content1):\n    return CQ(content1).public_Construction_quantity()", "entry_point": "test_run", "test_matching": "assert candidate([['class CQ', 'def _private_Construction_quantity', 'def public_Construction_quantity'], ['class CQ', 'def __private_Construction_quantity', 'def public_Construction_quantity']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/175", "question": "Firstly, design an **RS** class using the Python language, which has an instance attribute **w**, a private function **private_Return_Subscript**, and a public function **public_Return_Subscript**. Then, in the private function **private_Return_Subscript**, randomly select and return a subscript from the range [0, w.length-1] (including 0 and w.length-1), with the probability of selecting subscript **i** being w[i]/sum(w). Finally, in the public function **public_Return_Subscript**, call the private function **private_Return_Subscript** to return the result.", "test_list": ["assert candidate([\"Solution\",\"pickIndex\"],[[[1]],[]])==[null,0]", "assert candidate([\"Solution\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\",\"pickIndex\"],[[[1,3]],[],[],[],[],[]])==[null,1,1,1,1,0]"], "test_function": "def test_run(content1,content2):\n    return RS(content1,content2).public_Return_Subscript()", "entry_point": "test_run", "test_matching": "assert candidate([['class RS', 'def _private_Return_Subscript', 'def public_Return_Subscript'], ['class RS', 'def __private_Return_Subscript', 'def public_Return_Subscript']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/176", "question": "Firstly, design a class named **MG** using Python language, which has instance attributes **board** and **click**, a private function **private_Minesweeping_game**, and a public function **public_Minesweeping_game**. Then, implement the following problem in the private function **private_Minesweeping_game**. Finally, call the private function **private_Minesweeping_game** in the public function **public_Minesweeping_game** to return the result.\nProblem: Please design a minesweeper game represented by an m x n two-dimensional character matrix **board**. 'M', 'E', 'B', and 'X' respectively represent unexcavated mines, empty blocks, excavated blank blocks, and excavated mines. The specific rules are as follows: If a mine ('M') is excavated, the game ends, and it is changed to 'X'. If an empty block ('E') with no adjacent mines is excavated, change it to 'B', and all its adjacent unexcavated blocks should be recursively revealed. If an empty block ('E') adjacent to at least one mine is excavated, change it to a number ('1' to '8'), representing the number of adjacent mines. The requirement is to return the corresponding game board after the corresponding position is clicked.", "test_list": ["assert candidate([[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"M\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"],[\"E\",\"E\",\"E\",\"E\",\"E\"]],[3,0])==[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]", "assert candidate([[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"M\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]],[1,2])==[[\"B\",\"1\",\"E\",\"1\",\"B\"],[\"B\",\"1\",\"X\",\"1\",\"B\"],[\"B\",\"1\",\"1\",\"1\",\"B\"],[\"B\",\"B\",\"B\",\"B\",\"B\"]]"], "test_function": "def test_run(content1,content2):\n    return MG(content1,content2).public_Minesweeping_game()", "entry_point": "test_run", "test_matching": "assert candidate([['class MG', 'def _private_Minesweeping_game', 'def public_Minesweeping_game'], ['class MG', 'def __private_Minesweeping_game', 'def public_Minesweeping_game']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/177", "question": "Firstly, design a class **NP** using the Python language, which has instance attributes **nums** and **k**, a private function **private_Number_Pairs**, and a public function **public_Number_Pairs**. Then, return the number of different **k-diff** number pairs in the private function **private_Number_Pairs**. Finally, call the private function **private_Number_Pairs** in the public function **public_Number_Pairs** to return the result.", "test_list": ["assert candidate([3, 1, 4, 1, 5],2)==2", "assert candidate([1, 2, 3, 4, 5],1)==4", "assert candidate([1, 3, 1, 5, 4],0)==1"], "test_function": "def test_run(content1,content2):\n    return NP(content1,content2).public_Number_Pairs()", "entry_point": "test_run", "test_matching": "assert candidate([['class NP', 'def _private_Number_Pairs', 'def public_Number_Pairs'], ['class NP', 'def __private_Number_Pairs', 'def public_Number_Pairs']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/178", "question": "Firstly, design a **SOP** class using the Python language, which has instance attributes **num1** and **num2**, a private function **String_product**, and a public function **public_String_product**. Then, in the private function **String_product**, follow the complex number representation format, and return a string representing the product of complex numbers **num1** and **num2**. Finally, in the public function **public_String_product**, call the private function **String_product** to return the result.", "test_list": ["assert candidate(\"1+1i\",\"1+1i\")==\"0+2i\"", "assert candidate(\"1+-1i\",\"1+-1i\")==\"0+-2i\""], "test_function": "def test_run(content1,content2):\n    return SOP(content1,content2).public_String_product()", "entry_point": "test_run", "test_matching": "assert candidate([['class SOP', 'def _String_product', 'def public_String_product'], ['class SOP', 'def __String_product', 'def public_String_product']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/179", "question": "Firstly, design an **MTD** class using the Python language, which has an instance attribute **timePoints**, a private function **Minimum_difference**, and a public function **public_Minimum_difference**. Then, in the private function **Minimum_difference**, return the minimum time difference between any two times in the list, represented in minutes. Finally, in the public function **public_Minimum_difference**, call the private function **Minimum_difference** to return the result.", "test_list": ["assert candidate([\"23:59\",\"00:00\"])==1", "assert candidate([\"00:00\",\"23:59\",\"00:00\"])==0"], "test_function": "def test_run(content1):\n    return MTD(content1).public_Number_occurrences()", "entry_point": "test_run", "test_matching": "assert candidate([['class MTD', 'def _Minimum_difference', 'def public_Minimum_difference'], ['class MTD', 'def __Minimum_difference', 'def public_Minimum_difference']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/180", "question": "Firstly, design a class named **NOO** using Python language, which has an instance attribute **nums**, a private function **Number_occurrences**, and a public function **public_Number_occurrences**. Then, implement the following problem in the private function **Number_occurrences**. Finally, call the private function **Number_occurrences** in the public function **public_Number_occurrences** to return the result.\nProblem: Given a sorted array composed only of integers, where each element appears twice except for one that appears only once. Please find and return that single number.", "test_list": ["assert candidate([1,1,2,3,3,4,4,8,8])==2", "assert candidate([3,3,7,7,10,11,11])==10"], "test_function": "def test_run(content1):\n    return NOO(content1).public_Number_of_occurrences()", "entry_point": "test_run", "test_matching": "assert candidate([['class NOO', 'def _Number_occurrences', 'def public_Number_occurrences'], ['class NOO', 'def __Number_occurrences', 'def public_Number_occurrences']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/181", "question": "Firstly, design a class named **MS** using Python language, which has an instance attribute **mat**, a private function **private_Matrices_size**, and a public function **public_Matrices_size**. Then, implement the following problem in the private function **private_Matrices_size**. Finally, call the private function **private_Matrices_size** in the public function **public_Matrices_size** to return the result.\nProblem: Given a matrix **mat** composed of 0 and 1, output a matrix of the same size, where each cell is the distance from the corresponding element in **mat** to the nearest 0. The distance between two adjacent elements is 1.", "test_list": ["assert candidate([[0,0,0],[0,1,0],[0,0,0]])==[[0,0,0],[0,1,0],[0,0,0]]", "assert candidate([[0,0,0],[0,1,0],[1,1,1]])==[[0,0,0],[0,1,0],[1,2,1]]"], "test_function": "def test_run(content1):\n    return MS(content1).public_Matrices_size()", "entry_point": "test_run", "test_matching": "assert candidate([['class MS', 'def _private_Matrices_size', 'def public_Matrices_size'], ['class MS', 'def __private_Matrices_size', 'def public_Matrices_size']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/182", "question": "Firstly, design an **RB** class using Python language, which has an instance attribute **boxes**, a private function **private_Remove_Box**, and a public function **public_Remove_Box**. Then, implement the following problem in the private function **private_Remove_Box**. Finally, call the private function **private_Remove_Box** in the public function **public_Remove_Box** to return the result.\nProblem: Given some **boxes** of different colors, the color of the box is represented by different positive numbers. After several rounds of operations to remove the boxes until all the boxes are removed. In each round, you can remove **k** consecutive boxes of the same color (k >= 1), and you will get **k * k** points after such a round. Return the maximum sum of points that can be obtained.", "test_list": ["assert candidate([1,3,2,2,2,3,4,3,1])==23", "assert candidate([1,1,1])==9", "assert candidate([1])==1"], "test_function": "def test_run(content1):\n    return RB(content1).public_Remove_Box()", "entry_point": "test_run", "test_matching": "assert candidate([['class RB', 'def _private_Remove_Box', 'def public_Remove_Box'], ['class RB', 'def __private_Remove_Box', 'def public_Remove_Box']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/183", "question": "Firstly, design an **AP** class using the Python language, which has an instance attribute **nums**, a private function **private_Add_parentheses**, and a public function **public_Add_parentheses**. Then, implement the following problem in the private function **private_Add_parentheses**. Finally, call the private function **private_Add_parentheses** in the public function **public_Add_parentheses** to return the result.\nProblem: Please perform floating-point division on a positive integer array **nums**. You can add any number of parentheses at any position to change the priority of arithmetic. Return the corresponding expression in string format with the maximum value.", "test_list": ["assert candidate([1000,100,10,2])==\"1000/(100/10/2)\"", "assert candidate([2,3,4])==\"2/(3/4)\""], "test_function": "def test_run(content1):\n    return AP(content1).public_Add_parentheses()", "entry_point": "test_run", "test_matching": "assert candidate([['class AP', 'def _private_Add_parentheses', 'def public_Add_parentheses'], ['class AP', 'def __private_Add_parentheses', 'def public_Add_parentheses']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/184", "question": "Firstly, design an **MI** class using Python language, which has an instance attribute **n**, a private function **private_Minimum_integer**, and a public function **public_Minimum_integer**. Then, implement the following problem in the private function **private_Minimum_integer**. Finally, call the private function **private_Minimum_integer** in the public function **public_Minimum_integer** to return the result.\nProblem: Given a positive integer **n**, find the smallest integer that meets the conditions, which is composed of each digit existing in **n** rearranged, and its value is greater than **n**. If there is no such positive integer, return -1.", "test_list": ["assert candidate(12)==21", "assert candidate(21)==-1"], "test_function": "def test_run(content1):\n    return MI(content1).public_Minimum_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class MI', 'def _private_Minimum_integer', 'def public_Minimum_integer'], ['class MI', 'def __private_Minimum_integer', 'def public_Minimum_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/185", "question": "Firstly, design an **IS** class using the Python language, which has an instance attribute **s**, a private function **private_Invert_String**, and a public function **public_Invert_String**. Then, in the private function **private_Invert_String**, output the string after reversing the character order of each word in the string, while still retaining the spaces and the initial order of the words. Finally, call the private function **private_Invert_String** in the public function **public_Invert_String** to return the result.", "test_list": ["assert candidate(\"Let's take LeetCode contest\")==\"s'teL ekat edoCteeL tsetnoc\"", "assert candidate(\"God Ding\")==\"doG gniD\""], "test_function": "def test_run(content1):\n    return IS(content1).public_Invert_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class IS', 'def _private_Invert_String', 'def public_Invert_String'], ['class IS', 'def __private_Invert_String', 'def public_Invert_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/186", "question": "Firstly, design a **CS** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Continuous_subarray**, and a public function **public_Continuous_subarray**. Then, in the private function **private_Continuous_subarray**, count and return the number of continuous subarrays in the array whose sum is **k**. Finally, call the private function **private_Continuous_subarray** in the public function **public_Continuous_subarray** to return the result.", "test_list": ["assert candidate([1,1,1],2)==2", "assert candidate([1,2,3],3)==2"], "test_function": "def test_run(content1,content2):\n    return CS(content1,content2).public_Continuous_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class CS', 'def _private_Continuous_subarray', 'def public_Continuous_subarray'], ['class CS', 'def __private_Continuous_subarray', 'def public_Continuous_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/187", "question": "Firstly, design a class **PI** using the Python language, which has an instance attribute **n**, a private function **private_Palindrome_integer**, and a public function **public_Palindrome_integer**. Then, in the private function **private_Palindrome_integer**, return the palindrome integer closest to the string **n** (excluding itself). If there is more than one, return the smaller one. **Closest** is defined as the smallest absolute difference between two integers. Finally, in the public function **public_Palindrome_integer**, call the private function **private_Palindrome_integer** to return the result.", "test_list": ["assert candidate(\"123\")==\"121\"", "assert candidate(\"1\")==\"0\""], "test_function": "def test_run(content1):\n    return PI(content1).public_Palindrome_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class PI', 'def _private_Palindrome_integer', 'def public_Palindrome_integer'], ['class PI', 'def __private_Palindrome_integer', 'def public_Palindrome_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/188", "question": "Firstly, design a class **JA** using the Python language, which has instance attributes **s1** and **s2**, a private function **private_Judgment_arrangement**, and a public function **public_Judgment_arrangement**. Then, in the private function **private_Judgment_arrangement**, determine whether **s2** contains the arrangement of **s1**. If it does, return **True**; otherwise, return **False**. Finally, call the private function **private_Judgment_arrangement** in the public function **public_Judgment_arrangement** to return the result.", "test_list": ["assert candidate(\"ab\",\"eidbaooo\")==True", "assert candidate(\"ab\",\"eidboaoo\")==False"], "test_function": "def test_run(content1,content2):\n    return JA(content1,content2).public_Judgment_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([['class JA', 'def _private_Judgment_arrangement', 'def public_Judgment_arrangement'], ['class JA', 'def __private_Judgment_arrangement', 'def public_Judgment_arrangement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/189", "question": "Firstly, design a class named **SS** using the Python language, which includes an instance attribute **nums**, a private function **private_Shortest_subarray**, and a public function **public_Shortest_subarray**. Then, implement the following problem in the private function **private_Shortest_subarray**. Finally, call the private function **private_Shortest_subarray** in the public function **public_Shortest_subarray** to return the result.\nProblem: Given an integer array **nums**, you need to find a continuous subarray. If this subarray is sorted in ascending order, then the entire array will become sorted in ascending order. Please find the shortest subarray that meets this requirement and output its length.", "test_list": ["assert candidate([2,6,4,8,10,9,15])==5", "assert candidate([1,2,3,4])==0", "assert candidate([1])==0"], "test_function": "def test_run(content1):\n    return SS(content1).public_Shortest_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class SS', 'def _private_Shortest_subarray', 'def public_Shortest_subarray'], ['class SS', 'def __private_Shortest_subarray', 'def public_Shortest_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/190", "question": "Firstly, design a class named **MS** using the Python language, which has instance attributes **word1** and **word2**, a private function **private_Minimum_Steps**, and a public function **public_Minimum_Steps**. Then, in the private function **private_Minimum_Steps**, return the minimum number of steps required to make **word1** and **word2** identical. Finally, in the public function **public_Minimum_Steps**, call the private function **private_Minimum_Steps** to return the result.", "test_list": ["assert candidate(\"sea\",\"eat\")==2", "assert candidate(\"leetcode\",\"etco\")==4"], "test_function": "def test_run(content1,content2):\n    return MS(content1,content2).public_Minimum_Steps()", "entry_point": "test_run", "test_matching": "assert candidate([['class MS', 'def _private_Minimum_Steps', 'def public_Minimum_Steps'], ['class MS', 'def __private_Minimum_Steps', 'def public_Minimum_Steps']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/191", "question": "Firstly, design an **RC** class using the Python language, which has an instance attribute **trees**, a private function **private_Return_Coordinates**, and a public function **public_Return_Coordinates**. Then, implement the following problem in the private function **private_Return_Coordinates**. Finally, call the private function **private_Return_Coordinates** in the public function **public_Return_Coordinates** to return the result.\nProblem: Given an array **trees**, where trees[i]=[x_i, y_i] represents the location of the tree in the garden. You are required to enclose the entire garden with the shortest length of rope because the rope is expensive. The garden is well enclosed only when all the trees are enclosed. Return the coordinates of the trees that are exactly on the perimeter of the fence.", "test_list": ["assert candidate([[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]])==[[1,1],[2,0],[3,3],[2,4],[4,2]]", "assert candidate([[1,2],[2,2],[4,2]])==[[4,2],[2,2],[1,2]]"], "test_function": "def test_run(content1):\n    return RC(content1).public_Return_Coordinates()", "entry_point": "test_run", "test_matching": "assert candidate([['class RC', 'def _private_Return_Coordinates', 'def public_Return_Coordinates'], ['class RC', 'def __private_Return_Coordinates', 'def public_Return_Coordinates']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/192", "question": "First, design a class named **MS** using Python language, which has an instance attribute **expression**, a private function **private_Minimal_Score**, and a public function **public_Minimal_Score**. Then, implement the following problem in the private function **private_Minimal_Score**. Finally, call the private function **private_Minimal_Score** in the public function **public_Minimal_Score** to return the result.\nProblem: Given a string **expression** representing addition and subtraction of scores, you need to return a string form of the calculated result. This result should be an irreducible fraction, that is, the simplest fraction. If the final result is an integer, for example, an integer 2, you need to convert it into a fraction form with a denominator of 1. So in the above example, 2 should be converted to 2/1.", "test_list": ["assert candidate(\"-1/2+1/2\")==\"0/1\"", "assert candidate(\"-1/2+1/2\")==\"0/1\"", "assert candidate(\"1/3-1/2\")==\"-1/6\""], "test_function": "def test_run(content1):\n    return MS(content1).public_Minimal_Score()", "entry_point": "test_run", "test_matching": "assert candidate([['class MS', 'def _private_Minimal_Score', 'def public_Minimal_Score'], ['class MS', 'def __private_Minimal_Score', 'def public_Minimal_Score']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/193", "question": "Firstly, design a **FAS** class using the Python language, which has instance attributes **p1**, **p2**, **p3**, and **p4**, a private function **Form_square**, and a public function **public_Form_square**. Then, in the private function **Form_square**, determine whether the four points form a square. If they do, return True; otherwise, return False. Finally, in the public function **public_Form_square**, call the private function **Form_square** to return the result.", "test_list": ["assert candidate([0,0],[1,1],[1,0],[0,1])==True", "assert candidate([0,0],[1,1],[1,0],[0,12])==False", "assert candidate([1,0],[-1,0],[0,1],[0,-1])==False"], "test_function": "def test_run(content1,content2,content3,content4):\n    return FAS(content1,content2,content3,content4).public_Form_square()", "entry_point": "test_run", "test_matching": "assert candidate([['class FAS', 'def _Form_square', 'def public_Form_a_square'], ['class FAS', 'def __Form_square', 'def public_Form_a_square']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/194", "question": "Firstly, design a **TC** class using Python language, which has an instance attribute **n**, a private function **private_There_continuity**, and a public function **public_There_continuity**. Then, in the private function **private_There_continuity**, count how many non-negative integers in the range of [0, n] do not have consecutive 1 in their binary representation. Finally, call the private function **private_There_continuity** in the public function **public_There_continuity** to return the result.", "test_list": ["assert candidate(5)==5", "assert candidate(1)==2", "assert candidate(2)==3"], "test_function": "def test_run(content1):\n    return TC(content1).public_There_continuity()", "entry_point": "test_run", "test_matching": "assert candidate([['class TC', 'def _private_There_continuity', 'def public_There_continuity'], ['class TC', 'def __private_There_continuity', 'def public_There_continuity']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/195", "question": "Firstly, design a **NOT** class using Python language, which has an instance attribute **nums**, a private function **private_Number_of_triples**, and a public function **public_Number_of_triples**. Then, in the private function **private_Number_of_triples**, return the number of triples that **nums** can form the three sides of a triangle. Finally, in the public function **public_Number_of_triples**, call the private function **private_Number_of_triples** to return the result.", "test_list": ["assert candidate([2,2,3,4])==3", "assert candidate([4,2,3,4])==4"], "test_function": "def test_run(content1):\n    return NOT(content1).public_Number_of_triples()", "entry_point": "test_run", "test_matching": "assert candidate([['class NOT', 'def _private_Number_of_triples', 'def public_Number_of_triples'], ['class NOT', 'def __private_Number_of_triples', 'def public_Number_of_triples']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/196", "question": "Firstly, design an **MT** class using Python language, which has instance attributes **tasks** and **n**, a private function **private_Minimum_time**, and a public function **public_Minimum_time**. Then, implement the following problem in the private function **private_Minimum_time**. Finally, call the private function **private_Minimum_time** in the public function **public_Minimum_time** to return the result.\nProblem: Given a list of tasks that the CPU needs to execute, represented by a character array **tasks**. Each letter represents a different type of task. Tasks can be executed in any order, and each task can be completed within 1 unit of time. In any unit of time, the CPU can complete a task or be in standby mode. However, there must be a cooling time of integer **n** between two tasks of the same type, so the CPU must be executing different tasks or in standby mode for at least continuous **n** units of time. Calculate the shortest time required to complete all tasks.", "test_list": ["assert candidate([\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"],2)==8", "assert candidate([\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"],0)==6", "assert candidate([\"A\",\"A\",\"A\",\"A\",\"A\",\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"],2)==16"], "test_function": "def test_run(content1,content2):\n    return MT(content1,content2).public_Minimum_time()", "entry_point": "test_run", "test_matching": "assert candidate([['class MT', 'def _private_Minimum_time', 'def public_Minimum_time'], ['class MT', 'def __private_Minimum_time', 'def public_Minimum_time']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/197", "question": "Firstly, design a class named **ROP** using the Python language, which has instance attributes **n** and **k**, a private function **private_Reverse_order_pair**, and a public function **public_Reverse_order_pair**. Then, implement the following problem in the private function **private_Reverse_order_pair**. Finally, call the private function **private_Reverse_order_pair** in the public function **public_Reverse_order_pair** to return the result.\nProblem: Please find out the number of different arrays that contain numbers from 1 to **n** and exactly have **k** reverse order pairs. Definition of reverse order pair: For the i-th and j-th elements of the array **nums**, if it satisfies 0<=i<j<nums.length and nums[i]>nums[j], it is a reverse order pair; otherwise, it is not.", "test_list": ["assert candidate(3,0)==1", "assert candidate(3,1)==2"], "test_function": "def test_run(content1,content2):\n    return ROP(content1,content2).public_Reverse_order_pair()", "entry_point": "test_run", "test_matching": "assert candidate([['class ROP', 'def _private_Reverse_order_pair', 'def public_Reverse_order_pair'], ['class ROP', 'def __private_Reverse_order_pair', 'def public_Reverse_order_pair']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/198", "question": "Firstly, design an **NCT** class using Python language, which has an instance attribute **courses**, a private function **private_Number_courses_taken**, and a public function **public_Number_courses_taken**. Then, implement the following problem in the private function **private_Number_courses_taken**. Finally, call the private function **private_Number_courses_taken** in the public function **public_Number_courses_taken** to return the result.\nProblem: Here are **n** different online courses, numbered from 1 to **n**. Given an array **courses**, where courses[i] = [duration_i, lastDay_i] indicates that the i-th course will last for **duration_i** days, and must be completed no later than **lastDay_i**. Your semester starts from the first day and you cannot take two or more courses at the same time. Return the maximum number of courses you can take.", "test_list": ["assert candidate([[100,200],[200,1300],[1000,1250],[2000,3200]])==3", "assert candidate([[1,2]])==1", "assert candidate([[3,2],[4,3]])==0"], "test_function": "def test_run(content1):\n    return NCT(content1).public_Number_courses_taken()", "entry_point": "test_run", "test_matching": "assert candidate([['class NCT', 'def _private_Number_courses_taken', 'def public_Number_courses_taken'], ['class NCT', 'def __private_Number_courses_taken', 'def public_Number_courses_taken']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/199", "question": "Firstly, design a class **JI** using the Python language, which has an instance attribute **c**, a private function **private_Judging_integers**, and a public function **public_Judging_integers**. Then, in the private function **private_Judging_integers**, determine whether there exist two integers **a** and **b** such that a^2 + b^2 = c. If they exist, return True, otherwise, return False. Finally, call the private function **private_Judging_integers** in the public function **public_Judging_integers** to return the result.", "test_list": ["assert candidate(5)==True", "assert candidate(3)==False"], "test_function": "def test_run(content1):\n    return JI(content1).public_Judging_integers()", "entry_point": "test_run", "test_matching": "assert candidate([['class JI', 'def _private_Judging_integers', 'def public_Judging_integers'], ['class JI', 'def __private_Judging_integers', 'def public_Judging_integers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/200", "question": "First, design a class **SE** using the Python language, which has an instance attribute **equation**, a private function **private_solve_equation**, and a public function **public_solve_equation**. Then, implement the following problem in the private function **private_solve_equation**. Finally, call the private function **private_solve_equation** in the public function **public_solve_equation** to return the result.\nProblem: Solve a given equation and return **x** in the form of a string **x=#value**. The equation only contains '+' and '-' operations, the variable **x** and its corresponding coefficient. If the equation has no solution or the existing solution is not an integer, please return **No solution**. If the equation has infinite solutions, return **Infinite solutions**.", "test_list": ["assert candidate(\"x+5-3+x=6+x-2\")==\"x=2\"", "assert candidate(\"x=x\")==\"Infinite solutions\"", "assert candidate(\"2x=x\")==\"x=0\""], "test_function": "def test_run(content1):\n    return SE(content1).public_solve_equation()", "entry_point": "test_run", "test_matching": "assert candidate([['class SE', 'def _private_solve_equation', 'def public_solve_equation'], ['class SE', 'def __private_solve_equation', 'def public_solve_equation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/201", "question": "Firstly, design an **LPC** class using Python language, which has an instance attribute **pairs**, a private function **private_Longest_pair_chain**, and a public function **public_Longest_pair_chain**. Then, implement the following problem in the private function **private_Longest_pair_chain**. Finally, call the private function **private_Longest_pair_chain** in the public function **public_Longest_pair_chain** to return the result.\nProblem: Given an array of pairs **pairs** composed of n pairs, where pairs[i] = [left_i, right_i] and left_i < right_i. Now, define a following relationship, where pair p2 = [c, d] can only follow p1 = [a, b] if and only if b < c. Use this form to construct a pair chain, find and return the length of the longest pair chain that can be formed.", "test_list": ["assert candidate([[1,2], [2,3], [3,4]])==2", "assert candidate([[1,2],[7,8],[4,5]])==3"], "test_function": "def test_run(content1):\n    return LPC(content1).public_Longest_pair_chain()", "entry_point": "test_run", "test_matching": "assert candidate([['class LPC', 'def _private_Longest_pair_chain', 'def public_Longest_pair_chain'], ['class LPC', 'def __private_Longest_pair_chain', 'def public_Longest_pair_chain']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/202", "question": "Firstly, design a **PS** class using Python language, which has an instance attribute **s**, a private function **private_Palindrome_substring**, and a public function **public_Palindrome_substring**. Then, return the number of palindrome substrings in the string **s** within the private function **private_Palindrome_substring**. Finally, call the private function **private_Palindrome_substring** to return the result within the public function **public_Palindrome_substring**.", "test_list": ["assert candidate(\"abc\")==3", "assert candidate(\"aaa\")==6"], "test_function": "def test_run(content1):\n    return PS(content1).public_Palindrome_substring()", "entry_point": "test_run", "test_matching": "assert candidate([['class PS', 'def _private_Palindrome_substring', 'def public_Palindrome_substring'], ['class PS', 'def __private_Palindrome_substring', 'def public_Palindrome_substring']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/203", "question": "Firstly, design an **RS** class using the Python language, which has instance attributes **dictionary** and **sentence**, a private function **private_Root_substitution**, and a public function **public_Root_substitution**. Then, implement the following problem in the private function **private_Root_substitution**. Finally, call the private function **private_Root_substitution** in the public function **public_Root_substitution** to return the result.\n\nProblem: In English, there is a concept called **root**, where you can add other words after the root to form a longer word, which is called a **successor** word. For example, the root **an**, followed by the word **other**, can form a new word **another**. Now, given a **dictionary** composed of many roots and a **sentence** formed by words separated by spaces. You need to replace all the successor words in the sentence with the root. If there are many roots that can form the successor word, replace it with the shortest root. You need to output the sentence after the replacement.", "test_list": ["assert candidate([\"cat\",\"bat\",\"rat\"],\"the cattle was rattled by the battery\")==\"the cat was rat by the bat\"", "assert candidate([\"a\",\"b\",\"c\"],\"aadsfasf absbs bbab cadsfafs\")==\"a a b c\""], "test_function": "def test_run(content1,content2):\n    return RS(content1,content2).public_Root_substitution()", "entry_point": "test_run", "test_matching": "assert candidate([['class RS', 'def _private_Root_substitution', 'def public_Root_substitution'], ['class RS', 'def __private_Root_substitution', 'def public_Root_substitution']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/204", "question": "Firstly, design an **MNO** class using Python language, which has an instance attribute **n**, a private function **Minimum_operations**, and a public function **public_Minimum_operations**. Then, implement the following problem in the private function **Minimum_operations**. Finally, call the private function **Minimum_operations** in the public function **public_Minimum_operations** to return the result.\nProblem: Initially, there is only one character 'A' on the notepad. You can perform two types of operations on this notepad each time: 1. Copy All: Copy all characters in this notepad (partial copying is not allowed); 2. Paste: Paste the characters copied last time. Given a number **n**, you need to use the minimum number of operations to output exactly **n** 'A's on the notepad. Return the minimum number of operations that can print out **n** 'A's.", "test_list": ["assert candidate(3)==3", "assert candidate(1)==0"], "test_function": "def test_run(content1):\n    return MNO(content1).public_Minimum_operations()", "entry_point": "test_run", "test_matching": "assert candidate([['class MNO', 'def _Minimum_operations', 'def public_Minimum_operations'], ['class MNO', 'def __Minimum_operations', 'def public_Minimum_operations']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/205", "question": "Firstly, design an **FPV** class using Python language, which has instance attributes **arr**, **k**, and **x**, a private function **private_Find_Proximity_Values**, and a public function **public_Find_Proximity_Values**. Then, implement the following problem in the private function **private_Find_Proximity_Values**. Finally, call the private function **private_Find_Proximity_Values** in the public function **public_Find_Proximity_Values** to return the result.\nProblem: Given a sorted array **arr**, two integers **k** and **x**, find the **k** numbers closest to **x** (the difference between the two numbers is the smallest) from the array. The returned result must be sorted in ascending order. An integer **a** is closer to **x** than an integer **b** if: |a-x| < |b-x| or |a-x| == |b-x| and a < b.", "test_list": ["assert candidate([1,2,3,4,5],4,3)==[1,2,3,4]", "assert candidate([1,2,3,4,5],4,-1)==[1,2,3,4]"], "test_function": "def test_run(content1,content2,content3):\n    return FPV(content1,content2,content3).public_Find_Proximity_Values()", "entry_point": "test_run", "test_matching": "assert candidate([['class FPV', 'def _private_Find_Proximity_Values', 'def public_Find_Proximity_Values'], ['class FPV', 'def __private_Find_Proximity_Values', 'def public_Find_Proximity_Values']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/206", "question": "Firstly, design a **JS** class using the Python language, which has an instance attribute **nums**, a private function **private_Judgment_segmentation**, and a public function **public_Judgment_segmentation**. Then, implement the following problem in the private function **private_Judgment_segmentation**. Finally, call the private function **private_Judgment_segmentation** in the public function **public_Judgment_segmentation** to return the result.\nProblem: Given an integer array **nums** sorted in non-decreasing order. Please judge whether it is possible to satisfy the following two conditions while dividing **nums** into one or more sub-sequences: each sub-sequence is a continuous increasing sequence (that is, each integer is exactly one larger than the previous one); the length of all sub-sequences is at least 3. If **nums** can be divided and meet the above conditions, return True; otherwise, return False.", "test_list": ["assert candidate([1,2,3,3,4,5])==True", "assert candidate([1,2,3,3,4,4,5,5])==True", "assert candidate([1,2,3,4,4,5])==False"], "test_function": "def test_run(content1):\n    return JS(content1).public_Judgment_segmentation()", "entry_point": "test_run", "test_matching": "assert candidate([['class JS', 'def _private_Judgment_segmentation', 'def public_Judgment_segmentation'], ['class JS', 'def _private_Judgment_segmentation', 'def public_Judgment_segmentation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/207", "question": "Firstly, design an **MPT** class using Python language, which has an instance attribute **s**, a private function **Minimum_Times**, and a public function **public_Minimum_Times**. Then, implement the following problem in the private function **Minimum_Times**. Finally, call the private function **Minimum_Times** in the public function **public_Minimum_Times** to return the result.\nProblem: There is a strange printer with the following two special requirements: 1. The printer can only print a sequence composed of the same character each time; 2. It can print a new character at any position from the beginning to the end each time, and it will overwrite the original characters. Given a string **s**, your task is to calculate the minimum number of times this printer needs to print it.", "test_list": ["assert candidate(\"aaabbb\")==2", "assert candidate(\"aba\")==2"], "test_function": "def test_run(content1):\n    return MPT(content1).public_Minimum_Times()", "entry_point": "test_run", "test_matching": "assert candidate([['class MPT', 'def _Minimum_Times', 'def public_Minimum_Times'], ['class MPT', 'def __Minimum_Times', 'def public_Minimum_Times']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/208", "question": "Firstly, design an **NDC** class using Python language, which has an instance attribute **nums**, a private function **private_Non_decreasing_column**, and a public function **public_Non_decreasing_column**. Then, implement the following problem in the private function **private_Non_decreasing_column**. Finally, call the private function **private_Non_decreasing_column** in the public function **public_Non_decreasing_column** to return the result.\nProblem: Given an integer array **nums** of length **n**, please determine whether this array can become a non-decreasing sequence by changing at most one element. Definition of non-decreasing sequence: For any **i** (0 <= i <= n-2) in the array, it always satisfies that nums[i]<= nums[i + 1].", "test_list": ["assert candidate([4,2,3])==True", "assert candidate([4,2,1])==False"], "test_function": "def test_run(content1):\n    return NDC(content1).public_Non_decreasing_column()", "entry_point": "test_run", "test_matching": "assert candidate([['class NDC', 'def _private_Non_decreasing_column', 'def public_Non_decreasing_column'], ['class NDC', 'def __private_Non_decreasing_column', 'def public_Non_decreasing_column']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/209", "question": "Firstly, design an **AL** class using Python language, which has instance attributes **n** and **k**, a private function **private_Answer_List**, and a public function **public_Answer_List**. Then, return the constructed answer list **answer** in the private function **private_Answer_List**. Finally, call the private function **private_Answer_List** in the public function **public_Answer_List** to return the result.\nProblem: Given two integers **n** and **k**, please construct an answer list **answer**. This list should contain **n** different positive integers from 1 to **n**, and at the same time meet the following condition: Assuming the list is answer=[a1, a2, a3, ... , an], then the list [|a1 - a2|,|a2 - a3|,|a3 - a4|,...,|an-1 - an|] should have exactly **k** different integers. Return the list **answer**.", "test_list": ["assert candidate(3,1)==[1, 2, 3]", "assert candidate(3,2)==[1, 3, 2]"], "test_function": "def test_run(content1,content2):\n    return AL(content1,content2).public_Answer_List()", "entry_point": "test_run", "test_matching": "assert candidate([['class AL', 'def _private_Answer_List', 'def public_Answer_List'], ['class AL', 'def _private_Answer_List', 'def public_Answer_List']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/210", "question": "Firstly, design a class named **LIS** using Python language, which has instance attribute **nums**, a private function **lo_in_sub**, and a public function **public_lo_in_sub**. Then, in the private function **lo_in_sub**, return the count of the longest increasing subsequence from the unsorted integer array **nums**. Finally, in the public function **public_lo_in_sub**, call the private function **lo_in_sub** to return the result.", "test_list": ["assert candidate([1,3,5,4,7])==2", "assert candidate([2,2,2,2,2])==5"], "test_function": "def test_run(content1):\n    return LIS(content1).public_lo_in_sub()", "entry_point": "test_run", "test_matching": "assert candidate([['class LIS', 'def _lo_in_sub', 'def public_lo_in_sub'], ['class LIS', 'def __lo_in_sub', 'def public_lo_in_sub']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/211", "question": "Firstly, design a **CDT** class using Python language, which has an instance attribute **forest**, a private function **private_Chop_down_trees**, and a public function **public_Chop_down_trees**. Then, implement the following problem in the private function **private_Chop_down_trees**. Finally, call the private function **private_Chop_down_trees** in the public function **public_Chop_down_trees** to return the result.\nProblem: The forest is represented by an m x n matrix. In this matrix, 0 represents an obstacle that cannot be touched; 1 represents the ground where you can walk. Numbers larger than 1 represent cells with trees, which can be walked on, and the number represents the height of the tree. At each step, you can move one unit in one of the four directions: up, down, left, or right. If there is a tree where you stand, you can decide whether to cut it down. You need to cut down all the trees from low to high according to the height of the trees. After cutting down a tree, the value of the cell becomes **1** (i.e., it becomes the ground). You will start working from the point (0, 0), and return the minimum number of steps you need to take to cut down all the trees. If you cannot cut down all the trees, return -1.", "test_list": ["assert candidate([[1,2,3],[0,0,4],[7,6,5]])==6", "assert candidate([[1,2,3],[0,0,0],[7,6,5]])==-1", "assert candidate([[2,3,4],[0,0,5],[8,7,6]])==6"], "test_function": "def test_run(content1):\n    return CDT(content1).public_Chop_down_trees()", "entry_point": "test_run", "test_matching": "assert candidate([['class CDT', 'def _private_Chop_down_trees', 'def public_Chop_down_trees'], ['class CDT', 'def __private_Chop_down_trees', 'def public_Chop_down_trees']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/212", "question": "Firstly, design a **VS** class using Python language, which has an instance attribute **s**, a private function **private_Valid_String**, and a public function **public_Valid_String**. Then, implement the following problem in the private function **private_Valid_String**. Finally, call the private function **private_Valid_String** in the public function **public_Valid_String** and return the result.\nProblem: Given a string that only contains three types of characters, the supported character types are '(', ')', and '*'. Please check whether this string is a valid string. If it is a valid string, return True; otherwise, return False.", "test_list": ["assert candidate(\"()\")==True", "assert candidate(\"(*)\")==True", "assert candidate(\"(*))\")==True"], "test_function": "def test_run(content1):\n    return VS(content1).public_Valid_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class VS', 'def _private_Valid_String', 'def public_Valid_String'], ['class VS', 'def __private_Valid_String', 'def public_Valid_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/213", "question": "Firstly, design a class **ME** using the Python language, which has an instance attribute **cards**, a private function **private_mathematical_expression**, and a public function **public_mathematical_expression**. Then, implement the following problem in the private function **private_mathematical_expression**. Finally, call the private function **private_mathematical_expression** in the public function **public_mathematical_expression** to return the result.\nProblem: Given an integer array **cards** of length 4. Assume there are 4 cards, each containing a number ranging from [1,9]. You should arrange the numbers on these cards into a mathematical expression using the operators ['+', '-', '*', '/'] and parentheses '(' and ')' to achieve the value 24. You must follow these rules: 1. The division operator '/' represents real number division, not integer division; 2. Each operation is between two numbers. Specifically, you cannot use \"-\" as a unary operator. For example, if cards = [1,1,1,1], the expression \"-1 -1 -1 -1\" is not allowed; 3. You cannot string numbers together. If cards = [1,2,1,2], the expression \"12 + 12\" is invalid. If such an expression can be obtained and its calculation result is 24, return True, otherwise return False.", "test_list": ["assert candidate([4, 1, 8, 7])==True", "assert candidate([1, 2, 1, 2])==False"], "test_function": "def test_run(content1):\n    return ME(content1).public_mathematical_expression()", "entry_point": "test_run", "test_matching": "assert candidate([['class ME', 'def _private_mathematical_expression', 'def public_mathematical_expression'], ['class ME', 'def __private_mathematical_expression', 'def public_mathematical_expression']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/214", "question": "Firstly, design an **OS** class using Python language, which has instance attributes **a** and **b**, a private function **private_Overlay_substring**, and a public function **public_Overlay_substring**. Then, implement the following problem in the private function **private_Overlay_substring**. Finally, call the private function **private_Overlay_substring** in the public function **public_Overlay_substring** to return the result.\nProblem: Given two strings **a** and **b**, find the minimum number of times string **a** needs to be repeatedly overlaid so that string **b** becomes a substring of the overlaid string **a**. If it does not exist, return -1.", "test_list": ["assert candidate(\"abcd\",\"cdabcdab\")==3", "assert candidate(\"a\",\"aa\")==2", "assert candidate(\"a\",\"a\")==1", "assert candidate(\"abc\",\"wxyz\")==-1"], "test_function": "def test_run(content1,content2):\n    return OS(content1,content2).public_Overlay_substring()", "entry_point": "test_run", "test_matching": "assert candidate([['class OS', 'def _private_Overlay_substring', 'def public_Overlay_substring'], ['class OS', 'def __private_Overlay_substring', 'def public_Overlay_substring']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/215", "question": "Firstly, design a **KC** class using Python language, which has instance attributes **n**, **k**, **row**, and **column**, a private function **private_Knight_Chessboard**, and a public function **public_Knight_Chessboard**. Then, implement the following problem in the private function **private_Knight_Chessboard**. Finally, call the private function **private_Knight_Chessboard** in the public function **public_Knight_Chessboard** to return the result.\nProblem: On an n x n international chessboard, a knight starts from the cell (row, column) and tries to make **k** moves. Rows and columns start from 0, so the top-left cell is (0,0), and the bottom-right cell is (n - 1, n - 1). The chess knight has 8 possible moves, each move is two cells in the basic direction, then one cell in the orthogonal direction. Each time the knight is to move, it randomly selects one from the 8 possible moves (even if the piece will leave the board), and then moves there. The knight continues to move until it has taken **k** steps or has left the board. Return the probability that the knight still remains on the board after it stops moving.", "test_list": ["assert candidate(3,2,0,0)==0.0625", "assert candidate(1,0,0,0)==1.00000"], "test_function": "def test_run(content1,content2,content3,content4):\n    return KC(content1,content2,content3,content4).public_Knight_Chessboard()", "entry_point": "test_run", "test_matching": "assert candidate([['class KC', 'def _private_Knight_Chessboard', 'def public_Knight_Chessboard'], ['class KC', 'def __private_Knight_Chessboard', 'def public_Knight_Chessboard']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/216", "question": "Firstly, design an **MS** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Maximum_subarray**, and a public function **public_Maximum_subarray**. Then, implement the following problem in the private function **private_Maximum_subarray**. Finally, call the private function **private_Maximum_subarray** in the public function **public_Maximum_subarray** to return the result.\nProblem: Given an integer array **nums** and an integer **k**, find three non-overlapping subarrays of length **k** with the maximum sum of all numbers (3*k items) and return these three subarrays.", "test_list": ["assert candidate([1,2,1,2,6,7,5,1],2)==[0,3,5]", "assert candidate([1,2,1,2,1,2,1,2,1],2)==[0,2,4]"], "test_function": "def test_run(content1,content2):\n    return MS(content1,content2).public_Maximum_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class MS', 'def _private_Maximum_subarray', 'def public_Maximum_subarray'], ['class MS', 'def __private_Maximum_subarray', 'def public_Maximum_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/217", "question": "Firstly, design a class named **SW** using Python language, which has instance attributes **stickers** and **target**, a private function **private_Sticker_Words**, and a public function **public_Sticker_Words**. Then, implement the following problem in the private function **private_Sticker_Words**. Finally, call the private function **private_Sticker_Words** in the public function **public_Sticker_Words** to return the result.\nProblem: There are **n** different types of stickers, each with a lowercase English word on it. You want to spell out a given string **target** by cutting individual letters from the collected stickers and rearranging them. If you wish, you can use each sticker multiple times, and the quantity of each sticker is unlimited. Return the minimum number of stickers required to spell out the **target**. If the task is impossible, return -1.", "test_list": ["assert candidate([\"with\",\"example\",\"science\"],\"thehat\")==3", "assert candidate([\"notice\",\"possible\"],\"basicbasic\")==-1"], "test_function": "def test_run(content1,content2):\n    return SW(content1,content2).public_Sticker_Words()", "entry_point": "test_run", "test_matching": "assert candidate([['class SW', 'def _private_Sticker_Words', 'def public_Sticker_Words'], ['class SW', 'def __private_Sticker_Words', 'def public_Sticker_Words']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/218", "question": "Firstly, design an **MT** class using the Python language, which has instance attributes **words** and **k**, a private function **private_Most_times**, and a public function **public_Most_times**. Then, in the private function **private_Most_times**, return the top **k** most frequently occurring words from a given word list **words** and an integer **k**. Finally, call the private function **private_Most_times** in the public function **public_Most_times** to return the result.", "test_list": ["assert candidate([\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"],2)==[\"i\", \"love\"]", "assert candidate([\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"],4)==[\"the\", \"is\", \"sunny\", \"day\"]"], "test_function": "def test_run(content1,content2):\n    return MT(content1,content2).public_Most_times()", "entry_point": "test_run", "test_matching": "assert candidate([['class MT', 'def _private_Most_times', 'def public_Most_times'], ['class MT', 'def __private_Most_times', 'def public_Most_times']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/219", "question": "Firstly, design an **AA** class using the Python language, which has an instance attribute **n**, a private function **private_Alternating_appearance**, and a public function **public_Alternating_appearance**. Then, implement the following problem in the private function **private_Alternating_appearance**. Finally, call the private function **private_Alternating_appearance** in the public function **public_Alternating_appearance** to return the result.\nProblem: Given a positive integer, check whether its binary representation always alternates between 0 and 1. In other words, the adjacent digits in the binary representation are never the same. If 0 and 1 alternate, return True; otherwise, return False.", "test_list": ["assert candidate(5)==True", "assert candidate(7)==False", "assert candidate(11)==False"], "test_function": "def test_run(content1):\n    return AA(content1).public_Alternating_appearance()", "entry_point": "test_run", "test_matching": "assert candidate([['class AA', 'def _private_Alternating_appearance', 'def public_Alternating_appearance'], ['class AA', 'def __private_Alternating_appearance', 'def public_Alternating_appearance']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/220", "question": "Firstly, design an **IA** class using Python language, which has an instance attribute **grid**, a private function **private_Island_area**, and a public function **public_Island_area**. Then, implement the following problem in the private function **private_Island_area**. Finally, call the private function **private_Island_area** in the public function **public_Island_area** to return the result.\nProblem: Given a binary matrix **grid** of size m x n. An island is a combination of some adjacent 1s (representing land), where adjacency requires that two 1s must be adjacent in the horizontal or vertical four directions. It can be assumed that the four edges of the **grid** are surrounded by 0s (representing water). The area of the island is the number of cells on the island with a value of 1. Calculate and return the largest island area in the **grid**. If there is no island, return an area of 0.", "test_list": ["assert candidate([[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]])==6", "assert candidate([[0,0,0,0,0,0,0,0]])==0"], "test_function": "def test_run(content1):\n    return IA(content1).public_Island_area()", "entry_point": "test_run", "test_matching": "assert candidate([['class IA', 'def _private_Island_area', 'def public_Island_area'], ['class IA', 'def __private_Island_area', 'def public_Island_area']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/221", "question": "Firstly, design an **ES** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Equal_sum**, and a public function **public_Equal_sum**. Then, in the private function **private_Equal_sum**, determine whether it is possible to divide this array into **k** non-empty subsets with equal sums, based on a given integer array **nums** and a positive integer **k**. Finally, call the private function **private_Equal_sum** in the public function **public_Equal_sum** to return the result.", "test_list": ["assert candidate([4, 3, 2, 3, 5, 2, 1],4)==True", "assert candidate([1,2,3,4],3)==False"], "test_function": "def test_run(content1,content2):\n    return ES(content1,content2).public_Equal_sum()", "entry_point": "test_run", "test_matching": "assert candidate([['class ES', 'def _private_Equal_sum', 'def public_Equal_sum'], ['class ES', 'def __private_Equal_sum', 'def public_Equal_sum']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/222", "question": "Firstly, design a **BS** class using Python language, which has an instance attribute **positions**, a private function **private_Block_stacking**, and a public function **public_Block_stacking**. Then, implement the following problem in the private function **private_Block_stacking**. Finally, call the private function **private_Block_stacking** in the public function **public_Block_stacking** to return the result.\nProblem: Given a two-dimensional integer array **positions**, where positions[i] = [left_i, sideLength_i] indicates: the side length of the i-th block is **sideLength_i**, and its left side aligns with the coordinate point **left_i** on the x-axis. Each block falls from a height higher than all the currently landed blocks. The block falls in the negative direction of the y-axis until it lands on the top edge of another square or on the x-axis. A block merely brushing past the left or right side of another block does not count as landing. Once landed, it will be fixed in place and cannot move. After each block falls, you must record the highest height of the currently stable stacked blocks.", "test_list": ["assert candidate([[1,2],[2,3],[6,1]])==[2,5,5]", "assert candidate([[100,100],[200,100]])==[100,100]"], "test_function": "def test_run(content1):\n    return BS(content1).public_Block_stacking()", "entry_point": "test_run", "test_matching": "assert candidate([['class BS', 'def _private_Block_stacking', 'def public_Block_stacking'], ['class BS', 'def __private_Block_stacking', 'def public_Block_stacking']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/223", "question": "Firstly, design a **DC** class using the Python language, which has instance attributes **s1** and **s2**, a private function **private_Delete_Characters**, and a public function **public_Delete_Characters**. Then, in the private function **private_Delete_Characters**, return the minimum sum of the ASCII values of the characters that need to be deleted to make the two given strings **s1** and **s2** equal. Finally, call the private function **private_Delete_Characters** in the public function **public_Delete_Characters** to return the result.", "test_list": ["assert candidate(\"sea\",\"eat\")==231", "assert candidate(\"delete\",\"leet\")==403"], "test_function": "def test_run(content1,content2):\n    return DC(content1,content2).public_Delete_Characters()", "entry_point": "test_run", "test_matching": "assert candidate([['class DC', 'def _private_Delete_Characters', 'def public_Delete_Characters'], ['class DC', 'def __private_Delete_Characters', 'def public_Delete_Characters']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/224", "question": "Firstly, design a **POE** class using Python language, which has instance attributes **nums** and **k**, a private function **private_Product_of_elements**, and a public function **public_Product_of_elements**. Then, in the private function **private_Product_of_elements**, return the number of continuous subarrays where the product of all elements in the subarray is strictly less than **k**, given an integer array **nums** and an integer **k**. Finally, in the public function **public_Product_of_elements**, call the private function **private_Product_of_elements** to return the result.", "test_list": ["assert candidate([10,5,2,6],100)==8", "assert candidate([1,2,3],0)==0"], "test_function": "def test_run(content1,content2):\n    return POE(content1,content2).public_Product_of_elements()", "entry_point": "test_run", "test_matching": "assert candidate([['class POE', 'def _private_Product_of_elements', 'def public_Product_of_elements'], ['class POE', 'def __private_Product_of_elements', 'def public_Product_of_elements']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/225", "question": "Firstly, design a **BS** class using Python language, which has instance attributes **prices** and **fee**, a private function **private_buy_share**, and a public function **public_buy_share**. Then, implement the following problem in the private function **private_buy_share**. Finally, call the private function **private_buy_share** in the public function **public_buy_share** to return the result.\nProblem: Given an integer array **prices**, where prices[i] represents the stock price on the i-th day; the integer **fee** represents the transaction fee for trading stocks. You can complete transactions unlimited times, but you need to pay a fee for each transaction. If you have already purchased a stock, you cannot continue to buy stocks before selling it. Return the maximum profit that can be obtained.", "test_list": ["assert candidate([1, 3, 2, 8, 4, 9],2)==8", "assert candidate([1,3,7,5,10,3],3)==6"], "test_function": "def test_run(content1,content2):\n    return BS(content1,content2).public_buy_share()", "entry_point": "test_run", "test_matching": "assert candidate([['class BS', 'def _private_buy_share', 'def public_buy_share'], ['class BS', 'def __private_buy_share', 'def public_buy_share']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/226", "question": "Firstly, design a **BC** class using the Python language, which has an instance attribute **bits**, a private function **private_Bit_character**, and a public function **public_Bit_character**. Then, implement the following problem in the private function **private_Bit_character**. Finally, call the private function **private_Bit_character** in the public function **public_Bit_character** to return the result.\nProblem: There are two special characters: the first type of character can be represented by a one-bit 0; the second type of character can be represented by two bits (10 or 11). Given a binary array **bits** ending with 0, if the last character must be a one-bit character, return True; otherwise, return False.", "test_list": ["assert candidate([1, 0, 0])==True", "assert candidate([1,1,1,0])==False"], "test_function": "def test_run(content1):\n    return BC(content1).public_Bit_character()", "entry_point": "test_run", "test_matching": "assert candidate([['class BC', 'def _private_Bit_character', 'def public_Bit_character'], ['class BC', 'def __private_Bit_character', 'def public_Bit_character']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/227", "question": "Firstly, design a **BL** class using Python language, which has instance attributes **nums1** and **nums2**, a private function **private_BLongest_length**, and a public function **public_BLongest_length**. Then, in the private function **private_BLongest_length**, return the length of the longest common subarray from the two given integer arrays **nums1** and **nums2**. Finally, call the private function **private_BLongest_length** in the public function **public_BLongest_length** to return the result.", "test_list": ["assert candidate([1,2,3,2,1],[3,2,1,4,7])==3", "assert candidate([0,0,0,0,0],[0,0,0,0,0])==5"], "test_function": "def test_run(content1,content2):\n    return BL(content1,content2).public_BLongest_length()", "entry_point": "test_run", "test_matching": "assert candidate([['class BL', 'def _private_BLongest_length', 'def public_BLongest_length'], ['class BL', 'def __private_BLongest_length', 'def public_BLongest_length']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/228", "question": "Firstly, design an **AD** class using Python language, which has instance attributes **nums** and **k**, a private function **private_absolute_difference**, and a public function **public_absolute_difference**. Then, implement the following problem in the private function **private_absolute_difference**. Finally, call the private function **private_absolute_difference** in the public function **public_absolute_difference** to return the result.\nProblem: A pair of numbers (a, b) is composed of integers **a** and **b**, and the distance of the pair is defined as the absolute difference between **a** and **b**. Given an integer array **nums** and an integer **k**, the pair is composed of nums[i] and nums[j] and satisfies 0<= i<j<nums.length. Return the k-th smallest pair distance among all pair distances.", "test_list": ["assert candidate([1,3,1],1)==0", "assert candidate([1,1,1],2)==0", "assert candidate([1,6,1],3)==5"], "test_function": "def test_run(content1,content2):\n    return AD(content1,content2).public_absolute_difference()", "entry_point": "test_run", "test_matching": "assert candidate([['class AD', 'def _private_absolute_difference', 'def public_absolute_difference'], ['class AD', 'def __private_absolute_difference', 'def public_absolute_difference']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/229", "question": "Firstly, design an **ED** class using the Python language, which has an instance attribute **words**, a private function **private_English_Dictionary**, and a public function **public_English_Dictionary**. Then, implement the following problem in the private function **private_English_Dictionary**. Finally, call the private function **private_English_Dictionary** in the public function **public_English_Dictionary** to return the result.\nProblem: Given a string array **words** that forms an English dictionary, return the longest word in **words**. This word is formed by gradually adding one letter from other words in the **words** dictionary. If there are multiple feasible answers, return the word with the smallest lexicographical order among the answers. If there is no answer, return an empty string.", "test_list": ["assert candidate([\"w\",\"wo\",\"wor\",\"worl\", \"world\"])==\"world\"", "assert candidate([\"a\", \"banana\", \"app\", \"appl\", \"ap\", \"apply\", \"apple\"])==\"apple\""], "test_function": "def test_run(content1):\n    return ED(content1).public_English_Dictionary()", "entry_point": "test_run", "test_matching": "assert candidate([['class ED', 'def _private_English_Dictionary', 'def public_English_Dictionary'], ['class ED', 'def __private_English_Dictionary', 'def public_English_Dictionary']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/230", "question": "Firstly, design an **LS** class using Python language, which has instance attributes **head** and **k**, a private function **private_List_separation**, and a public function **public_List_separation**. Then, implement the following problem in the private function **private_List_separation**. Finally, call the private function **private_List_separation** in the public function **public_List_separation** to return the result.\nProblem: Given a singly linked list with a head node **head** and an integer **k**, please design an algorithm to divide the linked list into **k** consecutive parts. The length of each part should be as equal as possible: the difference in length between any two parts cannot exceed 1. This may cause some parts to be null. These **k** parts should be arranged in the order they appear in the linked list, and the length of the parts in the front should be greater than or equal to the length of the parts in the back. Return an array composed of the above **k** parts.", "test_list": ["assert candidate([1,2,3],5)==[[1],[2],[3],[],[]]", "assert candidate([1,2,3,4,5,6,7,8,9,10],3)==[[1,2,3,4],[5,6,7],[8,9,10]]"], "test_function": "def test_run(content1,content2):\n    return LS(content1,content2).public_public_List_separation()", "entry_point": "test_run", "test_matching": "assert candidate([['class LS', 'def _private_List_separation', 'def public_List_separation'], ['class LS', 'def __private_List_separation', 'def public_List_separation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/231", "question": "Firstly, design a **NOS** class using the Python language, which has an instance attribute **s**, a private function **private_Number_of_sequences**, and a public function **public_Number_of_sequences**. Then, in the private function **private_Number_of_sequences**, return the number of different non-empty palindrome sub-sequences in a given string **s**. Finally, in the public function **public_Number_of_sequences**, call the private function **private_Number_of_sequences** to return the result.", "test_list": ["assert candidate('bccb')==6", "assert candidate('abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba')==104860361"], "test_function": "def test_run(content1):\n    return NOS(content1).public_Number_of_sequences()", "entry_point": "test_run", "test_matching": "assert candidate([['class NOS', 'def _private_Number_of_sequences', 'def public_Number_of_sequences'], ['class NOS', 'def __private_Number_of_sequences', 'def public_Number_of_sequences']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/232", "question": "Firstly, design an **MI** class using Python language, which has an instance attribute **n**, a private function **private_monotonic_increase**, and a public function **public_monotonic_increase**. Then, implement the following problem in the private function **private_monotonic_increase**. Finally, call the private function **private_monotonic_increase** in the public function **public_monotonic_increase** to return the result. \nProblem: An integer is said to be monotonically increasing if and only if each pair of adjacent digits **x** and **y** satisfy x <= y. Given an integer **n**, return the largest number less than or equal to **n** that is monotonically increasing.", "test_list": ["assert candidate(10)==9", "assert candidate(1234)==1234", "assert candidate(332)==299"], "test_function": "def test_run(content1):\n    return MI(content1).public_monotonic_increase()", "entry_point": "test_run", "test_matching": "assert candidate([['class MI', 'def _private_monotonic_increase', 'def public_monotonic_increase'], ['class MI', 'def __private_monotonic_increase', 'def public_monotonic_increase']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/233", "question": "Firstly, design a class **TR** using the Python language, which has an instance attribute **temperatures**, a private function **private_Temperature_rise**, and a public function **public_Temperature_rise**. Then, implement the following problem in the private function **private_Temperature_rise**. Finally, call the private function **private_Temperature_rise** in the public function **public_Temperature_rise** to return the result.\nProblem: Given an integer array **temperatures** representing the temperature of each day, return an array **answer**, where answer[i] refers to the number of days until the next higher temperature for the i-th day. If the temperature will not rise after this, please replace it with 0 at this position.", "test_list": ["assert candidate([73,74,75,71,69,72,76,73])==[1,1,4,2,1,1,0,0]", "assert candidate([30,40,50,60])==[1,1,1,0]", "assert candidate([30,60,90])==[1,1,0]"], "test_function": "def test_run(content1):\n    return TR(content1).public_Temperature_rise()", "entry_point": "test_run", "test_matching": "assert candidate([['class TR', 'def _private_Temperature_rise', 'def public_Temperature_rise'], ['class TR', 'def __private_Temperature_rise', 'def public_Temperature_rise']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/234", "question": "Firstly, design a class **MN** using the Python language, which has an instance attribute **nums**, a private function **private_Maximum_number**, and a public function **public_Maximum_number**. Then, implement the following problem in the private function **private_Maximum_number**. Finally, call the private function **private_Maximum_number** in the public function **public_Maximum_number** to return the result.\nProblem: Given an integer array **nums**, you can perform some operations on it. In each operation, choose any nums[i], delete it and get the points of nums[i]. After that, you must delete all elements equal to nums[i]-1 and nums[i]+1. Initially, you have 0 points. Return the maximum points that can be obtained through these operations.", "test_list": ["assert candidate([3,4,2])==6", "assert candidate([2,2,3,3,3,4])==9"], "test_function": "def test_run(content1):\n    return MN(content1).public_Maximum_number()", "entry_point": "test_run", "test_matching": "assert candidate([['class MN', 'def _private_Maximum_number', 'def public_Maximum_number'], ['class MN', 'def __private_Maximum_number', 'def public_Maximum_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/235", "question": "Firstly, design a class **NN** using the Python language, which has instance attributes **times**, **n** and **k**, a private function **private_network_node**, and a public function **public_network_node**. Then, implement the following problem in the private function **private_network_node**. Finally, call the private function **private_network_node** in the public function **public_network_node** to return the result.\nProblem: There are **n** network nodes, labeled from 1 to n. Given a list **times**, which represents the transmission time of signals passing through directed edges. times[i] = (u_i, v_i, w_i), where **u_i** is the source node, **v_i** is the target node, and **w_i** is the time it takes for a signal to pass from the source node to the target node. Now, a signal is sent from a certain node **K**, how long will it take for all nodes to receive the signal? If not all nodes can receive the signal, return -1.", "test_list": ["assert candidate([[2,1,1],[2,3,1],[3,4,1]],4,2)==2", "assert candidate([[1,2,1]],2,1)==1", "assert candidate([[1,2,1]],2,2)==-1"], "test_function": "def test_run(content1,content2,content3):\n    return NN(content1,content2,content3).public_network_node()", "entry_point": "test_run", "test_matching": "assert candidate([['class NN', 'def _private_network_node', 'def public_network_node'], ['class NN', 'def __private_network_node', 'def public_network_node']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/236", "question": "Firstly, design an **INA** class using Python language, which has an instance attribute **target**, a private function **private_Infinite_number_axis**, and a public function **public_Infinite_number_axis**. Then, implement the following problem in the private function **private_Infinite_number_axis**. Finally, call the private function **private_Infinite_number_axis** in the public function **public_Infinite_number_axis** to return the result.\nProblem: On an infinitely long number axis, you stand at position 0, and the endpoint is at the **target** position. You can make a certain number of moves **numMoves**: each time you can choose to move left or right, and for the i-th move (from i==1 to i==numMoves), you walk **i** steps in the chosen direction. Given an integer **target**, return the minimum number of moves required to reach the target (i.e., the minimum **numMoves**).", "test_list": ["assert candidate(2)==3", "assert candidate(3)==2"], "test_function": "def test_run(content1):\n    return INA(content1).public_Infinite_number_axis()", "entry_point": "test_run", "test_matching": "assert candidate([['class INA', 'def _private_Infinite_number_axis', 'def public_Infinite_number_axis'], ['class INA', 'def __private_Infinite_number_axis', 'def public_Infinite_number_axis']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/237", "question": "Firstly, design an **IC** class using Python language, which has an instance attribute **intervals**, a private function **private_Include_Collection**, and a public function **public_Include_Collection**. Then, implement the following problem in the private function **private_Include_Collection**. Finally, call the private function **private_Include_Collection** in the public function **public_Include_Collection** to return the result.\nProblem: Given a two-dimensional integer array **intervals**, where intervals[i] = [start_i, end_i] represents all integers from **start_i** to **end_i**, including **start_i** and **end_i**. The inclusion set is an array named **nums**, and it satisfies that each interval in **intervals** has at least two integers in **nums**. Return the possible minimum size of the inclusion set.", "test_list": ["assert candidate([[1,3],[3,7],[8,9]])==5", "assert candidate([[1,3],[1,4],[2,5],[3,5]])==3", "assert candidate([[1,2],[2,3],[2,4],[4,5]])==5"], "test_function": "def test_run(content1):\n    return IC(content1).public_Include_Collection()", "entry_point": "test_run", "test_matching": "assert candidate([['class IC', 'def _private_Include_Collection', 'def public_Include_Collection'], ['class IC', 'def __private_Include_Collection', 'def public_Include_Collection']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/238", "question": "Firstly, design a class **SP** using Python language, which has an instance attribute **s**, a private function **private_String_partitioning**, and a public function **public_String_partitioning**. Then, implement the following problem in the private function **private_String_partitioning**. Finally, call the private function **private_String_partitioning** in the public function **public_String_partitioning** to return the result.\nProblem: Given a string **s**, partition this string into as many segments as possible, with the same letter appearing at most once in a segment, and return a list representing the length of each string segment.\nThe partition result needs to satisfy: concatenating all partition results in order, the string obtained is still **s**.", "test_list": ["assert candidate(\"ababcbacadefegdehijhklij\")==[9,7,8]", "assert candidate(\"eccbbbbdec\")==[10]"], "test_function": "def test_run(content1):\n    return SP(content1).public_String_partitioning()", "entry_point": "test_run", "test_matching": "assert candidate([['class SP', 'def _private_String_partitioning', 'def public_String_partitioning'], ['class SP', 'def __private_String_partitioning', 'def public_String_partitioning']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/239", "question": "Firstly, design a **PS** class using Python language, which has instance attributes **n** and **mines**, a private function **private_Plus_sign**, and a public function **public_Plus_sign**. Then, implement the following problem in the private function **private_Plus_sign**. Finally, call the private function **private_Plus_sign** in the public function **public_Plus_sign** to return the result.\nProblem: In an n x n matrix **grid**, every element is 1 except for the elements given as 0 in the array **mines**. mines[i]=[x_i,y_i] indicates grid[x_i][y_i]==0. Return the order of the largest axis-aligned plus sign of 1s in **grid**. If no plus sign is found, return 0.", "test_list": ["assert candidate(5,[[4, 2]])==2", "assert candidate(1,[[0, 0]])==0"], "test_function": "def test_run(content1,content2):\n    return PS(content1,content2).public_Plus_sign()", "entry_point": "test_run", "test_matching": "assert candidate([['class PS', 'def _private_Plus_sign', 'def public_Plus_sign'], ['class PS', 'def __private_Plus_sign', 'def public_Plus_sign']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/240", "question": "Firstly, design an **ES** class using Python language, which has an instance attribute **row**, a private function **private_Exchange_seats**, and a public function **public_Exchange_seats**. Then, implement the following problem in the private function **private_Exchange_seats**. Finally, call the private function **private_Exchange_seats** in the public function **public_Exchange_seats** to return the result.\nProblem: There are **n** pairs of couples sitting on **2n** seats arranged in a row, and they want to hold each other's hands. People and seats are represented by an integer array **row**, where row[i] is the ID of the person sitting in the i-th seat. The couples are numbered in order, the first pair is (0, 1), the second pair is (2, 3), and so on, the last pair is (2n-2, 2n-1). Return the minimum number of seat swaps so that each couple can sit together side by side. You can choose any two people for each swap, and have them stand up and exchange seats.", "test_list": ["assert candidate([0,2,1,3])==1", "assert candidate([3,2,0,1])==0"], "test_function": "def test_run(content1):\n    return ES(content1).public_Exchange_seats()", "entry_point": "test_run", "test_matching": "assert candidate([['class ES', 'def _private_Exchange_seats', 'def public_Exchange_seats'], ['class ES', 'def __private_Exchange_seats', 'def public_Exchange_seats']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/241", "question": "Firstly, design a **JM** class using Python language, which has an instance attribute **matrix**, a private function **private_judgment_matrix**, and a public function **public_judgment_matrix**. Then, in the private function **private_judgment_matrix**, determine whether a given m x n **matrix** is a Toeplitz matrix. If it is, return True; otherwise, return False. Finally, call the private function **private_judgment_matrix** in the public function **public_judgment_matrix** to return the result.", "test_list": ["assert candidate([[1,2,3,4],[5,1,2,3],[9,5,1,2]])==True", "assert candidate([[1,2],[2,2]])==False"], "test_function": "def test_run(content1):\n    return JM(content1).public_judgment_matrix()", "entry_point": "test_run", "test_matching": "assert candidate([['class JM', 'def _private_judgment_matrix', 'def public_judgment_matrix'], ['class JM', 'def _private_judgment_matrix', 'def public_judgment_matrix']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/242", "question": "First, design an **RL** class using the Python language, which has an instance attribute **s**, a private function **private_Rearrange_letters**, and a public function **public_Rearrange_letters**. Then, implement the following problem in the private function **private_Rearrange_letters**. Finally, call the private function **private_Rearrange_letters** in the public function **public_Rearrange_letters** to return the result.\nProblem: Given a string **s**, check if it is possible to rearrange its letters so that no two adjacent characters are the same. Return any possible rearrangement of **s**. If it is not feasible, return an empty string \"\".", "test_list": ["assert candidate(\"aab\")==\"aba\"", "assert candidate(\"aaab\")==\"\""], "test_function": "def test_run(content1):\n    return RL(content1).public_Rearrange_letters()", "entry_point": "test_run", "test_matching": "assert candidate([['class RL', 'def _private_Rearrange_letters', 'def public_Rearrange_letters'], ['class RL', 'def _private_Rearrange_letters', 'def public_Rearrange_letters']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/243", "question": "Firstly, design an **MNB** class using the Python language, which has an instance attribute **arr**, a private function **private_Maximum_number_blocks**, and a public function **public_Maximum_number_blocks**. Then, implement the following problem in the private function **private_Maximum_number_blocks**. Finally, call the private function **private_Maximum_number_blocks** in the public function **public_Maximum_number_blocks** to return the result.\nProblem: Given an integer array **arr**, split **arr** into several chunks, and sort these chunks separately. Then connect them together so that the result of the connection is the same as the original array sorted in ascending order. Return the maximum number of chunks that the array can be divided into.", "test_list": ["assert candidate([5,4,3,2,1])==1", "assert candidate([2,1,3,4,4])==4"], "test_function": "def test_run(content1):\n    return MNB(content1).public_Maximum_number_blocks()", "entry_point": "test_run", "test_matching": "assert candidate([['class MNB', 'def _private_Maximum_number_blocks', 'def public_Maximum_number_blocks'], ['class MNB', 'def __private_Maximum_number_blocks', 'def public_Maximum_number_blocks']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/244", "question": "Firstly, design a class named **SS** using Python language, which includes an instance attribute **arr**, a private function **private_Sort_separately**, and a public function **public_Sort_separately**. Then, implement the following problem in the private function **private_Sort_separately**. Finally, call the private function **private_Sort_separately** in the public function **public_Sort_separately** and return the result.\nProblem: Given an integer array **arr** of length **n**, which represents the permutation of integers in the range [0, n - 1], divide **arr** into several blocks (i.e., partitions) and sort each block separately. After connecting them, make the result of the connection the same as the original array sorted in ascending order, and return the maximum number of blocks that the array can be divided into.", "test_list": ["assert candidate([4,3,2,1,0])==1", "assert candidate([1,0,2,3,4])==4"], "test_function": "def test_run(content1):\n    return SS(content1).public_Sort_separately()", "entry_point": "test_run", "test_matching": "assert candidate([['class SS', 'def _private_Sort_separately', 'def public_Sort_separately'], ['class SS', 'def __private_Sort_separately', 'def public_Sort_separately']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/245", "question": "Firstly, design a class **SPB** using Python language, which has an instance attribute **board**, a private function **private_Solving_puzzle_board**, and a public function **public_Solving_puzzle_board**. Then, implement the following problem in the private function **private_Solving_puzzle_board**. Finally, call the private function **private_Solving_puzzle_board** in the public function **public_Solving_puzzle_board** to return the result.\nProblem: On a 2 x 3 **board**, there are 5 tiles represented by numbers 1~5, and an empty space represented by 0. A move is defined as swapping 0 with an adjacent number (up, down, left, or right). The puzzle is solved when the **board** result is [[1,2,3],[4,5,0]]. Given an initial state of the puzzle **board**, return the minimum number of moves to solve the puzzle. If the puzzle cannot be solved, return -1.", "test_list": ["assert candidate([[1,2,3],[4,0,5]])==1", "assert candidate([[1,2,3],[5,4,0]])==-1", "assert candidate([[4,1,2],[5,0,3]])==5"], "test_function": "def test_run(content1):\n    return SPB(content1).public_Solving_puzzle_board()", "entry_point": "test_run", "test_matching": "assert candidate([['class SPB', 'def _private_Solving_puzzle_board', 'def public_Solving_puzzle_board'], ['class SPB', 'def __private_Solving_puzzle_board', 'def public_Solving_puzzle_board']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/246", "question": "Firstly, design a class **LI** using Python language, which has an instance attribute **nums**, a private function **private_Local_inversion**, and a public function **public_Local_inversion**. Then, implement the following problem in the private function **private_Local_inversion**. Finally, call the private function **private_Local_inversion** in the public function **public_Local_inversion** and return the result.\nProblem: Given an integer array **nums** of length **n**, representing a permutation composed of all integers within the range [0, n - 1]. The number of global inversions is equal to the number of different index pairs (i, j) that satisfy the following conditions: 1. 0 <= i < j < n; 2. nums[i] > nums[j]; The number of local inversions is equal to the number of indexes **i** that satisfy the following conditions: 1. 0 <= i < n - 1; 2. nums[i] > nums[i + 1]; When the number of global inversions in the array **nums** equals the number of local inversions, return True; otherwise, return False.", "test_list": ["assert candidate([1,0,2])==True", "assert candidate([1,2,0])==False"], "test_function": "def test_run(content1):\n    return LI(content1).public_Local_inversion()", "entry_point": "test_run", "test_matching": "assert candidate([['class LI', 'def _private_Local_inversion', 'def public_Local_inversion'], ['class LI', 'def __private_Local_inversion', 'def public_Local_inversion']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/247", "question": "Firstly, design a class **GS** using the Python language, which has an instance attribute **grid**, a private function **private_Grid_swimming**, and a public function **public_Grid_swimming**. Then, implement the following problem in the private function **private_Grid_swimming**. Finally, call the private function **private_Grid_swimming** in the public function **public_Grid_swimming** to return the result.\nProblem: In an n x n integer matrix **grid**, each cell's value grid[i][j] represents the platform height at position (i, j). When it starts to rain, the water level in the pool is **t** at time **t**. You can swim to any adjacent platform, but the prerequisite is that the water level must submerge these two platforms at the same time. Assuming you can move an infinite distance instantly, that is, it is assumed that swimming within the grid does not consume time. Of course, you must stay within the coordinate grid while swimming. You start from the top-left platform (0,0) of the coordinate grid, and return the minimum time required to reach the bottom-right platform (n-1, n-1) of the coordinate grid.", "test_list": ["assert candidate([[0,2],[1,3]])==3", "assert candidate([[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]])==16"], "test_function": "def test_run(content1):\n    return GS(content1).public_Grid_swimming()", "entry_point": "test_run", "test_matching": "assert candidate([['class GS', 'def _private_Grid_swimming', 'def public_Grid_swimming'], ['class GS', 'def __private_Grid_swimming', 'def public_Grid_swimming']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/248", "question": "Firstly, design a **GNR** class using Python language, which has instance attributes **n** and **k**, a private function **private_Given_number_rows**, and a public function **public_Given_number_rows**. Then, implement the following problem in the private function **private_Given_number_rows**. Finally, call the private function **private_Given_number_rows** in the public function **public_Given_number_rows** to return the result.\nProblem: We have constructed a table with **n** rows (indexed from 1). Initially, we write a 0 on the first row. For each subsequent row, we replace 0 with 01 and 1 with 10 in the previous row. Given the row number **n** and the ordinal **k**, return the k-th character (k indexed from 1) in the n-th row.", "test_list": ["assert candidate(1,1)==0", "assert candidate(2,1)==0", "assert candidate(2,2)==1"], "test_function": "def test_run(content1,content2):\n    return GNR(content1,content2).public_Given_number_rows()", "entry_point": "test_run", "test_matching": "assert candidate([['class GNR', 'def _private_Given_number_rows', 'def public_Given_number_rows'], ['class GNR', 'def __private_Given_number_rows', 'def public_Given_number_rows']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/249", "question": "Firstly, design a **CN** class using Python language, which has instance attributes **sx**, **sy**, **tx**, and **ty**, a private function **private_Convert_numbers**, and a public function **public_Convert_numbers**. Then, implement the following problem in the private function **private_Convert_numbers**. Finally, call the private function **private_Convert_numbers** in the public function **public_Convert_numbers** to return the result.\nProblem: Given four integers **sx**, **sy**, **tx**, and **ty**. If it is possible to reach the endpoint (tx, ty) from the starting point (sx, sy) through a series of transformations, return True, otherwise return False. From point (x, y), it can be transformed to either (x, x+y) or (x+y, y).", "test_list": ["assert candidate(1,1,3,5)==True", "assert candidate(1,1,2,2)==False", "assert candidate(1,1,1,1)==True"], "test_function": "def test_run(content1,content2,content3,content4):\n    return CN(content1,content2,content3,content4).public_Convert_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class CN', 'def _private_Convert_numbers', 'def public_Convert_numbers'], ['class CN', 'def __private_Convert_numbers', 'def public_Convert_numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/250", "question": "First, design a class **FR** using the Python language, which has an instance attribute **answers**, a private function **private_Forest_Rabbit**, and a public function **public_Forest_Rabbit**. Then, implement the following problem in the private function **private_Forest_Rabbit**. Finally, call the private function **private_Forest_Rabbit** in the public function **public_Forest_Rabbit** to return the result.\nProblem: There is an unknown number of rabbits in the forest. Ask some of the rabbits **how many other rabbits have the same color as you (referring to the rabbit being asked)**, and collect the answers into an integer array **answers**, where answers[i] is the answer of the i-th rabbit.\nGiven the array **answers**, return the minimum number of rabbits in the forest.", "test_list": ["assert candidate([1,1,2])==5", "assert candidate([10,10,10])==11"], "test_function": "def test_run(content1):\n    return FR(content1).public_Forest_Rabbit()", "entry_point": "test_run", "test_matching": "assert candidate([['class FR', 'def _private_Forest_Rabbit', 'def public_Forest_Rabbit'], ['class FR', 'def __private_Forest_Rabbit', 'def public_Forest_Rabbit']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/251", "question": "Firstly, design a class **NM** using the Python language, which has an instance attribute **board**, a private function **private_Network_Matrix**, and a public function **public_Network_Matrix**. Then, implement the following problem in the private function **private_Network_Matrix**. Finally, call the private function **private_Network_Matrix** in the public function **public_Network_Matrix** to return the result.\nProblem: A n x n two-dimensional network **board** is composed only of 0 and 1. In each move, you can freely swap the positions of two columns or two rows. Return the minimum number of moves required to transform this matrix into a **chessboard**. If there is no feasible transformation, output -1.", "test_list": ["assert candidate([[0,1,1,0],[0,1,1,0],[1,0,0,1],[1,0,0,1]])==2", "assert candidate([[0,1],[1,0]])==0", "assert candidate([[1,0],[1,0]])==-1"], "test_function": "def test_run(content1):\n    return NM(content1).public_Network_Matrix()", "entry_point": "test_run", "test_matching": "assert candidate([['class NM', 'def _private_Network_Matrix', 'def public_Network_Matrix'], ['class NM', 'def __private_Network_Matrix', 'def public_Network_Matrix']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/252", "question": "Firstly, design a class **CC** using Python language, which has an instance attribute **s**, a private function **private_Change_Case**, and a public function **public_Change_Case**. Then, implement the following problem in the private function **private_Change_Case**. Finally, call the private function **private_Change_Case** in the public function **public_Change_Case** to return the result.\nProblem: Given a string **s**, by changing the case of each letter in the string **s**, we can obtain a new string. Return the set of all possible strings that can be obtained.", "test_list": ["assert candidate(\"a1b2\")==[\"a1b2\", \"a1B2\", \"A1b2\", \"A1B2\"]", "assert candidate(\"3z4\")==[\"3z4\",\"3Z4\"]"], "test_function": "def test_run(content1):\n    return CC(content1).public_Change_Case()", "entry_point": "test_run", "test_matching": "assert candidate([['class CC', 'def _private_Change_Case', 'def public_Change_Case'], ['class CC', 'def __private_Change_Case', 'def public_Change_Case']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/253", "question": "Firstly, design a class **MS** using the Python language, which has instance attributes **arr** and **k**, a private function **private_Minimum_score**, and a public function **public_Minimum_score**. Then, implement the following problem in the private function **private_Minimum_score**. Finally, call the private function **private_Minimum_score** in the public function **public_Minimum_score** to return the result.\nProblem: Given an array **arr** sorted in ascending order and an integer **k**. The array **arr** is composed of 1 and several prime numbers, and all integers in it are different from each other. For each pair of **i** and **j** satisfying 0 <= i < j < arr.length, a score can be obtained as arr[i]/arr[j]. So, what is the k-th smallest score?", "test_list": ["assert candidate([1,2,3,5],3)==[2,5]", "assert candidate([1,7],1)==[1,7]"], "test_function": "def test_run(content1,content2):\n    return MS(content1,content2).public_Minimum_score()", "entry_point": "test_run", "test_matching": "assert candidate([['class MS', 'def _private_Minimum_score', 'def public_Minimum_score'], ['class MS', 'def __private_Minimum_score', 'def public_Minimum_score']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/254", "question": "Firstly, design a **PM** class using Python language, which has instance attributes **order** and **s**, a private function **private_Permutation_matching**, and a public function **public_Permutation_matching**. Then, implement the following problem in the private function **private_Permutation_matching**. Finally, call the private function **private_Permutation_matching** in the public function **public_Permutation_matching** to return the result.\nProblem: Given two strings, **order** and **s**, all the letters in **order** are unique and have been sorted in some custom order. Permute the characters of **s** to match the sorted **order**. More specifically, if character **x** appears before character **y** in **order**, then in the permuted string, **x** should also appear before **y**. Return any permutation of **s** that satisfies this property.", "test_list": ["assert candidate(\"cba\",\"abcd\")==\"cbad\"", "assert candidate(\"cbafg\",\"abcd\")==\"cbad\""], "test_function": "def test_run(content1,content2):\n    return PM(content1,content2).public_Permutation_matching()", "entry_point": "test_run", "test_matching": "assert candidate([['class PM', 'def _private_Permutation_matching', 'def public_Permutation_matching'], ['class PM', 'def _private_Permutation_matching', 'def public_Permutation_matching']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/255", "question": "Firstly, design a class **NW** using the Python language, which has instance attributes **s** and **words**, a private function **private_Number_words**, and a public function **public_Number_words**. Then, in the private function **private_Number_words**, return the number of words in words[i] that are subsequences of the given string **s** based on the given string **s** and the number of strings **words**. Finally, in the public function **public_Number_words**, call the private function **private_Number_words** to return the result.", "test_list": ["assert candidate(\"abcde\",[\"a\",\"bb\",\"acd\",\"ace\"])==3", "assert candidate(\"dsahjpjauf\",[\"ahjpjau\",\"ja\",\"ahbwzgqnuk\",\"tnmlanowax\"])==2"], "test_function": "def test_run(content1,content2):\n    return NW(content1,content2).public_Number_words()", "entry_point": "test_run", "test_matching": "assert candidate([['class NW', 'def _private_Number_words', 'def public_Number_words'], ['class NW', 'def __private_Number_words', 'def public_Number_words']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/256", "question": "Firstly, design a class **NI** using Python language, which has an instance attribute **k**, a private function **private_nonnegative_integer**, and a public function **public_nonnegative_integer**. Then, implement the following problem in the private function **private_nonnegative_integer**. Finally, call the private function **private_nonnegative_integer** in the public function **public_nonnegative_integer** to return the result.\nProblem: f(x) is the number of zeros at the end of x!, recall that x! = 1*2*3*...*x, and 0! = 1. Given **k**, find the number of non-negative integers **x** that can satisfy f(x) = k.", "test_list": ["assert candidate(0)==5", "assert candidate(5)==0", "assert candidate(3)==5"], "test_function": "def test_run(content1):\n    return NI(content1).public_nonnegative_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class NI', 'def _private_nonnegative_integer', 'def public_nonnegative_integer'], ['class NI', 'def __private_nonnegative_integer', 'def public_nonnegative_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/2", "question": "Question: Given an integer array **nums** and two integers **left** and **right**. Find the number of subarrays in **nums** that are continuous, non-empty, and have the maximum element within the range [left, right].\n Please create a class called FDSB in Python based on the above problem, with the **nums** attribute. Then create a class called **SN_FDSB** that inherits from the **FDSB** class, and add two attributes **left** and **right**, as well as a public function called **find_subarray** that checks and returns the number of subarrays in **nums** that are continuous, non-empty, and have the maximum element within the range [left, right].", "test_list": ["assert candidate([2,1,4,3],2,3)==3", "assert candidate([2,9,2,5,6],2,8)==7"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FDSB(content1,content2,content3).find_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class FDSB', 'def find_subarray', 'super().__init__(nums)', 'def find_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/257", "question": "Question: Given an integer array **nums** and two integers: **left** and **right**. Find the continuous, non-empty subarrays in **nums** where the maximum element is within the range [left, right] and return the number of such subarrays that meet the conditions.\nBased on the above question, create a class **FDSB** in Python language with the attribute **nums**; then create another class **SN_FDSB** that inherits from the **FDSB** class, and add two attributes **left** and **right**, as well as a public function **find_subarray** to determine and return the number of continuous, non-empty subarrays in **nums** where the maximum element is within the range [left, right].", "test_list": ["assert candidate([2,1,4,3],2,3)==3", "assert candidate([2,9,2,5,6],2,8)==7"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FDSB(content1,content2,content3).find_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class FDSB', 'class SN_FDSB(FDSB)', 'super().__init__(nums)', 'def find_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/258", "question": "Question: Given a directed acyclic graph (DAG) with **n** nodes, find and output all paths from node 0 to node n-1;\nBased on the above question, create a class **PO** in Python with the attribute **graph**; then create another class **SN_PO**, inheriting from the **PO** class, and add a public function **Path_output** to return all paths from node 0 to node n-1 in the **n** nodes.", "test_list": ["assert candidate([[1,2],[3],[3],[]])==[[0,1,3],[0,2,3]]", "assert candidate([[4,3,1],[3,2,4],[3],[4],[]])==[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]"], "test_function": "def test_run(content1):\n    return SN_PO(content1).Path_output()", "entry_point": "test_run", "test_matching": "assert candidate([['class PO', 'class SN_PO(PO)', 'super().__init__(graph)', 'def Path_output']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/259", "question": "Question: Given two integer arrays **nums1** and **nums2** of equal length and not empty. In one operation, you can swap the elements of nums1[i] and nums2[i]. For example, if nums1=[1,2,3,8], nums2=[5,6,7,4], you can swap the element at i=3 to get nums1=[1,2,3,4] and nums2=[5,6,7,8]. Return the minimum number of operations required to make **nums1** and **nums2** strictly increasing;\nBased on the above question, create a class **EE** in Python language with the attribute **nums1**; then create a class **SN_EE** that inherits the **EE** class, and add the attribute **nums2**, as well as a public function **Exchange_Elements** to return the minimum number of operations required to make **nums1** and **nums2** strictly increasing.", "test_list": ["assert candidate([1,3,5,4],[1,2,3,7])==1", "assert candidate([0,3,5,8,9],[2,1,4,6,9])==1"], "test_function": "def test_run(content1,content2):\n    return SN_EE(content1,content2).Exchange_Elements()", "entry_point": "test_run", "test_matching": "assert candidate([['class EE', 'class SN_EE(EE)', 'super().__init__(nums1)', 'def Exchange_Elements']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/260", "question": "Question: Given a directed graph with **n** nodes numbered from 0 to n-1, the graph is represented by a 2D integer array **graph** indexed from 0, where graph[i] is an integer array of nodes adjacent to node **i**, meaning there is an edge from node **i** to each node in **graph[i]**. If a node has no outgoing directed edges, it is a **terminal node**. If all possible paths starting from this node lead to a terminal node, then this node is a **safe node**. Return an array consisting of all the safe nodes in the graph as the answer. The elements in the answer array should be sorted in ascending order;\nBased on the above question, please create a class **SND** in Python with the property **graph**; then create a class **SN_SND** that inherits from the **SND** class, and add a public function **secure_node** to return an array of all the safe nodes in the graph sorted in ascending order.", "test_list": ["assert candidate([[1,2],[2,3],[5],[0],[5],[],[]])==[2,4,5,6]", "assert candidate([[1,2,3,4],[1,2],[3,4],[0,4],[]])==[4]"], "test_function": "def test_run(content1):\n    return SN_SND(content1).secure_node()", "entry_point": "test_run", "test_matching": "assert candidate([['class SND', 'class SN_SND(SND)', 'super().__init__(graph)', 'def secure_node']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/261", "question": "Question: There is an m x n binary **grid**, where 1 represents a brick and 0 represents a blank. The premise for a brick to be stable (not falling) is: a brick is directly connected to the top of the grid, or at least one adjacent (one of the four directions) brick is stable and will not fall. Given an array **hits**, this is the position where the bricks need to be eliminated in order. Whenever the brick at the position hits[i]=(row_i, col_i) is eliminated, the corresponding brick (if it exists) will disappear, and then other bricks may fall due to this elimination operation. Once the brick falls, it will immediately disappear from the grid (it will not fall on other stable bricks). Return an array **result**, where result[i] represents the number of bricks falling corresponding to the i-th elimination operation;\nBased on the above question, please create a class **NBS** in Python language with the property **grid**; then create a class **SN_NBS** that inherits the **NBS** class, and add the property **hits**, and a public function **Number_bricks** to return the array **result** representing the number of bricks falling corresponding to the elimination operation.", "test_list": ["assert candidate([[1,0,0,0],[1,1,1,0]],[[1,0]])==[2]", "assert candidate([[1,0,0,0],[1,1,0,0]],[[1,1],[1,0]])==[0,0]"], "test_function": "def test_run(content1,content2):\n    return SN_NBS(content1,content2).Number_bricks()", "entry_point": "test_run", "test_matching": "assert candidate([['class NBS', 'class SN_NBS(NBS)', 'super().__init__(grid)', 'def Number_bricks']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/262", "question": "Question: Given an integer array **nums**. Move each element in the **nums** array to array **A** or array **B**, ensuring that arrays **A** and **B** are not empty, and average(A) == average(B). If it can be completed, return True, otherwise return False;\nBased on the above question, please create a class **EMT** in Python, with the attribute **nums**; then create another class **SN_EMT** that inherits from the **EMT** class, and add a public function **Element_Movement** to determine whether it can be completed.", "test_list": ["assert candidate([1,2,3,4,5,6,7,8])==True", "assert candidate([3,1])==False"], "test_function": "def test_run(content1):\n    return SN_EMT(content1).Element_Movement()", "entry_point": "test_run", "test_matching": "assert candidate([['class EMT', 'class SN_EMT(EMT)', 'super().__init__(nums)', 'def Element_Movement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/263", "question": "Question: Given an array **nums** and an integer **k**. We divide the given array **nums** into at most **k** non-empty subarrays, and the array is continuous. The score is composed of the sum of the averages within each subarray. Return the maximum score that can be obtained;\nBased on the above question, use Python language to create a class **MSE** with the attribute **nums**; then create a class **SN_MSE**, inheriting from the **MSE** class, and add the attribute **k**, as well as a public function **Maximum_score** to return the maximum score that can be obtained.", "test_list": ["assert candidate([9,1,2,3,9],3)==20.00000", "assert candidate([1,2,3,4,5,6,7],4)==20.50000"], "test_function": "def test_run(content1,content2):\n    return SN_MSE(content1,content2).Maximum_score()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSE', 'class SN_MSE(MSE)', 'super().__init__(nums)', 'def Maximum_score']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/264", "question": "Question: Given an array **routes**, representing a series of bus routes, where each routes[i] represents a bus route, the i-th bus will circulate on it. For example, the route routes[0]=[1,5,7] indicates that the 0-th bus will always travel in the sequence of 1->5->7->1->5->7->1->... Now starting from the **source** station (not initially on the bus), you want to go to the **target** station. During this period, you can only take the bus. Find the minimum number of buses to take. If it is impossible to reach the terminal station, return -1;\nBased on the above question, please use Python to create a class **TSN** with the attribute **routes**; then create a class **SN_TSN** that inherits from the **TSN** class, and add two attributes **source** and **target**, as well as a public function **Terminal_Station** to return the minimum number of buses to take.", "test_list": ["assert candidate([[1,2,7],[3,6,7]],1,6)==2", "assert candidate([[7,12],[4,5,15],[6],[15,19],[9,12,13]],15,12)==-1"], "test_function": "def test_run(content1,content2,content3):\n    return SN_TSN(content1,content2,content3).Terminal_Station()", "entry_point": "test_run", "test_matching": "assert candidate([['class TSN', 'class SN_TSN(TSN)', 'super().__init__(routes)', 'def Terminal_Station']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/265", "question": "Question: There are some two-dimensional coordinates, such as (1,3) or (2,0.5), and then we remove all commas, decimal points, and spaces to get a string **S**. Return all possible original strings to a list. The original coordinate notation will not have extra zeros, so there will be no **00**, **0.0**, **0.00**, **1.0**, **001**, **00.01** or some other smaller numbers to represent coordinates. In addition, there is at least one number before a decimal point, so there will be no **.1** form of numbers. Note that there is a space between the two returned numbers (after the comma);\nPlease create a class **AOR** based on the above problem using Python language, with the attribute **s**; then create a class **SN_AOR** that inherits the **AOR** class, and add a public function **Any_order** to return all possible original strings in any order to a list after removing all commas, decimal points, and spaces from the string **S**.", "test_list": ["assert candidate(\"(123)\")==[\"(1, 23)\", \"(12, 3)\", \"(1.2, 3)\", \"(1, 2.3)\"]", "assert candidate(\"(00011)\")==[\"(0.001, 1)\", \"(0, 0.011)\"]", "assert candidate(\"(0123)\")==[\"(0, 123)\", \"(0, 12.3)\", \"(0, 1.23)\", \"(0.1, 23)\", \"(0.1, 2.3)\", \"(0.12, 3)\"]", "assert candidate(\"(100)\")==[(10, 0)]"], "test_function": "def test_run(content1):\n    return SN_AOR(content1).Any_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class AOR', 'class SN_AOR(AOR)', 'super().__init__(s)', 'def Any_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/266", "question": "Question: The valid encoding of the word array **words** consists of any mnemonic string **s** and index array **indices**, and meets the following requirements:\n1. words.length == indices.length\n2. The mnemonic string **s** ends with the character '#'\n3. For each index indices[i], a substring of **s** that starts from indices[i] and ends at the next '#' character (but does not include '#') exactly equals to words[i]. Given a word array **words**, return the length of the smallest mnemonic string **s** that successfully encodes **words**;\nBased on the above question, please create a class **ECG** in Python with the attribute **words**; then create a class **SN_ECG** that inherits the **ECG** class, and add a public function **efficient_coding** to return the length of the smallest mnemonic string **s** that successfully encodes **words**.", "test_list": ["assert candidate([\"time\", \"me\", \"bell\"])==10", "assert candidate([\"t\"])==2"], "test_function": "def test_run(content1):\n    return SN_ECG(content1).efficient_coding()", "entry_point": "test_run", "test_matching": "assert candidate([['class ECG', 'class SN_ECG(ECG)', 'super().__init__(words)', 'def efficient_coding']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/267", "question": "Question: Given a string **s** and a character **c**, where **c** is a character that appears in **s**. Return an integer array **answer**, where answer.length == s.length and answer[i] is the distance from index **i** in **s** to the nearest character **c**;\nBased on the above question, please create a class **CDC** in Python, with the attribute **s**; then create another class **SN_CDC**, inheriting from the **CDC** class, and add the attribute **c**, as well as a public function **Character_distance** to return an integer array **answer**.", "test_list": ["assert candidate(\"loveleetcode\",\"e\")==[3,2,1,0,1,0,0,1,2,2,1,0]", "assert candidate(\"aaab\",\"b\")==[3,2,1,0]"], "test_function": "def test_run(content1,content2):\n    return SN_CDC(content1,content2).Character_distance()", "entry_point": "test_run", "test_matching": "assert candidate([['class CDC', 'class SN_CDC(CDC)', 'super().__init__(s)', 'def Character_distance']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/268", "question": "Question: Given an array **arr** containing non-repeating integer elements, each integer arr[i] is greater than 1. Use these integers to construct a binary tree, each integer can be used any number of times. Where: the value of each non-leaf node should be equal to the product of the values of its two child nodes. How many binary trees are there that meet the conditions;\nBased on the above question, please use Python language to create a class **RIR** with the attribute **arr**; then create a class **SN_RIR** that inherits the **RIR** class, and add a public function **repeating_integer** to return the number of binary trees that meet the conditions.", "test_list": ["assert candidate([2, 4])==3", "assert candidate([2, 4, 5, 10])==7"], "test_function": "def test_run(content1):\n    return SN_RIR(content1).repeating_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class RIR', 'class SN_RIR(RIR)', 'super().__init__(arr)', 'def repeating_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/269", "question": "Question: You have **n** jobs and **m** workers. Given three arrays: **difficulty**, **profit**, and **worker**, where: difficulty[i] represents the difficulty of the i-th job, profit[i] represents the profit of the i-th job. **worker[i]** is the ability of the i-th worker, that is, the worker can only complete jobs with difficulty less than or equal to worker[i]. Each worker can only be assigned one job at most, but one job can be completed multiple times. For example, if three workers all try to complete the same job with a reward of $1, then the total profit is $3. If a worker cannot complete any job, his profit is $0. Return the maximum profit we can get after assigning workers to jobs;\nPlease create a class **MPT** in Python based on the above question, with the attribute **difficulty**; then create a class **SN_MPT** that inherits the **MPT** class, and add two attributes **profit** and **worker**, as well as a public function **Maximum_profit** to return the maximum profit we can get after assigning **m** workers to **n** jobs.", "test_list": ["assert candidate([2,4,6,8,10],[10,20,30,40,50],[4,5,6,7])==100", "assert candidate([85,47,57],[24,66,99],[40,25,25])==0"], "test_function": "def test_run(content1,content2,content3):\n    return SN_MPT(content1,content2,content3).Maximum_profit()", "entry_point": "test_run", "test_matching": "assert candidate([['class MPT', 'class SN_MPT(MPT)', 'super().__init__(difficulty)', 'def Maximum_profit']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/270", "question": "Question: Given a binary matrix **grid** of size n x n. You are allowed to change at most one 0 to 1. Return the maximum area of an island in the **grid** after this operation;\nPlease create a class **IAA** in Python based on the above question, with the attribute **grid**. Then create a class **SN_IAA** that inherits from the **IAA** class, and add a public function **Island_area** to return the maximum area of an island in the **grid** after changing one 0 to 1 in the binary matrix **grid**.", "test_list": ["assert candidate([[1, 0], [0, 1]])==3", "assert candidate([[1, 1], [1, 0]])==4", "assert candidate([[1, 1], [1, 1]])==4"], "test_function": "def test_run(content1):\n    return SN_IAA(content1).Island_area()", "entry_point": "test_run", "test_matching": "assert candidate([['class IAA', 'class SN_IAA(IAA)', 'super().__init__(grid)', 'def Island_area']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/271", "question": "Question: Define a function **countUniqueChars** to count the unique characters in string **s**, and return the number of unique characters;\nBased on the above question, please create a class **UCR** in Python language with the attribute **s**; then create another class **SN_UCR** that inherits from the **UCR** class, and add a public function **Unique_character** to return the number of unique characters in string **s**.", "test_list": ["assert candidate(\"ABC\")==10", "assert candidate(\"ABA\")==8", "assert candidate(\"LEETCODE\")==92"], "test_function": "def test_run(content1):\n    return SN_UCR(content1).Unique_character()", "entry_point": "test_run", "test_matching": "assert candidate([['class UCR', 'class SN_UCR(UCR)', 'super().__init__(s)', 'def Unique_character']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/272", "question": "Question: Given a positive integer **n**, return the number of groups of consecutive positive integers that satisfy the sum of all numbers equals **n**;\nBased on the above question, please create a class **SNS** in Python, which has an attribute **n**. Then create another class **SN_SNS** that inherits from the **SNS** class, and add a public function **Sum_Numbers** to return the number of groups of consecutive positive integers that satisfy the sum of all numbers equals **n**.", "test_list": ["assert candidate(5)==2", "assert candidate(9)==3", "assert candidate(15)==5"], "test_function": "def test_run(content1):\n    return SN_SNS(content1).Sum_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class SNS', 'class SN_SNS(SNS)', 'super().__init__(n)', 'def Sum_Numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/273", "question": "Question: Given an undirected, connected tree. The tree has **n** nodes labeled from 0 to n-1 and n-1 edges. Given an integer **n** and an array **edges**, edges[i] = [a_i, b_i] indicates that there is an edge between nodes a_i and b_i in the tree. Return an array answer of length **n**, where answer[i] is the sum of the distances between the i-th node and all other nodes in the tree;\nBased on the above question, please create a class **SDC** in Python language with the attribute **n**; then create a class **SN_SDC** that inherits from the **SDC** class, and add the attribute **edges**, as well as a public function **Sum_distances** to return an array **answer** of length **n**.", "test_list": ["assert candidate(6,[[0,1],[0,2],[2,3],[2,4],[2,5]])==[8,12,6,10,10,10]", "assert candidate(1,[])==[0]", "assert candidate(2,[[1,0]])==[1,1]"], "test_function": "def test_run(content1,content2):\n    return SN_SDC(content1,content2).Sum_distances()", "entry_point": "test_run", "test_matching": "assert candidate([['class SDC', 'class SN_SDC(SDC)', 'super().__init__(n)', 'def Sum_distances']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/274", "question": "Question: Given two images **img1** and **img2**, both of which are n x n in size and represented by binary square matrices of the same size. The binary matrix is composed only of several 0s and 1s. Transform one of the images by sliding all the 1s to the left, right, up, or down by any number of units; then place it on top of the other image. The overlap of this transformation refers to the number of positions where both images have 1s. Please note that the transformation does not include rotation in any direction. Any 1s that cross the matrix boundary will be cleared. What is the maximum possible number of overlaps?\nBased on the above question, please create a class **OQT** in Python with the attribute **img1**; then create another class **SN_OQT** that inherits from the **OQT** class, and add the attribute **img2**, as well as a public function **Overlap_quantity** to return the maximum possible number of overlaps.", "test_list": ["assert candidate([[1,1,0],[0,1,0],[0,1,0]],[[0,0,0],[0,1,1],[0,0,1]])==3", "assert candidate([[1]],[[1]])==1", "assert candidate([[0]],[[0]])==0"], "test_function": "def test_run(content1,content2):\n    return SN_OQT(content1,content2).Overlap_quantity()", "entry_point": "test_run", "test_matching": "assert candidate([['class OQT', 'class SN_OQT(OQT)', 'super().__init__(img1)', 'def Overlap_quantity']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/275", "question": "Question: A rectangle is represented as a list [x1,y1,x2,y2], where (x1,y1) is the coordinate of the bottom left corner, and (x2,y2) is the coordinate of the top right corner. The top and bottom edges of the rectangle are parallel to the x-axis, and the left and right edges are parallel to the y-axis. If the intersecting area is positive, then the two rectangles are considered to be **overlapping**. It should be clarified that two rectangles that only touch at the corner or edge do not constitute an overlap. Given two rectangles **rec1** and **rec2**. If they overlap, return True; otherwise, return False.\nBased on the above question, please create a class **ROP** in Python language with the attribute **rec1**; then create a class **SN_ROP** that inherits from the **ROP** class, and add the attribute **rec2**, as well as a public function **Rectangle_overlap** to determine whether the intersecting area of the two rectangles **rec1** and **rec2** is positive. If it is, return True; otherwise, return False.", "test_list": ["assert candidate([0,0,2,2],[1,1,3,3])==True", "assert candidate([0,0,1,1],[1,0,2,1])==False", "assert candidate([0,0,1,1],[2,2,3,3])==False"], "test_function": "def test_run(content1,content2):\n    return SN_ROP(content1,content2).Rectangle_overlap()", "entry_point": "test_run", "test_matching": "assert candidate([['class ROP', 'class SN_ROP(ROP)', 'super().__init__(rec1)', 'def Rectangle_overlap']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/276", "question": "Question: Alice participates in a game roughly based on the rules of the card game **Blackjack**, described as follows: Alice starts with 0 points, and draws numbers when her score is less than k points. When drawing, she randomly gets an integer from the range [1, maxPts] to accumulate as a score, where **maxPts** is an integer. Each draw is independent, and the results have the same probability. When Alice gets **k** points or more, she stops drawing numbers. What is the probability that Alice's score does not exceed **n**;\nPlease create a class **ENS** in python language based on the above question, with the attribute **n**; then create a class **SN_ENS**, inheriting from the **ENS** class, and add two attributes **k** and **maxPts**, as well as a public **Extract_Numbers** function to return the probability that Alice's score does not exceed **n**.", "test_list": ["assert candidate(10,1,10)==1.00000", "assert candidate(6,1,10)==0.60000", "assert candidate(21,17,10)==0.73278"], "test_function": "def test_run(content1,content2,content3):\n    return SN_ENS(content1,content2,content3).Extract_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class ENS', 'class SN_ENS(ENS)', 'super().__init__(n)', 'def Extract_Numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/277", "question": "Question: If two different positions in string **X** are swapped to make it equal to string **Y**, then **X** and **Y** are considered similar. If the two strings are identical, they are also similar. Given a list of strings **strs**, each string in the list is an anagram of all other strings in **strs**. How many similar string groups are there in **strs**;\nBased on the above question, create a class **SST** in Python with the attribute **strs**; then create a class **SN_SST** that inherits from the **SST** class, and add a public function **Similar_Strings** to return the number of similar string groups in the string list **strs**.", "test_list": ["assert candidate([\"tars\",\"rats\",\"arts\",\"star\"])==2", "assert candidate([\"omv\",\"ovm\"])==1"], "test_function": "def test_run(content1):\n    return SN_SST(content1).Similar_Strings()", "entry_point": "test_run", "test_matching": "assert candidate([['class SST', 'class SN_SST(SST)', 'super().__init__(strs)', 'def Similar_Strings']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/278", "question": "Question: A 3x3 magic square is a 3x3 matrix filled with distinct numbers from 1 to 9, where the sum of each row, each column, and the two diagonals are equal. Given a grid of row x col composed of integers, how many 3x3 **magic square** submatrices are there? (Each submatrix is continuous);\nBased on the above question, please create a **SAX** class in Python with a **grid** attribute; then create a **SN_SAX** class that inherits from the **SAX** class, and add a public **submatrix** function to return the number of 3x3 magic square submatrices.", "test_list": ["assert candidate([[4,3,8,4],[9,5,1,9],[2,7,6,2]])==1", "assert candidate([[8]])==0"], "test_function": "def test_run(content1):\n    return SN_SAX(content1).submatrix()", "entry_point": "test_run", "test_matching": "assert candidate([['class SAX', 'class SN_SAX(SAX)', 'super().__init__(grid)', 'def submatrix']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/279", "question": "Question: There are **n** rooms, numbered from 0 to n-1. Initially, all rooms except room 0 are locked. Your goal is to enter all rooms. However, you cannot enter a locked room without obtaining the key. When you enter a room, you may find a set of different keys inside, each key has a corresponding room number, indicating the room that the key can open. You can take all the keys to unlock other rooms. You are given an array **rooms**, where rooms[i] is the set of keys you can get when you enter room **i**. If you can enter all rooms, return True, otherwise return False.\nPlease create a class **ARS** in Python based on the above question, with the property **rooms**. Then create a class **SN_ARS** that inherits the **ARS** class, and add a public function **All_rooms** to determine whether you can enter all **n** rooms numbered from 0 to n-1. If you can, return True, otherwise return False.", "test_list": ["assert candidate([[1],[2],[3],[]])==True", "assert candidate([[1,3],[3,0,1],[2],[0]])==False"], "test_function": "def test_run(content1):\n    return SN_ARS(content1).All_rooms()", "entry_point": "test_run", "test_matching": "assert candidate([['class ARS', 'class SN_ARS(ARS)', 'super().__init__(rooms)', 'def All_rooms']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/280", "question": "Question: Given a string of digits **num**, such as \"123456579\", we can split it into a Fibonacci-like sequence [123,456,579]. Formally, a Fibonacci-like sequence is a list of non-negative integers **f**, satisfying:\n1. 0<=f[i]<231, (in other words, each integer conforms to the 32-bit signed integer type). 2. f.length>=3. 3. For all 0<=i<f.length-2, f[i]+f[i+1]=f[i+2]. Also, please note that when splitting the string into chunks, each chunk's number must not start with zero, unless the chunk is the number 0 itself. Return any Fibonacci-like sequence chunks split from num, if it cannot be split, return [].\nBased on the above question, please create a class **FEQ** in Python, with the attribute **num**; then create another class **SN_FEQ**, inheriting from the **FEQ** class, and add a public function **Fibonacci_equation** to return any Fibonacci-like sequence chunks split from **num**, if it cannot be split, return [].", "test_list": ["assert candidate(\"1101111\")==[11,0,11,11]", "assert candidate(\"112358130\")==[]", "assert candidate(\"0123\")==[]"], "test_function": "def test_run(content1):\n    return SN_FEQ(content1).Fibonacci_equation()", "entry_point": "test_run", "test_matching": "assert candidate([['class FEQ', 'class SN_FEQ(FEQ)', 'super().__init__(num)', 'def Fibonacci_equation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/281", "question": "Question: An array arr is called a mountain array if it meets the following properties:\n1. arr.length>=3. 2. There exists an index **i** (0<i<arr.length-1), such that arr[0]<arr[1]<...<arr[i-1]<arr[i] and arr[i]>arr[i+1]>...>arr[arr.length-1]. Given an integer array **arr**, return the length of the longest mountain subarray. If there is no mountain subarray, return 0;\nBased on the above question, please create a class **LMN** in Python, which has the property **arr**; then create a class **SN_LMN** that inherits the **LMN** class, and add a public function **Longest_mountain** to return the length of the longest **mountain subarray** in the integer array **arr**. If there is no mountain subarray, return 0.", "test_list": ["assert candidate([2,1,4,7,3,2,5])==5", "assert candidate([2,2,2])==0"], "test_function": "def test_run(content1):\n    return SN_LMN(content1).Longest_mountain()", "entry_point": "test_run", "test_matching": "assert candidate([['class LMN', 'class SN_LMN(LMN)', 'super().__init__(arr)', 'def Longest_mountain']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/282", "question": "Question: Alice has a deck of cards in her hand. She wants to rearrange these cards into several groups, each with a group size of **groupSize**, and each group consists of **groupSize** consecutive cards. You are given an integer array **hand** where hand[i] is the value written on the i-th card. If she can rearrange these cards, return True; otherwise, return False.\nBased on the above question, please create a class **RRG** in Python, which has the attribute **hand**; then create a class **SN_RRG** that inherits the **RRG** class, and add the attribute **groupSize**, as well as a public function **rearrange** to determine whether Alice can rearrange the deck of cards in her hand into several groups, each with a group size of **groupSize**, and each group consists of **groupSize** consecutive cards.", "test_list": ["assert candidate([1,2,3,6,2,3,4,7,8],3)==True", "assert candidate([1,2,3,4,5],4)==False"], "test_function": "def test_run(content1,content2):\n    return SN_RRG(content1,content2).rearrange()", "entry_point": "test_run", "test_matching": "assert candidate([['class RRG', 'class SN_RRG(RRG)', 'super().__init__(hand)', 'def rearrange']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/283", "question": "Question: There exists an undirected connected graph composed of **n** nodes, with the nodes numbered from 0 to n-1. A given array **graph** represents this graph. In it, graph[i] is a list, composed of all nodes directly connected to node **i**. Return the length of the shortest path that can visit all nodes. You can start and stop at any node, revisit nodes multiple times, and reuse edges;\nBased on the above question, create a class **TTH** using Python, with the property **graph**; then create another class **SN_TTH** that inherits from the **TTH** class, and add a public function **The_length** to return the length of the shortest path that can visit all nodes.", "test_list": ["assert candidate([[1,2,3],[0],[0],[0]])==4", "assert candidate([[1],[0,2,4],[1,3,4],[2],[1,2]])==4"], "test_function": "def test_run(content1):\n    return SN_TTH(content1).The_length()", "entry_point": "test_run", "test_matching": "assert candidate([['class TTH', 'class SN_TTH(TTH)', 'super().__init__(graph)', 'def The_length']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/284", "question": "Question: There is a string **s** composed of lowercase letters, and an integer array **shifts** of the same length. We call the next letter in the alphabet a **shift** of the original letter (since the alphabet is circular, 'z' will become 'a'). Return the final string obtained after applying all these shifts to **s**;\nBased on the above question, please create a class **SAN** in Python language with the attribute **s**; then create a class **SN_SAN** that inherits the **SAN** class, and add the attribute **shifts**, as well as a public function **Shift_application** to return the final string obtained after applying all these shifts to **s**.", "test_list": ["assert candidate(\"abc\",[3,5,9])==\"rpl\"", "assert candidate(\"aaa\",[1,2,3])==\"gfd\""], "test_function": "def test_run(content1,content2):\n    return SN_SAN(content1,content2).Shift_application()", "entry_point": "test_run", "test_matching": "assert candidate([['class SAN', 'class SN_SAN(SAN)', 'super().__init__(s)', 'def Shift_application']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/285", "question": "Question: Given an array **seats** representing a row of seats, where seats[i]=1 means someone is sitting in the i-th seat, and seats[i]=0 means the i-th seat is empty (index starts from 0). There is at least one empty seat, and at least one person is already sitting. Alex wants to sit in a seat that maximizes the distance to the nearest person;\nBased on the above question, use Python to create a class **ASG** with the attribute **seats**. Then create a class **SN_ASG** that inherits the **ASG** class, and add a public function **Maximized_seating** that returns the maximum distance from Alex to the nearest person.", "test_list": ["assert candidate([1,0,0,0,1,0,1])==2", "assert candidate([1,0,0,0])==3", "assert candidate([0,1])==1"], "test_function": "def test_run(content1):\n    return SN_ASG(content1).Maximized_seating()", "entry_point": "test_run", "test_matching": "assert candidate([['class ASG', 'class SN_ASG(ASG)', 'super().__init__(seats)', 'def Maximized_seating']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/286", "question": "Question: Given an axis-aligned 2D array **rectangles**. For rectangle[i]=[x1,y1,x2,y2], where (x1,y1) are the coordinates of the bottom left corner of rectangle **i**, (x_i1,y_i1) are the coordinates of the bottom left corner of the rectangle, and (x_i2,y_i2) are the coordinates of the top right corner of the rectangle. Calculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once, return the total area.\nBased on the above question, please create a class **TAR** in Python language with the attribute **rectangles**; then create a class **SN_TAR** that inherits the **TAR** class, and add a public function **total_area** to return the total area covered by all axis-aligned 2D array rectangles in the plane.", "test_list": ["assert candidate([[0,0,2,2],[1,0,2,3],[1,0,3,1]])==6", "assert candidate([[0,0,1000000000,1000000000]])==49"], "test_function": "def test_run(content1):\n    return SN_TAR(content1).total_area()", "entry_point": "test_run", "test_matching": "assert candidate([['class TAR', 'class SN_TAR(TAR)', 'super().__init__(rectangles)', 'def total_area']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/287", "question": "Question: For some non-negative integers **k**, if swapping the positions of two letters in **s1** exactly **k** times can result in a string equal to **s2**, then the similarity of strings **s1** and **s2** is considered to be **k**. Given two anagrams s1 and s2, return the minimum value of the similarity **k** between **s1** and **s2**;\nBased on the above question, please create a class named **MVE** using Python, which has an attribute **s1**. Then create another class named **SN_MVE**, inheriting from the **MVE** class, and add an attribute **s2**, as well as a public function **Minimum_value** to return the minimum value of the similarity **k** between the given two anagrams **s1** and **s2**.", "test_list": ["assert candidate(\"ab\",\"ba\")==1", "assert candidate(\"abc\",\"bca\")==2"], "test_function": "def test_run(content1,content2):\n    return SN_MVE(content1,content2).Minimum_value()", "entry_point": "test_run", "test_matching": "assert candidate([['class MVE', 'class SN_MVE(MVE)', 'super().__init__(s1)', 'def Minimum_value']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/288", "question": "Question: Given a balanced parentheses string **S**, calculate the score of the string according to the following rules:\n1. **()** gets 1 point. 2. **AB** gets A+B points, where A and B are balanced parentheses strings. 3. **(A)** gets 2*A points, where A is a balanced parentheses string.\nBased on the above question, please create a class **BPS** in Python, with the attribute **S**. Then create another class **SN_BPS** that inherits from the **BPS** class, and add a public function **Balanced_parentheses** to return the score of a given balanced parentheses string **S** calculated according to the rules.", "test_list": ["assert candidate(\"()\")==1", "assert candidate(\"(())\")==2", "assert candidate(\"()()\")==2", "assert candidate(\"(()(()))\")==6"], "test_function": "def test_run(content1):\n    return SN_BPS(content1).Balanced_parentheses()", "entry_point": "test_run", "test_matching": "assert candidate([['class BPS', 'class SN_BPS(BPS)', 'super().__init__(S)', 'def Balanced_parentheses']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/289", "question": "Question: There is a special **square room**, each wall of which has a mirror. Except for the **southwest corner**, there is a receiver in each corner, numbered as 0, 1, and 2. The length of the wall of the square room is **p**, a laser beam is emitted from the southwest corner, and it will first meet the east wall. The distance from the point of incidence to receiver 0 is **q**. Return the number of the receiver that the returned light first encounters (ensure that the light will eventually encounter a receiver);\nBased on the above question, please use Python language to create a class **RNE** with the attribute **p**; then create a class **SN_RNE** that inherits the **RNE** class, and add the attribute **q** and a public function **Receiver_number** to return the number of the receiver that the light first encounters.", "test_list": ["assert candidate(2,1)==2", "assert candidate(3,1)==1"], "test_function": "def test_run(content1,content2):\n    return SN_RNE(content1,content2).Receiver_number()", "entry_point": "test_run", "test_matching": "assert candidate([['class RNE', 'class SN_RNE(RNE)', 'super().__init__(p)', 'def Receiver_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/290", "question": "Question: Given a binary matrix **grid** of size m x n, where each element in the matrix is either 0 or 1. A move is defined as choosing any row or column and flipping the values in that row or column: change all 0s to 1s and all 1s to 0s. After making any number of moves, the score of the matrix is the sum of the numbers obtained by interpreting each row as a binary number. After making any number of moves (including 0), return the possible highest score;\nBased on the above question, please create a class **HSE** in Python with the attribute **grid**. Then create a class **SN_HSE** that inherits from the **HSE** class, and add a public function **Highest_Score** to return the possible highest score.", "test_list": ["assert candidate([[0,0,1,1],[1,0,1,0],[1,1,0,0]])==39", "assert candidate([[0]])==1"], "test_function": "def test_run(content1):\n    return SN_HSE(content1).Highest_Score()", "entry_point": "test_run", "test_matching": "assert candidate([['class HSE', 'class SN_HSE(HSE)', 'super().__init__(grid)', 'def Highest_Score']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/291", "question": "Question: Given an integer array **nums** and an integer **k**, find the shortest non-empty subarray in **nums** whose sum is at least **k**, and return the length of this subarray. If such a subarray does not exist, return -1;\nBased on the above question, create a class **SEY** in Python, which has the attribute **nums**; then create another class **SN_SEY** that inherits from the **SEY** class, and add the attribute **k**, as well as a public function **Shortest_empty** to return the length of the shortest non-empty subarray in **nums** whose sum is at least **k**.", "test_list": ["assert candidate([1],1)==1", "assert candidate([1,2],4)==-1", "assert candidate([2,-1,2],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_SEY(content1,content2).Shortest_empty()", "entry_point": "test_run", "test_matching": "assert candidate([['class SEY', 'class SN_SEY(SEY)', 'super().__init__(nums)', 'def Shortest_empty']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/292", "question": "Question: Find the smallest palindrome prime number that is greater than or equal to **N**;\nBased on the above question, please create a class **PPM** in Python with an attribute **N**. Then, create another class **SN_PPM** that inherits from the **PPM** class, and add a public function **prime_palindromes** to return the smallest palindrome prime number that is greater than or equal to **N**.", "test_list": ["assert candidate(6)==7", "assert candidate(8)==11", "assert candidate(13)==101"], "test_function": "def test_run(content1):\n    return SN_PPM(content1).prime_palindromes()", "entry_point": "test_run", "test_matching": "assert candidate([['class PPM', 'class SN_PPM(PPM)', 'super().__init__(N)', 'def prime_palindromes']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/293", "question": "Question: Given a positive integer **n**, we reorder the digits in any order (including the original order), noting that the leading digit cannot be zero. If we can obtain a power of 2 in this way, return True; otherwise, return False;\nBased on the above question, please create a class **NRG** in Python with the attribute **n**; then create a class **SN_NRG** that inherits from the **NRG** class, and add a public function **Number_Reordering** to determine whether reordering the positive integer **n** in any order (including the original order) can result in a power of 2. If it can, return True; otherwise, return False.", "test_list": ["assert candidate(1)==True", "assert candidate(10)==False"], "test_function": "def test_run(content1):\n    return SN_NRG(content1).Number_Reordering()", "entry_point": "test_run", "test_matching": "assert candidate([['class NRG', 'class SN_NRG(NRG)', 'super().__init__(n)', 'def Number_Reordering']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/294", "question": "Question: Given two arrays of equal length, **nums1** and **nums2**, the advantage of **nums1** over **nums2** can be described by the number of indices **i** for which nums1[i] > nums2[i]. Return any permutation of **nums1** that maximizes its advantage over **nums2**;\nBased on the above question, create a class **MAS** in Python with the attribute **nums1**. Then create a class **SN_MAS** that inherits from the **MAS** class, and add the attribute **nums2**, as well as a public function **Maximizing_Advantages** that returns any permutation of **nums1** that maximizes its **advantage** over **nums2**.", "test_list": ["assert candidate([2,7,11,15],[1,10,4,11])==[2,11,7,15]", "assert candidate([12,24,8,32],[13,25,32,11])==[24,32,8,12]"], "test_function": "def test_run(content1,content2):\n    return SN_MAS(content1,content2).Maximizing_Advantages()", "entry_point": "test_run", "test_matching": "assert candidate([['class MAS', 'class SN_MAS(MAS)', 'super().__init__(nums1)', 'def Maximizing_Advantages']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/295", "question": "Question: If a sequence X_1, X_2, ..., X_n satisfies the following conditions, it is said to be **Fibonacci-like**:\n1. n>=3. 2. For all i+2<=n, we have X_i+X_{i+1}=X_{i+2}. Given a strictly increasing positive integer array forming a sequence **arr**, find the length of the longest Fibonacci-like subsequence in **arr**. If one does not exist, return 0;\nBased on the above question, please create a class **PAY** in Python, which has the attribute **arr**; then create a class **SN_PAY** that inherits the **PAY** class, and add a public function **Positive_array** to return the length of the longest Fibonacci-like subsequence in the strictly increasing positive integer array forming the sequence **arr**.", "test_list": ["assert candidate([1,2,3,4,5,6,7,8])==5", "assert candidate([1,3,7,11,12,14,18])==3"], "test_function": "def test_run(content1):\n    return SN_PAY(content1).Positive_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class PAY', 'class SN_PAY(PAY)', 'super().__init__(arr)', 'def Positive_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/296", "question": "Question: Koko loves to eat bananas. There are **n** piles of bananas here, and the i-th pile has piles[i] bananas. The guard has already left and will return in **h** hours. Koko can decide her eating speed **k** (unit: bananas/hour). Every hour, she will choose a pile of bananas and eat **k** bananas from it. If this pile has fewer than **k** bananas, she will eat all the bananas in this pile, and will not eat any more bananas within this hour. Koko likes to eat slowly, but still wants to eat all the bananas before the guard comes back. Return the minimum speed **k** (k is an integer) at which she can eat all the bananas within **h** hours;\nBased on the above question, please create a class **MSD** in Python language with the attribute **piles**; then create a class **SN_MSD** that inherits the **MSD** class, and add the attribute **h**, as well as a public function **Minimum_Speed** to return the minimum speed **k** at which Koko can eat all the bananas within **h** hours.", "test_list": ["assert candidate([3,6,7,11],8)==4", "assert candidate([30,11,23,4,20],5)==30", "assert candidate([30,11,23,4,20],6)==23"], "test_function": "def test_run(content1,content2):\n    return SN_MSD(content1,content2).Minimum_Speed()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSD', 'class SN_MSD(MSD)', 'super().__init__(piles)', 'def Minimum_Speed']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/297", "question": "Question: A positive integer is magical if it can be divided by **a** or **b**. Given three integers **n**, **a**, **b**, return the n-th magical number;\nBased on the above question, create a class **MNS** in Python with the attribute **n**; then create another class **SN_MNS** that inherits from the **MNS** class, and add two attributes **a** and **b**, as well as a public function **Magical_Numbers** to return the n-th magical number.", "test_list": ["assert candidate(1,2,3)==2", "assert candidate(4,2,3)==6"], "test_function": "def test_run(content1,content2,content3):\n    return SN_MNS(content1,content2,content3).Magical_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class MNS', 'class SN_MNS(MNS)', 'super().__init__(n)', 'def Magical_Numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/298", "question": "Question: There are **n** employees in the group, who can complete various jobs to generate profits. The i-th job will generate a profit of profit[i], and it requires group[i] members to participate together. If a member participates in one job, he/she cannot participate in another job. Any subset of jobs that generates at least **minProfit** profit is called a profitable plan. And the total number of job members is up to **n**. How many plans can be chosen;\nBased on the above question, please create a class called **PPN** in Python, which has an attribute **n**; then create another class **SN_PPN** that inherits from the **PPN** class, and add three attributes **minProfit**, **group**, and **profit**, as well as a public function **Profit_Plan** that returns the number of profitable plans.", "test_list": ["assert candidate(5,3,[2,2],[2,3])==2", "assert candidate(10,5,[2,3,5],[6,7,8])==7"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_PPN(content1,content2,content3,content4).Profit_Plan()", "entry_point": "test_run", "test_matching": "assert candidate([['class PPN', 'class SN_PPN(PPN)', 'super().__init__(n)', 'def Profit_Plan']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/299", "question": "Question: Given an encoded string **S**. You are asked to find the decoded string and write it onto a tape. During the decoding process, read one character from the encoded string at a time, and take the following steps:\n1. If the character read is a letter, write it on the tape. 2. If the character read is a number (such as **d**), the entire current tape will be written repeatedly **d-1** times. Now, for the given encoded string **S** and index **K**, find and return the K-th letter in the decoded string;\nYou are required to create a class **DSG** in Python, which has the attribute **S**; then create another class **SN_DSG** that inherits from the **DSG** class, and add the attribute **K**, as well as a public function **Decode_String** to find and return the K-th letter in the given encoded string **S**.", "test_list": ["assert candidate(\"leet2code3\",10)==\"o\"", "assert candidate(\"ha22\",5)==\"h\"", "assert candidate(\"a2345678999999999999999\",1)==\"a\""], "test_function": "def test_run(content1,content2):\n    return SN_DSG(content1,content2).Decode_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class DSG', 'class SN_DSG(DSG)', 'super().__init__(S)', 'def Decode_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/300", "question": "Question: Given an array **people**. people[i] represents the weight of the i-th person, the number of boats is unlimited, and each boat can carry a maximum weight of **limit**. Each boat can carry up to two people at the same time, but the condition is that the sum of these people's weights is at most **limit**. Return the minimum number of boats required to carry all people;\nBased on the above question, please create a class **MSS** in Python language with the attribute **people**; then create a class **SN_MSS**, inherit the **MSS** class, and add the attribute **limit**, as well as a public function **Minimum_ships** to return the minimum number of boats required to carry all people.", "test_list": ["assert candidate([1,2],3)==1", "assert candidate([3,2,2,1],3)==3", "assert candidate([3,5,3,4],5)==4"], "test_function": "def test_run(content1,content2):\n    return SN_MSS(content1,content2).Minimum_ships()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSS', 'class SN_MSS(MSS)', 'super().__init__(people)', 'def Minimum_ships']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/301", "question": "Question: In an n x n **grid**, we place some 1 x 1 x 1 cubes aligned with the **x**, **y**, **z** axes. Each value v = grid[i][j] represents **v** cubes stacked on the cell (i, j). Now, we look at the projections of these cubes on the **xy**, **yz**, and **zx** planes. A projection is like a shadow, mapping a three-dimensional shape onto a two-dimensional plane. When we look at the cube from the top, front, and side, we will see the shadow. Return the total area of all three projections;\nPlease create a class **TPD** based on the above question using Python, with the attribute **grid**; then create a class **SN_TPD**, inheriting from the **TPD** class, and add a public function **Total_projected** to return the total area of all the cubes' projections on the **xy**, **yz**, and **zx** planes.", "test_list": ["assert candidate([[1,2],[3,4]])==17", "assert candidate([[2]])==5", "assert candidate([[1,0],[0,2]])==8"], "test_function": "def test_run(content1):\n    return SN_TPD(content1).Total_projected()", "entry_point": "test_run", "test_matching": "assert candidate([['class TPD', 'class SN_TPD(TPD)', 'super().__init__(grid)', 'def Total_projected']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/302", "question": "Question: On a grid of rows x cols, you start from the cell (rStart, cStart) facing east. The northwest corner of the grid is at the first row and the first column, and the southeast corner is at the last row and the last column. You need to walk in a clockwise spiral, visiting every position in this grid. Whenever you move beyond the boundary of the grid, you need to continue walking outside the grid (but you may return to the grid boundary later). Eventually, we have visited all the rows x cols spaces in the grid. Return the list of coordinates representing the grid positions in the order of visit;\nBased on the above question, please create a class **CLT** in Python language with the property **rows**; then create another class **SN_CLT** that inherits the **CLT** class, and add three properties **cols**, **rStart** and **cStart**, as well as a public function **Coordinate_List** to return the list of coordinates representing the grid positions in the order of visit.", "test_list": ["assert candidate(1,4,0,0)==[[0,0],[0,1],[0,2],[0,3]]", "assert candidate(5,6,1,4)==[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_CLT(content1,content2,content3,content4).Coordinate_List()", "entry_point": "test_run", "test_matching": "assert candidate([['class CLT', 'class SN_CLT(CLT)', 'super().__init__(rows)', 'def Coordinate_List']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/303", "question": "Question: Given a set of **n** people (numbered 1,2,...,n), we want to divide each person into two groups of any size. Each person may not like others, so they should not belong to the same group. Given the integer **n** and the array **dislikes**, where dislikes[i]=[a_i,b_i], it is not allowed to put the people numbered **a_i** and **b_i** into the same group. When all people can be divided into two groups in this way, return True; otherwise, return False;\nBased on the above question, please create a class **GPG** in Python with the attribute **n**; then create a class **SN_GPG** that inherits from the **GPG** class, and add the attribute **dislikes**, as well as a public function **grouping** to determine whether each person can be divided into two groups of any size given the integer **n**and the array **dislikes**. If it is possible, return True; otherwise, return False.", "test_list": ["assert candidate(4,[[1,2],[1,3],[2,4]])==True", "assert candidate(3,[[1,2],[1,3],[2,3]])==False", "assert candidate(5,[[1,2],[2,3],[3,4],[4,5],[1,5]])==False"], "test_function": "def test_run(content1,content2):\n    return SN_GPG(content1,content2).grouping()", "entry_point": "test_run", "test_matching": "assert candidate([['class GPG', 'class SN_GPG(GPG)', 'super().__init__(n)', 'def grouping']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/304", "question": "Question: You are given **k** identical eggs and you have access to a building with **n** floors from the 1st floor to the n-th floor. It is known that there exists a floor **f**, satisfying 0<=f<=n, any eggs dropped from a floor higher than **f** will break, and those dropped from the **f** floor or lower will not break. Each time, you can take an unbroken egg and drop it from any floor **x** (satisfying 1<=x<=n). If the egg breaks, you cannot use it again. If an egg does not break after being dropped, it can be reused in subsequent operations. Please calculate and return the minimum number of operations to determine the exact value of **f**.\nPlease create a class **NOS** in Python based on the above problem, with the attribute **k**. Then create a class **SN_NOS** that inherits from the **NOS** class, adds the attribute **n**, and a public function **number_operations** to calculate and return the minimum number of operations to determine the exact value of **f**.", "test_list": ["assert candidate(1,2)==2", "assert candidate(2,6)==3", "assert candidate(3,14)==4"], "test_function": "def test_run(content1,content2):\n    return SN_NOS(content1,content2).number_operations()", "entry_point": "test_run", "test_matching": "assert candidate([['class NOS', 'class SN_NOS(NOS)', 'super().__init__(k)', 'def number_operations']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/305", "question": "Question: The width of a sequence is defined as the difference between the maximum and minimum elements in the sequence. Given an integer array **nums**, return the sum of the widths of all non-empty subsequences of **nums**. A subsequence is defined as an array obtained by deleting some (or not deleting) elements from an array without changing the order of the remaining elements.\nBased on the above question, please create a class **SWS** in Python, which has the attribute **nums**; then create another class **SN_SWS** that inherits from the **SWS** class, and add a public function **Sum_widths** to return the sum of the widths of all non-empty subsequences of the integer array **nums**.", "test_list": ["assert candidate([2,1,3])==6", "assert candidate([2])==0"], "test_function": "def test_run(content1):\n    return SN_SWS(content1).Sum_widths()", "entry_point": "test_run", "test_matching": "assert candidate([['class SWS', 'class SN_SWS(SWS)', 'super().__init__(nums)', 'def Sum_widths']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/306", "question": "Question: We have a non-negative integer array **arr**. For each (continuous) subarray sub=[arr[i],arr[i+1],...,arr[j]] (i<=j), we perform a bitwise OR operation on each element in **sub**, obtaining the result arr[i]|arr[i+1]|...|arr[j]. Return the number of possible results. Multiple occurrences of the result are only counted once in the final answer;\nPlease create a class **FAR** with the property **arr** in Python language based on the above question; then create a class **SN_FAR** inheriting the **FAR** class, and add a public function **Final_Answer** to return the number of possible results.", "test_list": ["assert candidate([0])==1", "assert candidate([1,1,2])==3", "assert candidate([1,2,4])==6"], "test_function": "def test_run(content1):\n    return SN_FAR(content1).Final_Answer()", "entry_point": "test_run", "test_matching": "assert candidate([['class FAR', 'class SN_FAR(FAR)', 'super().__init__(arr)', 'def Final_Answer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/307", "question": "Question: Given a string **s** and an integer **k**. You can choose one from the first **k** letters of **s** and add it to the end of the string. Return the lexicographically smallest string after any number of moves applying the above steps;\nPlease create a class **SSG** with the attribute **s** in Python based on the above question; then create another class **SN_SSG** that inherits from the **SSG** class, and add the attribute **k**, as well as a public function **Smallest_string** to return the lexicographically smallest string after any number of moves applying the above steps.", "test_list": ["assert candidate(\"cba\",1)==\"acb\"", "assert candidate(\"baaca\",3)==\"aaabc\""], "test_function": "def test_run(content1,content2):\n    return SN_SSG(content1,content2).Smallest_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSG', 'class SN_SSG(SSG)', 'super().__init__(s)', 'def Smallest_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/308", "question": "Question: Given a numerical array **digits** sorted in non-decreasing order. You can write numbers using digits[i] any number of times. For example, if digits = ['1','3','5'], we can write numbers like '13', '551', and '1351315'. Return the number of positive integers that can be generated that are less than or equal to a given integer **n**;\nPlease create a class **NDG** in Python based on the above question, with the property **digits**; then create a class **SN_NDG** that inherits the **NDG** class, and add the property **n**, as well as a public function **Non_decreasing** to return the number of positive integers that can be generated that are less than or equal to the given integer **n**.", "test_list": ["assert candidate([\"1\",\"3\",\"5\",\"7\"],100)==20", "assert candidate([\"1\",\"4\",\"9\"],1000000000)==29523", "assert candidate([\"7\"],8)==1"], "test_function": "def test_run(content1,content2):\n    return SN_NDG(content1,content2).Non_decreasing()", "entry_point": "test_run", "test_matching": "assert candidate([['class NDG', 'class SN_NDG(NDG)', 'super().__init__(digits)', 'def Non_decreasing']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/309", "question": "Question: Given a string **s** of length **n**, where s[i] is:\n1. **D** means decrease; 2. **I** means increase; A valid arrangement is a permutation **perm** of n+1 integers within the range [0, n], so that for all **i**:\n1. If s[i] == 'D', then perm[i] > perm[i+1]; 2. If s[i] == 'I', then perm[i] < perm[i+1]. Return the number of valid arrangements **perm**;\nBased on the above question, please create a class **EAT** in Python, with the attribute **s**; then create a class **SN_EAT** that inherits from the **EAT** class, and add a public function **Effective_arrangement** that returns the number of valid arrangements **perm**.", "test_list": ["assert candidate(\"DID\")==5", "assert candidate(\"D\")==1"], "test_function": "def test_run(content1):\n    return SN_EAT(content1).Effective_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([['class EAT', 'class SN_EAT(EAT)', 'super().__init__(s)', 'def Effective_arrangement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/310", "question": "Question: Given an integer array **arr**, find the sum of min(b), where **b** ranges over each (continuous) subarray of **arr**.\nPlease create a class **IAY** in Python language based on the above question, with the attribute **arr**; then create a class **SN_IAY** that inherits from the **IAY** class, and add a public function **Integer_array** to return the sum of min(b).", "test_list": ["assert candidate([3,1,2,4])==17", "assert candidate([11,81,94,43,3])==444"], "test_function": "def test_run(content1):\n    return SN_IAY(content1).Integer_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class IAY', 'class SN_IAY(IAY)', 'super().__init__(arr)', 'def Integer_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/311", "question": "Question: Given an integer array **nums** and an integer **k**. For each index **i** (0<=i<nums.length), change nums[i] to nums[i]+k or nums[i]-k. The score of **nums** is the difference between the maximum and minimum elements in **nums**. After changing the value corresponding to each index, return the minimum score of **nums**;\nBased on the above question, please use Python to create a class **MSE** with the attribute **nums**; then create another class **SN_MSE** that inherits from the **MSE** class, and add the attribute **k**, as well as a public function **Minimum_score** that returns the minimum score of **nums**.", "test_list": ["assert candidate([1],0)==0", "assert candidate([0,10],2)==6", "assert candidate([1,3,6],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MSE(content1,content2).Minimum_score()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSE', 'class SN_MSE(MSE)', 'super().__init__(nums)', 'def Minimum_score']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/312", "question": "Question: Given an integer array **nums**, please sort this array in ascending order;\nBased on the above question, please create a class **AOR** using Python language, with the attribute **nums**; then create another class **SN_AOR** that inherits from the **AOR** class, and add a public function **ascend_order** to sort the integer array **nums** in ascending order.", "test_list": ["assert candidate([5,2,3,1])==[1,2,3,5]", "assert candidate([5,1,1,2,0,0])==[0,0,1,1,2,5]"], "test_function": "def test_run(content1):\n    return SN_AOR(content1).ascend_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class AOR', 'class SN_AOR(AOR)', 'super().__init__(nums)', 'def ascend_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/313", "question": "Question: Two players play the roles of a cat and a mouse respectively, and they play a game on an undirected graph, taking turns to move. The form of the graph is: graph[a] is a list, consisting of all nodes **b** that satisfy that **ab** is an edge in the graph. The **mouse** starts from node 1 and moves first; the **cat** starts from node 2 and moves second. There is a **hole** at node 0. In each player's move, they must move along an edge connected to their current position in the graph. For example, if the mouse is at node 1, it must move to any node in graph[1]. In addition, the cat cannot move into the hole (node 0). Then, the game ends when one of the following three situations occurs: If the cat and the mouse appear at the same node, the cat wins. If the mouse reaches the hole, the mouse wins. If a position is repeated (that is, the player's position and the order of movement are the same as the last action), the game is a draw. Given a graph, and assuming that both players participate in the game in their best state: if the mouse wins, return 1; if the cat wins, return 2; if it is a draw, return 0;\nBased on the above question, please create a class called **CGS** in Python language with the attribute **graph**; then create a class called **SN_CGS** that inherits from the **CGS** class, and add a public function called **Cat_games** to return the final game result.", "test_list": ["assert candidate([[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]])==0", "assert candidate([[1,3],[0],[3],[0,2]])==1"], "test_function": "def test_run(content1):\n    return SN_CGS(content1).Cat_games()", "entry_point": "test_run", "test_matching": "assert candidate([['class CGS', 'class SN_CGS(CGS)', 'super().__init__(graph)', 'def Cat_games']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/314", "question": "Question: Given a deck of cards, each card has an integer written on it. At this point, you need to select a number **X**, so that we can divide the deck into one or more groups according to the following rules: each group has **X** cards. All the cards in the group have the same integer written on them. Return True only when the selectable **X** is greater than or equal to 2, otherwise return False;\nBased on the above question, please use Python language to create a class **SIR** with the attribute **deck**; then create a class **SN_SIR** that inherits the **SIR** class, and add a public function **Same_integer** to determine whether the selectable **X** is greater than or equal to 2. If it is, return True, otherwise, return False.", "test_list": ["assert candidate([1,2,3,4,4,3,2,1])==True", "assert candidate([1,1,1,2,2,2,3,3])==False"], "test_function": "def test_run(content1):\n    return SN_SIR(content1).Same_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class SIR', 'class SN_SIR(SIR)', 'super().__init__(deck)', 'def Same_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/315", "question": "Question: Given an array **nums**, divide it into two consecutive sub-arrays **left** and **right** so that:\n1. Each element in **left** is less than or equal to each element in **right**. 2. Both **left** and **right** are non-empty. 3. The length of **left** should be as small as possible. After completing such grouping, return the length of **left**;\nPlease create a class **PLH** in Python language based on the above question, with the attribute **nums**; then create another class **SN_PLH** that inherits the **PLH** class, and add a public function **Packet_Length** to divide the array **nums** into two consecutive sub-arrays **left** and **right**, and then return the length of **left** after grouping.", "test_list": ["assert candidate([5,0,3,8,6])==3", "assert candidate([1,1,1,0,6,12])==4"], "test_function": "def test_run(content1):\n    return SN_PLH(content1).Packet_Length()", "entry_point": "test_run", "test_matching": "assert candidate([['class PLH', 'class SN_PLH(PLH)', 'super().__init__(nums)', 'def Packet_Length']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/316", "question": "Question: Given two string arrays **words1** and **words2**. Now, if every letter in **b** appears in **a**, including the repeated letters, then we say that string **b** is a subset of string **a**. If for every word **b** in **words2**, **b** is a subset of **a**, then we say that the word **a** in **words1** is a universal word. Return all the universal words in **words1** in the form of an array;\nBased on the above question, create a class **CWS** using Python language, with the property **words1**; then create a class **SN_CWS**, inheriting from the **CWS** class, and add the property **words2**, as well as a public function **Common_Words** to return all the universal words in **words1** in the form of an array.", "test_list": ["assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"e\",\"o\"])==[\"facebook\",\"google\",\"leetcode\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"l\",\"e\"])==[\"apple\",\"google\",\"leetcode\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"e\",\"oo\"])==[\"facebook\",\"google\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"lo\",\"eo\"])==[\"google\",\"leetcode\"]", "assert candidate([\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"],[\"ec\",\"oc\",\"ceo\"])==[\"facebook\",\"leetcode\"]"], "test_function": "def test_run(content1,content2):\n    return SN_CWS(content1,content2).Common_Words()", "entry_point": "test_run", "test_matching": "assert candidate([['class CWS', 'class SN_CWS(CWS)', 'super().__init__(words1)', 'def Common_Words']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/317", "question": "Question: Given a circular integer array **nums** of length **n**, return the maximum possible sum of non-empty subarrays in **nums**. \nPlease create a class **CAY** in Python based on the above question, with the attribute **nums**. Then create another class **SN_CAY**, inheriting from the **CAY** class, and add a public function **Circular_array** to return the maximum possible sum of non-empty subarrays in the circular integer array **nums** of length **n**.", "test_list": ["assert candidate([1,-2,3,-2])==3", "assert candidate([5,-3,5])==10", "assert candidate([3,-2,2,-3])==3"], "test_function": "def test_run(content1):\n    return SN_CAY(content1).Circular_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class CAY', 'class SN_CAY(CAY)', 'super().__init__(nums)', 'def Circular_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/318", "question": "Question: You have **n** different songs in your music player. During your journey, you plan to listen to **goal** songs (not necessarily different, i.e., song repetition is allowed). You will create a playlist according to the following rules:\n1. Each song is played at least once. 2. A song can only be played again after other **k** songs have been played. Given **n**, **goal**, and **k**, return the number of playlists that can meet the requirements.\nBased on the above question, please create a class **PAL** in Python with the attribute **n**; then create another class **SN_PAL**, inheriting from the **PAL** class, and add two attributes **goal** and **k**, as well as a public function **PlayList** that returns the number of playlists that can meet the requirements.", "test_list": ["assert candidate(3,3,1)==6", "assert candidate(2,3,0)==6", "assert candidate(2,3,1)==2"], "test_function": "def test_run(content1,content2,content3):\n    return SN_PAL(content1,content2,content3).PlayList()", "entry_point": "test_run", "test_matching": "assert candidate([['class PAL', 'class SN_PAL(PAL)', 'super().__init__(n)', 'def PlayList']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/319", "question": "Question: A parenthesis string is valid only if one of the following conditions is met:\n1. It is an empty string; 2. It can be written as AB (A connected with B), where both A and B are valid strings; 3. It can be written as (A), where A is a valid string. Given a parenthesis string **s**, in each operation, you can insert a parenthesis at any position in the string to make the result string **s** valid. The task is to return the minimum number of parentheses that must be added to make the string **s** valid.\nBased on the above question, please create a class **MPS** in Python, which has an attribute **s**. Then create another class **SN_MPS**, which inherits from the **MPS** class, and add a public function **Minimum_parentheses** that returns the minimum number of parentheses that must be added to make the result string **s** valid.", "test_list": ["assert candidate(\"())\")==1", "assert candidate(\"(((\")==3"], "test_function": "def test_run(content1):\n    return SN_MPS(content1).Minimum_parentheses()", "entry_point": "test_run", "test_matching": "assert candidate([['class MPS', 'class SN_MPS(MPS)', 'super().__init__(s)', 'def Minimum_parentheses']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/320", "question": "Question: Given a non-negative integer array **nums**, half of the integers in **nums** are odd, and half are even. Sort the array so that when nums[i] is odd, **i** is also odd; when nums[i] is even, **i** is also even. You can return any array that meets the above conditions as the answer;\nBased on the above question, please use Python to create a class **ASG** with the attribute **nums**; then create a class **SN_ASG** that inherits from the **ASG** class, and add a public function **Array_sorting** that returns an array that meets the conditions as the answer.", "test_list": ["assert candidate([4,2,5,7])==[4,5,2,7]", "assert candidate([2,3])==[2,3]"], "test_function": "def test_run(content1):\n    return SN_ASG(content1).Array_sorting()", "entry_point": "test_run", "test_matching": "assert candidate([['class ASG', 'class SN_ASG(ASG)', 'super().__init__(nums)', 'def Array_sorting']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/321", "question": "Question: Given an integer array **arr**, and an integer **target** as the target value, return the number of tuples **i**, **j**, **k** that satisfy i<j<k and arr[i]+arr[j]+arr[k]==target;\nPlease create a class **NTS** in Python language based on the above question, with **arr** as an attribute; then create another class **SN_NTS**, inheriting from the **NTS** class, and add the attribute **target**, as well as a public function **Number_tuples** to return the number of tuples **i**, **j**, **k** that satisfy i<j<k and arr[i]+arr[j]+arr[k]==target.", "test_list": ["assert candidate([1,1,2,2,3,3,4,4,5,5],8)==20", "assert candidate([1,1,2,2,2,2],5)==12"], "test_function": "def test_run(content1,content2):\n    return SN_NTS(content1,content2).Number_tuples()", "entry_point": "test_run", "test_matching": "assert candidate([['class NTS', 'class SN_NTS(NTS)', 'super().__init__(arr)', 'def Number_tuples']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/322", "question": "Question: Given a binary string **s**, you can flip any 0 to 1 or flip 1 to 0. Return the minimum number of flips to make **s** monotonically increasing;\nPlease create a class **FTM** in Python based on the above question, with the attribute **s**. Then create another class **SN_FTM** that inherits from the **FTM** class, and add a public function **Flip_Times** to return the minimum number of flips to make the binary string **s** monotonically increasing.", "test_list": ["assert candidate(\"00110\")==1", "assert candidate(\"010110\")==2", "assert candidate(\"00011000\")==2"], "test_function": "def test_run(content1):\n    return SN_FTM(content1).Flip_Times()", "entry_point": "test_run", "test_matching": "assert candidate([['class FTM', 'class SN_FTM(FTM)', 'super().__init__(s)', 'def Flip_Times']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/323", "question": "Question: Given an array **arr** composed of 0s and 1s, divide the array into three non-empty parts so that all these parts represent the same binary value. If it can be done, please return any [i, j], where i+1<j, so that:\n1. arr[0], arr[1], ..., arr[i] is the first part; 2. arr[i+1], arr[i+2], ..., arr[j-1] is the second part; 3. arr[j], arr[j+1], ..., arr[arr.length-1] is the third part. These three parts represent the same binary value. If it cannot be done, return [-1, -1];\nBased on the above question, please create a class **BVE** in Python with the attribute **arr**; then create a class **SN_BVE** that inherits the **BVE** class, and add a public function **Binary_values** that returns any [i, j], or [-1, -1] if not possible.", "test_list": ["assert candidate([1,0,1,0,1])==[0,3]", "assert candidate([1,1,0,1,1])==[-1,-1]", "assert candidate([1,1,0,0,1])==[0,2]"], "test_function": "def test_run(content1):\n    return SN_BVE(content1).Binary_values()", "entry_point": "test_run", "test_matching": "assert candidate([['class BVE', 'class SN_BVE(BVE)', 'super().__init__(arr)', 'def Binary_values']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/324", "question": "Question: Given a binary array **nums** and an integer **goal**, please count and return how many non-empty subarrays have a sum equal to **goal**. \nPlease create a class **NSY** in Python based on the above question, with the attribute **nums**. Then create another class **SN_NSY**, inheriting from the **NSY** class, and add the attribute **goal**, as well as a public function **Non_subarray** to count and return how many non-empty subarrays have a sum equal to the integer **goal**.", "test_list": ["assert candidate([1,0,1,0,1],2)==4", "assert candidate([0,0,0,0,0],0)==15"], "test_function": "def test_run(content1,content2):\n    return SN_NSY(content1,content2).Non_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class NSY', 'class SN_NSY(NSY)', 'super().__init__(nums)', 'def Non_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/325", "question": "Question: Given a square integer array **matrix** of size n x n, find and return the minimum sum of a descending path through the **matrix**;\nBased on the above question, create a class **DPH** in Python with the attribute **matrix**. Then create another class **SN_DPH** that inherits from the **DPH** class, and add a public function **descent_path** to return the minimum sum of a descending path through the integer array **matrix**.", "test_list": ["assert candidate([[2,1,3],[6,5,4],[7,8,9]])==13", "assert candidate([[-19,57],[-40,-5]])==-59"], "test_function": "def test_run(content1):\n    return SN_DPH(content1).descent_path()", "entry_point": "test_run", "test_matching": "assert candidate([['class DPH', 'class SN_DPH(DPH)', 'super().__init__(matrix)', 'def descent_path']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/326", "question": "Question: An array **nums** of length **n** is considered a beautiful array if it meets the following conditions:\n1. **nums** is a permutation of the integers in the range [1, n]. \n2. For every 0 <= i < j < n, there is no index **k** (i < k < j) such that 2*nums[k] == nums[i] + nums[j]. \nGiven an integer **n**, return a beautiful array of length **n**.\nBased on the above question, create a class **BAR** in Python with an attribute **n**. Then create another class **SN_BAR** that inherits from the **BAR** class, and add a public function **Beautiful_array** that returns a beautiful array of length **n**.", "test_list": ["assert candidate(4)==[2,1,4,3]", "assert candidate(5)==[3,1,2,5,4]"], "test_function": "def test_run(content1):\n    return SN_BAR(content1).Beautiful_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class BAR', 'class SN_BAR(BAR)', 'super().__init__(n)', 'def Beautiful_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/327", "question": "Question: Given a binary matrix **grid** of size n x n, where 1 represents land and 0 represents water. An island is a maximum group formed by 1s connected on all four sides, i.e., it will not be connected to any other 1s not in the group. There are exactly two islands in the grid. You can turn any number of 0s into 1s to connect the two islands into one. Return the minimum number of 0s that must be flipped.\nBased on the above question, create a class **FNE** in Python, which has the attribute **grid**. Then create another class **SN_FNE** that inherits from the **FNE** class, and add a public function **Flip_Number** that returns the minimum number of 0s that must be flipped.", "test_list": ["assert candidate([[0,1],[1,0]])==1", "assert candidate([[0,1,0],[0,0,0],[0,0,1]])==2", "assert candidate([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]])==1"], "test_function": "def test_run(content1):\n    return SN_FNE(content1).Flip_Number()", "entry_point": "test_run", "test_matching": "assert candidate([['class FNE', 'class SN_FNE(FNE)', 'super().__init__(grid)', 'def Flip_Number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/328", "question": "Question: Given a log array **logs**. Each log is a string separated by spaces, with the first word being an identifier mixed with letters and numbers. There are two different types of logs:\n1. Letter logs: Apart from the identifier, all words are composed of lowercase letters; 2. Number logs: Apart from the identifier, all words are composed of numbers; Please re-sort the logs according to the following rules:\n1. All letter logs are ranked before number logs. 2. When the content of the letter logs is different, ignore the identifier and sort according to the alphabetical order of the content; when the content is the same, sort by the identifier. 3. The number logs should retain their original relative order. Return the final order of the logs;\nBased on the above question, please create a class **FOR** in Python language with the property **logs**; then create a class **SN_FOR** that inherits the **FOR** class, and add a public function **Final_order** to return the final order of the logs.", "test_list": ["assert candidate([\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"])==[\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]", "assert candidate([\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"])==[\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]"], "test_function": "def test_run(content1):\n    return SN_FOR(content1).Final_order()", "entry_point": "test_run", "test_matching": "assert candidate([['class FOR', 'class SN_FOR(FOR)', 'super().__init__(logs)', 'def Final_order']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/329", "question": "Question: Given a set of points **drop** on the xy-plane, determine the minimum area of the rectangle formed by these points, where the sides of the rectangle are parallel to the x-axis and y-axis. If no rectangle can be formed, return 0;\nBased on the above question, please create a class **MAR** in Python language with the property **drop**; then create a class **SN_MAR** that inherits from the **MAR** class, and add a public function **Minimum_Area** that returns the minimum area of the rectangle formed. If no rectangle can be formed, return 0.", "test_list": ["assert candidate([[1,1],[1,3],[3,1],[3,3],[2,2]])==4", "assert candidate([[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]])==2"], "test_function": "def test_run(content1):\n    return SN_MAR(content1).Minimum_Area()", "entry_point": "test_run", "test_matching": "assert candidate([['class MAR', 'class SN_MAR(MAR)', 'super().__init__(drop)', 'def Minimum_Area']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/330", "question": "Question: Given a string **s**, calculate the number of different non-empty sub-sequences of **s**;\nBased on the above question, please create a class **ESU** in Python language with the attribute **s**. Then create another class **SN_ESU** that inherits from the **ESU** class, and add a public function **empty_subsequence** to return the number of different non-empty sub-sequences of the string **s**.", "test_list": ["assert candidate(\"abc\")==7", "assert candidate(\"aba\")==6", "assert candidate(\"aaa\")==3"], "test_function": "def test_run(content1):\n    return SN_ESU(content1).empty_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class ESU', 'class SN_ESU(ESU)', 'super().__init__(s)', 'def empty_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/331", "question": "Question: Given an integer array **nums**. Each **move** operation will choose any index **i** that satisfies 0<=i<nums.length, and increase **nums[i]** by 1. Return the minimum number of operations required to make each value in **nums** unique;\nPlease create a class **MOT** with the attribute **nums** in Python based on the above question. Then create a class **SN_MOT** that inherits from the **MOT** class, and add a public function **Minimum_operations** to return the minimum number of operations required to make each value in the integer array **nums** unique.", "test_list": ["assert candidate([1,2,2])==1", "assert candidate([3,2,1,2,1,7])==6"], "test_function": "def test_run(content1):\n    return SN_MOT(content1).Minimum_operations()", "entry_point": "test_run", "test_matching": "assert candidate([['class MOT', 'class SN_MOT(MOT)', 'super().__init__(nums)', 'def Minimum_operations']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/332", "question": "Question: Given two sequences **pushed** and **popped**, each with unique values, return True if they could be the result of a sequence of **push** and **pop** operations on an initially empty stack; otherwise, return False. \nBased on the above question, create a class **ISK** in Python language with the attribute **pushed**; then create another class **SN_ISK** that inherits from the **ISK** class, and add the attribute **popped**, as well as a public function **Initial_stack** that returns the corresponding result.", "test_list": ["assert candidate([1,2,3,4,5],[4,5,3,2,1])==True", "assert candidate([1,2,3,4,5],[4,3,5,1,2])==False"], "test_function": "def test_run(content1,content2):\n    return SN_ISK(content1,content2).Initial_stack()", "entry_point": "test_run", "test_matching": "assert candidate([['class ISK', 'class SN_ISK(ISK)', 'super().__init__(pushed)', 'def Initial_stack']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/333", "question": "Question: There are **n** stones placed on some integer coordinates in a two-dimensional plane. Each coordinate can have at most one stone. If a stone has other stones on the same row or column, it can be removed. Given an array of length **n**, **stones**, where stones[i] = [x_i, y_i] represents the position of the i-th stone, return the maximum number of stones that can be removed;\nPlease create a class **RSN** in Python based on the above problem, with the attribute **stones**. Then create a class **SN_RSN** that inherits the **RSN** class, and add a public function **Removed_stones** to return the maximum number of stones that can be removed.", "test_list": ["assert candidate([[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]])==5", "assert candidate([[0,0],[0,2],[1,1],[2,0],[2,2]])==3", "assert candidate([[0,0]])==0"], "test_function": "def test_run(content1):\n    return SN_RSN(content1).Removed_stones()", "entry_point": "test_run", "test_matching": "assert candidate([['class RSN', 'class SN_RSN(RSN)', 'super().__init__(stones)', 'def Removed_stones']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/334", "question": "Question: Your initial energy is **power**, and your initial score is 0. You only have one pack of **tokens**. Where tokens[i] is the value of the i-th token (index starts from 0). There are two possible ways to use the tokens as follows:\n1. If you have at least token[i] points of energy, you can flip the i-th token face up, lose token[i] points of energy, and gain 1 point. 2. If we have at least 1 point, we can flip the i-th token face down, gain token[i] points of energy, and lose 1 point. Each token can only be used once, the order of use is not limited, and it is not necessary to use all tokens. After using any number of tokens, return the maximum score we can get;\nPlease create a class **INY** in Python based on the above question, with the attribute **tokens**; then create a class **SN_INY** that inherits the **INY** class, and add the attribute **power**, as well as a public function **Initial_energy** that returns the maximum score that can be obtained.", "test_list": ["assert candidate([100],50)==0", "assert candidate([100,200],150)==1", "assert candidate([100,200,300,400],200)==2"], "test_function": "def test_run(content1,content2):\n    return SN_INY(content1,content2).Initial_energy()", "entry_point": "test_run", "test_matching": "assert candidate([['class INY', 'class SN_INY(INY)', 'super().__init__(tokens)', 'def Initial_energy']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/335", "question": "Question: Given an array composed of 4 digits, return the maximum time that can be set in accordance with the 24-hour system. The 24-hour format is **HH:MM**, where HH is between 00 and 23, and MM is between 00 and 59. The smallest 24-hour system time is 00:00, and the largest is 23:59. Starting from 00:00 (midnight), the longer it passes, the greater the time. Return the answer in the format of **HH:MM** with a string length of 5. If the valid time cannot be determined, return an empty string;\nBased on the above question, please create a class named **ETM** in Python, which has an attribute **arr**; then create a class **SN_ETM** that inherits from the **ETM** class, and add a public function **effective_time** that returns the maximum time that can be set in accordance with the 24-hour system. If the valid time cannot be determined, return an empty string.", "test_list": ["assert candidate([1,2,3,4])==\"23:41\"", "assert candidate([5,5,5,5])==\"\"", "assert candidate([0,0,0,0])==\"00:00\"", "assert candidate([0,0,1,0])==\"10:00\""], "test_function": "def test_run(content1):\n    return SN_ETM(content1).effective_time()", "entry_point": "test_run", "test_matching": "assert candidate([['class ETM', 'class SN_ETM(ETM)', 'super().__init__(arr)', 'def effective_time']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/336", "question": "Question: Given a non-empty array **nums** composed of different positive integers, consider the following graph:\n1. There are nums.length nodes, marked from nums[0] to nums[nums.length-1]; 2. There is an edge between nums[i] and nums[j] only when nums[i] and nums[j] share a common factor greater than 1. Return the size of the largest connected component in the graph;\nBased on the above question, please create a class **CCN** in Python language with the attribute **nums**; then create a class **SN_CCN** that inherits from the **CCN** class, and add a public function **Connected_components** to return the size of the largest connected component in the graph.", "test_list": ["assert candidate([4,6,15,35])==4", "assert candidate([20,50,9,63])==2", "assert candidate([2,3,6,7,4,12,21,39])==8"], "test_function": "def test_run(content1):\n    return SN_CCN(content1).Connected_components()", "entry_point": "test_run", "test_matching": "assert candidate([['class CCN', 'class SN_CCN(CCN)', 'super().__init__(nums)', 'def Connected_components']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/337", "question": "Question: Given an integer array **arr** of even length, return True if **arr** can be rearranged to satisfy for each 0<=i<len(arr)/2, arr[2*i+1]=2*arr[2*i]; otherwise, return False. \nPlease create a class **RSF** with the attribute **arr** in Python based on the above question. Then create another class **SN_RSF** that inherits from the **RSF** class, and add a public function **Reorganization_satisfaction** that returns the corresponding result.", "test_list": ["assert candidate([3,1,3,6])==False", "assert candidate([2,1,2,6])==False", "assert candidate([4,-2,2,-4])==True"], "test_function": "def test_run(content1):\n    return SN_RSF(content1).Reorganization_satisfaction()", "entry_point": "test_run", "test_matching": "assert candidate([['class RSF', 'class SN_RSF(RSF)', 'super().__init__(arr)', 'def Reorganization_satisfaction']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/338", "question": "Question: Given an array **strs** composed of **n** strings, where each string is of equal length. Select a deletion index sequence, for each string in **strs**, delete the character at each corresponding index. Suppose, we have chosen a set of deletion indices **answer**, then after performing the deletion operation, the elements of the final array are arranged in lexicographical order (strs[0]<=strs[1]<=strs[2]...<=strs[n-1]), then please return the smallest possible value of answer.length;\nBased on the above question, please create a class **MPL** in Python language with the attribute **strs**; then create a class **SN_MPL** that inherits the **MPL** class, and add a public function **Minimum_possible** to return the smallest possible value of answer.length.", "test_list": ["assert candidate([\"ca\",\"bb\",\"ac\"])==1", "assert candidate([\"xc\",\"yb\",\"za\"])==0", "assert candidate([\"zyx\",\"wvu\",\"tsr\"])==3"], "test_function": "def test_run(content1):\n    return SN_MPL(content1).Minimum_possible()", "entry_point": "test_run", "test_matching": "assert candidate([['class MPL', 'class SN_MPL(MPL)', 'super().__init__(strs)', 'def Minimum_possible']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/339", "question": "Question: You are installing a billboard and want it to be as high as possible. This billboard will have two steel brackets, one on each side. The height of each steel bracket must be equal. You have a pile of **rods** that can be welded together. For example, if the lengths of the rods are 1, 2, and 3, they can be welded together to form a bracket of length 6. Return the maximum possible installation height of the billboard. If the billboard cannot be installed, please return 0;\nPlease create a class called **IBD** in Python based on the above problem, with the attribute **rods**; then create a class **SN_IBD** that inherits from the **IBD** class, and add a public function **Install_billboards** that returns the maximum possible installation height of the billboard. If the billboard cannot be installed, please return 0.", "test_list": ["assert candidate([1,2,3,6])==6", "assert candidate([1,2,3,4,5,6])==10", "assert candidate([1,2])==0"], "test_function": "def test_run(content1):\n    return SN_IBD(content1).Install_billboards()", "entry_point": "test_run", "test_matching": "assert candidate([['class IBD', 'class SN_IBD(IBD)', 'super().__init__(rods)', 'def Install_billboards']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/340", "question": "Question: In an nxn grid composed of 1x1 squares, each 1x1 square is made up of '/', '\\' or a space. These characters divide the square into some regions with common edges. Given the grid represented as an array of strings, return the number of regions;\nPlease create a class **NAS** in Python based on the above question, with the attribute **grid**; then create a class **SN_NAS** that inherits from the **NAS** class, and add a public function **Number_areas** that returns the number of regions.", "test_list": ["assert candidate([\" /\",\"/ \"])==2", "assert candidate([\" /\",\"  \"])==1", "assert candidate([\"/\\\",\"\\/\"])==5"], "test_function": "def test_run(content1):\n    return SN_NAS(content1).Number_areas()", "entry_point": "test_run", "test_matching": "assert candidate([['class NAS', 'class SN_NAS(NAS)', 'super().__init__(grid)', 'def Number_areas']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/341", "question": "Question: Given an array of **strs** composed of **n** lowercase letter strings, where each string is of equal length. Select a deletion index sequence, and for each string in **strs**, delete the character at each corresponding index. For example, if strs = [\"abcdef\", \"uvwxyz\"], and the deletion index sequence is {0,2,3}, the result after deletion would be [\"bef\", \"vyz\"]. Suppose we have chosen a set of deletion indices **answer**, then after performing the deletion operation, each element in the row of the final array is sorted in dictionary order (i.e., (strs[0][0]<=strs[0][1]<=...<=strs[0][strs[0].length-1]) and (strs[1][0]<=strs[1][1]<=...<=strs[1][strs[1].length-1]), and so on). Please return the smallest possible value of answer.length;\nBased on the above question, please create a class **MSI** in Python language with the property **strs**; then create a class **SN_MSI** that inherits from the **MSI** class, and add a public function **Minimum_spossible** that returns the smallest possible value of answer.length.", "test_list": ["assert candidate([\"babca\",\"bbazb\"])==3", "assert candidate([\"edcba\"])==4", "assert candidate([\"ghi\",\"def\",\"abc\"])==0"], "test_function": "def test_run(content1):\n    return SN_MSI(content1).Minimum_spossible()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSI', 'class SN_MSI(MSI)', 'super().__init__(strs)', 'def Minimum_spossible']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/342", "question": "Question: Given an integer array **A**, a slope is a tuple (i, j), where i < j and A[i] <= A[j]. The width of such a slope is j-i. Find the maximum width of the slope in **A**, if it does not exist, return 0.\nPlease create a class **WSP** in Python language based on the above question, with the attribute **A**. Then create another class **SN_WSP**, inheriting from the **WSP** class, and add a public function **Width_slope** to find the maximum width of the slope in **A**, if it does not exist, return 0.", "test_list": ["assert candidate([6,0,8,2,1,5])==4", "assert candidate([9,8,1,0,1,9,4,0,4,1])==7"], "test_function": "def test_run(content1):\n    return SN_WSP(content1).Width_slope()", "entry_point": "test_run", "test_matching": "assert candidate([['class WSP', 'class SN_WSP(WSP)', 'super().__init__(A)', 'def Width_slope']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/343", "question": "Question: Given a set of points **drop** on the **xy** plane, determine the minimum area of any rectangle formed by these points, where the sides of the rectangle are not necessarily parallel to the x-axis and y-axis. If there are no rectangles, return 0;\nBased on the above question, please create a class **ARE** in Python language with the property **drop**; then create a class **SN_ARE** that inherits from the **ARE** class, and add a public function **Any_rectangle** to return the minimum area of any rectangle formed. If there are no rectangles, return 0.", "test_list": ["assert candidate([[1,2],[2,1],[1,0],[0,1]])==2.00000", "assert candidate([[0,1],[2,1],[1,1],[1,0],[2,0]])==1.00000", "assert candidate([[0,3],[1,2],[3,1],[1,3],[2,1]])==0", "assert candidate([[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]])==2.00000"], "test_function": "def test_run(content1):\n    return SN_ARE(content1).Any_rectangle()", "entry_point": "test_run", "test_matching": "assert candidate([['class ARE', 'class SN_ARE(ARE)', 'super().__init__(drop)', 'def Any_rectangle']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/344", "question": "Question: Given a positive integer **x**, we will write an expression of the form x(op1)x(op2)x(op3)x..., where each operator op1, op2, ... can be one of addition, subtraction, multiplication, or division (+, -, *, or /). For example, for x=3, we can write the expression 3*3/3+3-3, which equals 3. When writing such expressions, we need to follow these conventions:\n1. The division operator (/) returns a rational number; 2. There are no parentheses anywhere; 3. We use the usual order of operations: multiplication and division occur before addition and subtraction; 4. The unary negation operator (-) is not allowed. For example, **x-x** is a valid expression because it only uses subtraction, but **-x+x** is not because it uses the negation operator. We want to write an expression that equals a given **target** value and uses the fewest operators. Return the minimum number of operators used.\nBased on the above question, please create a class **MNOOT** in Python with the attribute **x**; then create a class **SN_MNOOT** that inherits from the **MNOOT** class, and add a target attribute and a public function **minimum_operators** that returns the minimum number of operators used.", "test_list": ["assert candidate(3,19)==5", "assert candidate(5,501)==8", "assert candidate(100,100000000)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MNOOT(content1,content2).minimum_operators==5()", "entry_point": "test_run", "test_matching": "assert candidate([['class MNOOT', 'class SN_MNOOT(MNOOT)', 'super().__init__(x)', 'def minimum_operators']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/345", "question": "Question: Return all non-negative integers of length **n** such that the absolute difference between the digits in every two consecutive positions is **k**;\nPlease create a class **NIG** in Python language based on the above question, with the attribute **n**. Then create a class **SN_NIG** that inherits from the **NIG** class, and add the attribute **k**, as well as a public function **nonnegative_integer** to return the result of the above question.", "test_list": ["assert candidate(3,7)==[181,292,707,818,929]", "assert candidate(2,1)==[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]", "assert candidate(2,0)==[11,22,33,44,55,66,77,88,99]", "assert candidate(2,2)==[13,20,24,31,35,42,46,53,57,64,68,75,79,86,97]"], "test_function": "def test_run(content1,content2):\n    return SN_NIG(content1,content2).nonnegative_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class NIG', 'class SN_NIG(NIG)', 'super().__init__(n)', 'def nonnegative_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/346", "question": "Question: Given an integer array **arr**, please sort the array using pancake flipping. The execution process of a pancake flip is as follows:\n1. Choose an integer **k**, where 1<=k<=arr.length; 2. Reverse the sub-array arr[0...k-1] (index starts from 0); Return the sequence of **k** values corresponding to the pancake flipping operations that can sort **arr** in the form of an array. Any valid answer that sorts the array and the number of flips is within the range of 10*arr.length will be judged as correct;\nBased on the above question, please create a class **PFG** in Python language with the property **arr**; then create a class **SN_PFG** that inherits the **PFG** class, and add a public function **Pancake_flipping** to return the sequence of **k** values corresponding to the pancake flipping operations that can sort the integer array **arr** in the form of an array.", "test_list": ["assert candidate([3,2,4,1])==[4,2,4,3]", "assert candidate([1,2,3])==[]"], "test_function": "def test_run(content1):\n    return SN_PFG(content1).Pancake_flipping()", "entry_point": "test_run", "test_matching": "assert candidate([['class PFG', 'class SN_PFG(PFG)', 'super().__init__(arr)', 'def Pancake_flipping']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/347", "question": "Question: Given three integers **x**, **y**, and **bound**, return a list of all powerful integers that are less than or equal to **bound**;\nBased on the above question, please create a class **SIG** in Python with the attribute **x**; then create a class **SN_SIG** that inherits from the **SIG** class, and add two attributes **y** and **bound**, as well as a public function **Strong_integer** to return a list of all powerful integers that are less than or equal to **bound**.", "test_list": ["assert candidate(2,3,10)==[2,3,4,5,7,9,10]", "assert candidate(3,5,15)==[2,4,6,8,10,14]"], "test_function": "def test_run(content1,content2,content3):\n    return SN_SIG(content1,content2,content3).Strong_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class SIG', 'class SN_SIG(SIG)', 'super().__init__(x)', 'def Strong_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/348", "question": "Question: Given two strings **s** and **t**, each string represents a non-negative rational number, return True only when they represent the same number;\nBased on the above question, please create a class **SNR** in Python with the attribute **s**; then create another class **SN_SNR** inheriting from the **SNR** class, adding the attribute **t**, as well as a public function **Same_number** to return the result of the above question.", "test_list": ["assert candidate(\"0.(52)\",\"0.5(25)\")==True", "assert candidate(\"0.1666(6)\",\"0.166(66)\")==True", "assert candidate(\"0.9(9)\",\"1.\")==True"], "test_function": "def test_run(content1,content2):\n    return SN_SNR(content1,content2).()", "entry_point": "test_run", "test_matching": "assert candidate([['class SNR', 'class SN_SNR(SNR)', 'super().__init__(s)', 'def Same_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/349", "question": "Question: Given an array **points**, where points[i] = [x_i, y_i] represents a point on the X-Y plane, and an integer **k**, return the **k** points closest to the origin (0,0);\nBased on the above question, create a class **NOG** in Python, with the attribute **points**; then create a class **SN_NOG** that inherits from the **NOG** class, and add the attribute **k**, as well as a public function **Nearest_origin** to return the **k** points closest to the origin (0,0).", "test_list": ["assert candidate([[1,3],[-2,2]],1)==[[-2,2]]", "assert candidate([[3,3],[5,-1],[-2,4]],2)==[[3,3],[-2,4]]"], "test_function": "def test_run(content1,content2):\n    return SN_NOG(content1,content2).Nearest_origin()", "entry_point": "test_run", "test_matching": "assert candidate([['class NOG', 'class SN_NOG(NOG)', 'super().__init__(points)', 'def Nearest_origin']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/350", "question": "Question: Given an integer array **nums** and an integer **k**, return the number of (continuous, non-empty) sub-arrays whose sum of elements can be divided by **k**. \nPlease create a class **SET** in Python language based on the above question, which has the attribute **nums**. Then create another class **SN_SET**, inheriting from the **SET** class, and add the attribute **k**, as well as a public function **Sum_Elements** to return the number of (continuous, non-empty) sub-arrays in the integer array **nums** whose sum of elements can be divided by **k**.", "test_list": ["assert candidate([4,5,0,-2,-3,1],5)==7", "assert candidate([5],9)==0"], "test_function": "def test_run(content1,content2):\n    return SN_SET(content1,content2).Sum_Elements()", "entry_point": "test_run", "test_matching": "assert candidate([['class SET', 'class SN_SET(SET)', 'super().__init__(nums)', 'def Sum_Elements']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/351", "question": "Question: Given an integer array **A**, you can start from a certain index and make a certain number of jumps. During your jumping process, the 1-th, 3-th, 5-th... jumps are called odd jumps, while the 2-th, 4-th, 6-th... jumps are called even jumps. You can jump from index **i** to index **j** (where **i < j**) in the following ways:\n1. During an odd jump (e.g., the 1-th, 3-th, 5-th... jumps), you will jump to index **j** such that A[i] <= A[j], and A[j] is the smallest possible value. If there are multiple such indexes **j**, you can only jump to the smallest index **j** that meets the requirement.\n2. During an even jump (e.g., the 2-th, 4-th, 6-th... jumps), you will jump to index **j** such that A[i] >= A[j], and A[j] is the largest possible value. If there are multiple such indexes **j**, you can only jump to the smallest index **j** that meets the requirement. (For some indexes **i**, it may not be possible to make a jump that meets the requirement.)\n3. If you can reach the end of the array (index A.length-1) by making a certain number of jumps (possibly 0 or more) starting from a certain index, then that index is considered a good starting index. Return the number of good starting indexes.\nPlease create a class **SID** in Python language based on the above question, with the attribute **A**. Then create another class **SN_SID** that inherits the **SID** class, and add a public function **start_index** that returns the number of good starting indexes.", "test_list": ["assert candidate([10,13,12,14,15])==2", "assert candidate([2,3,1,1,4])==3", "assert candidate([5,1,3,4,2])==3"], "test_function": "def test_run(content1):\n    return SN_SID(content1).start_index()", "entry_point": "test_run", "test_matching": "assert candidate([['class SID', 'class SN_SID(SID)', 'super().__init__(A)', 'def start_index']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/352", "question": "Question: Given an integer array **arr**, return the length of the maximum **turbulence subarray** in **arr**. A subarray is a **turbulence subarray** if the comparison sign flips between each pair of adjacent elements in the subarray;\nBased on the above question, create a class **MTL** in Python, which has the attribute **arr**; then create another class **SN_MTL** that inherits from the **MTL** class, and add a public function **Maximum_turbulence** that returns the length of the maximum **turbulence subarray** in **arr**.", "test_list": ["assert candidate([9,4,2,10,7,8,8,1,9])==5", "assert candidate([4,8,12,16])==2", "assert candidate([100])==1"], "test_function": "def test_run(content1):\n    return SN_MTL(content1).Maximum_turbulence()", "entry_point": "test_run", "test_matching": "assert candidate([['class MTL', 'class SN_MTL(MTL)', 'super().__init__(arr)', 'def Maximum_turbulence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/353", "question": "Question: On a two-dimensional grid **grid**, there are 4 types of squares:\n**1** represents the starting square, and there is only one starting square; **2** represents the ending square, and there is only one ending square; **0** represents the empty square that we can walk through; **-1** represents the obstacle that we cannot cross. Return the number of different paths from the starting square to the ending square when walking in four directions (up, down, left, and right);\nBased on the above question, please create a class **DPS** using Python language, with the attribute **grid**; then create a class **SN_DPS** that inherits the **DPS** class, and add a public function **Different_paths** to return the result of the above question.", "test_list": ["assert candidate([[1,0,0,0],[0,0,0,0],[0,0,2,-1]])==2", "assert candidate([[1,0,0,0],[0,0,0,0],[0,0,0,2]])==4", "assert candidate([[0,1],[2,0]])==0"], "test_function": "def test_run(content1):\n    return SN_DPS(content1).Different_paths()", "entry_point": "test_run", "test_matching": "assert candidate([['class DPS', 'class SN_DPS(DPS)', 'super().__init__(grid)', 'def Different_paths']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/354", "question": "Question: Given an integer array **nums**, return the number of bitwise AND triplets. A bitwise AND triplet is a triplet made up of indices (i, j, k) that satisfy all of the following conditions:\n1. 0<=i<nums.length; 2. 0<=j<nums.length; 3. 0<=k<nums.length; 4. nums[i]&nums[j]&nums[k]==0, where & represents the bitwise AND operator;\nBased on the above question, create a class **BTT** using Python language, with the attribute **nums**; then create a class **SN_BTT** that inherits from the **BTT** class, and add a public function **Bitwise_triplet** that returns the number of bitwise AND triplets.", "test_list": ["assert candidate([2,1,3])==12", "assert candidate([0,0,0])==27"], "test_function": "def test_run(content1):\n    return SN_BTT(content1).Bitwise_triplet()", "entry_point": "test_run", "test_matching": "assert candidate([['class BTT', 'class SN_BTT(BTT)', 'super().__init__(nums)', 'def Bitwise_triplet']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/355", "question": "Question: Given two integers a and b, return any string s that satisfies the following conditions:\n1. The length of s is a+b, and it contains exactly a occurrences of the letter 'a' and b occurrences of the letter 'b'.\n2. The substring 'aaa' does not appear in s.\n3. The substring 'bbb' does not appear in s.\nPlease create a class **ASG** in Python that has an attribute **a**. Then create a class **SN_ASG** that inherits from **ASG** and adds an attribute **b**, as well as a public function **Any_string** that returns the result of the above problem.", "test_list": ["assert candidate(1,2)==\"abb\"", "assert candidate(4,1)==\"aabaa\""], "test_function": "def test_run(content1,content2):\n    return SN_ASG(content1,content2).Any_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class ASG', 'class SN_ASG(ASG)', 'super().__init__(a)', 'def Any_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/356", "question": "Question: Given two lists composed of some closed intervals, **firstList** and **secondList**, where firstList[i]=[start_i,end_i] and secondList[j]=[start_j,end_j]. Each interval list is pairwise disjoint and already sorted. Return the intersection of these two interval lists;\nBased on the above question, please create a class **ILT** in Python language with the property **firstList**; then create another class **SN_ILT**, inheriting from the **ILT** class, and add the property **secondList**, as well as a public function **Interval_List** to return the intersection of the above two interval lists.", "test_list": ["assert candidate([[0,2],[5,10],[13,23],[24,25]],[[1,5],[8,12],[15,24],[25,26]])==[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]", "assert candidate([[1,3],[5,9]],[])==[]", "assert candidate([],[[4,8],[10,12]])==[]", "assert candidate([[1,7]],[[3,10]])==[[3,7]]"], "test_function": "def test_run(content1,content2):\n    return SN_ILT(content1,content2).Interval_List()", "entry_point": "test_run", "test_matching": "assert candidate([['class ILT', 'class SN_ILT(ILT)', 'super().__init__(firstList)', 'def Interval_List']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/357", "question": "Question: Given an array composed of string equations that represent the relationships between variables, each string equation equations[i] has a length of 4 and takes one of two different forms: **a==b** or **a!=b**. Here, a and b are lowercase letters (not necessarily different), representing single-letter variable names. Return True only when integers can be assigned to variable names to satisfy all given equations, otherwise return False;\nBased on the above question, please create a class **SVE** in Python language with the attribute **equations**; then create another class **SN_SVE** that inherits from the **SVE** class, and add a public function **Single_variable** that returns the result of the above question.", "test_list": ["assert candidate([\"a==b\",\"b!=a\"])==False", "assert candidate([\"b==a\",\"a==b\"])==True", "assert candidate([\"a==b\",\"b==c\",\"a==c\"])==True", "assert candidate([\"a==b\",\"b!=c\",\"c==a\"])==False", "assert candidate([\"c==c\",\"b==d\",\"x!=z\"])==True"], "test_function": "def test_run(content1):\n    return SN_SVE(content1).Single_variable()", "entry_point": "test_run", "test_matching": "assert candidate([['class SVE', 'class SN_SVE(SVE)', 'super().__init__(equations)', 'def Single_variable']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/358", "question": "Question: On a broken calculator displaying the number **startValue**, we can perform the following two operations:\n1. Double: Multiply the number on the display by 2; 2. Decrement: Subtract 1 from the number on the display. Given two integers, **startValue** and **target**, return the minimum number of operations required to display the number **target**.\nBased on the above question, please create a class **MOS** in Python, with the attribute **startValue**. Then create another class **SN_MOS**, inheriting from the **MOS** class, and add the attribute **target**, as well as a public function **Minimum_operands** that returns the minimum number of operations required to display the number **target**.", "test_list": ["assert candidate(2,3)==2", "assert candidate(5,8)==2", "assert candidate(3,10)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MOS(content1,content2).Minimum_operands()", "entry_point": "test_run", "test_matching": "assert candidate([['class MOS', 'class SN_MOS(MOS)', 'super().__init__(startValue)', 'def Minimum_operands']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/359", "question": "Question: Given a positive integer array **nums** and an integer **k**, return the number of good sub-arrays in nums. If the number of different integers in a sub-array of nums is exactly **k**, then this continuous, not necessarily different sub-array of **nums** is called a good sub-array;\nBased on the above question, create a class **GAR** in Python language with the attribute **nums**; then create a class **SN_GAR**, inheriting from the **GAR** class, and add the attribute **k**, as well as a public function **Good_array** to return the number of good sub-arrays in **nums**.", "test_list": ["assert candidate([1,2,1,2,3],2)==7", "assert candidate([1,2,1,3,4],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_GAR(content1,content2).Good_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class GAR', 'class SN_GAR(GAR)', 'super().__init__(nums)', 'def Good_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/360", "question": "Question: In the given m x n grid **grid**, each cell can have one of the following three values: \n1. Value 0 represents an empty cell.\n2. Value 1 represents a fresh orange.\n3. Value 2 represents a rotten orange. \nEvery minute, a rotten orange will make any fresh orange in the four adjacent directions rot. Return the minimum number of minutes required to make all the oranges rotten. If it is impossible, return -1. \nPlease create a class **MME** in Python based on the above question, with a **grid** attribute. Then create a class **SN_MME** that inherits from the **MME** class and add a public function **Min_Minutes** to return the result of the above question.", "test_list": ["assert candidate([[2,1,1],[1,1,0],[0,1,1]])==4", "assert candidate([[2,1,1],[0,1,1],[1,0,1]])==-1", "assert candidate([[0,2]])==0"], "test_function": "def test_run(content1):\n    return SN_MME(content1).Min_Minutes()", "entry_point": "test_run", "test_matching": "assert candidate([['class MME', 'class SN_MME(MME)', 'super().__init__(grid)', 'def Min_Minutes']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/361", "question": "Question: Given a binary array **nums** and an integer **k**, return the minimum number of k-bit flips required for the array to have no zeros. If it's not possible, return -1. A k-bit flip means choosing a subarray of length **k** from nums, and simultaneously changing every 0 in the subarray to 1, and every 1 in the subarray to 0;\nBased on the above question, create a class **MFI** in Python, which has the attribute **nums**. Then create another class **SN_MFI**, inheriting from the **MFI** class, and add the attribute **K**, as well as a public function **Min_Flip** that returns the result of the above problem.", "test_list": ["assert candidate([0,1,0],1)==2", "assert candidate([1,1,0],2)==-1", "assert candidate([0,0,0,1,0,1,1,0],3)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MFI(content1,content2).Min_Flip()", "entry_point": "test_run", "test_matching": "assert candidate([['class MFI', 'class SN_MFI(MFI)', 'super().__init__(nums)', 'def Min_Flip']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/362", "question": "Question: Given a non-negative integer array **A**, if the sum of every pair of adjacent elements is a perfect square, then this array is called a square array. Return the number of square arrangements of **A**.\nPlease create a **SAT** class based on the above question, with the attribute **A**; then create a **SN_SAT** class, inheriting the **SAT** class, and add a public **Square_arrangement** function to return the number of square arrangements of A.", "test_list": ["assert candidate([1,17,8])==2", "assert candidate([2,2,2])==1"], "test_function": "def test_run(content1):\n    return SN_SAT(content1).Square_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([['class SAT', 'class SN_SAT(SAT)', 'super().__init__(A)', 'def Square_arrangement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/363", "question": "Question: There are **n** piles of stones arranged in a row, with stones[i] stones in the i-th pile. Each move requires merging **k** consecutive piles of stones into one pile, and the cost of this move is the total number of stones in these **k** piles. Return the lowest cost to merge all the stones into one pile. If it is impossible to merge into one pile, return -1;\nBased on the above question, create a class **SMG** using Python language, with the attribute **stones**; then create a class **SN_SMG** that inherits the **SMG** class, and add the attribute **K**, as well as a public function **Stone_Merge** that returns the result of the above question.", "test_list": ["assert candidate([3,2,4,1],2)==20", "assert candidate([3,2,4,1],3)==-1", "assert candidate([3,5,1,2,6],3)==25"], "test_function": "def test_run(content1,content2):\n    return SN_SMG(content1,content2).Stone_Merge()", "entry_point": "test_run", "test_matching": "assert candidate([['class SMG', 'class SN_SMG(SMG)', 'super().__init__(stones)', 'def Stone_Merge']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/364", "question": "Question: In a row of dominoes, tops[i] and bottoms[i] represent the top and bottom halves of the i-th domino respectively. (A domino is formed by two numbers from 1 to 6 arranged in columns - each half of the tile has a number.) We can rotate the i-th domino so that the values of tops[i] and bottoms[i] are swapped. Return the minimum number of rotations that can make all values in **tops** or all values in **bottoms** the same. If it is impossible, return -1;\nBased on the above question, please create a class **DMS** in Python with the attribute **tops**; then create another class **SN_DMS** that inherits from the **DMS** class, and add the attribute **bottoms**, as well as a public function **Dominoes** to return the result of the above question.", "test_list": ["assert candidate([2,1,2,4,2,2],[5,2,6,2,3,2])==2", "assert candidate([3,5,1,2,3],[3,6,3,3,4])==-1"], "test_function": "def test_run(content1,content2):\n    return SN_DMS(content1,content2).Dominoes()", "entry_point": "test_run", "test_matching": "assert candidate([['class DMS', 'class SN_DMS(DMS)', 'super().__init__(tops)', 'def Dominoes']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/365", "question": "Question: In the song list, the duration of the i-th song is time[i] seconds. Return the number of song pairs whose total duration (in seconds) can be divided by 60;\nBased on the above question, please create a class **TDN** in Python, with the attribute **time**; then create another class **SN_TDN**, inheriting from the **TDN** class, and add a public function **Total_duration** to return the number of song pairs whose total duration (in seconds) can be divided by 60.", "test_list": ["assert candidate([30,20,150,100,40])==3", "assert candidate([60,60,60])==3"], "test_function": "def test_run(content1):\n    return SN_TDN(content1).Total_duration()", "entry_point": "test_run", "test_matching": "assert candidate([['class TDN', 'class SN_TDN(TDN)', 'super().__init__(time)', 'def Total_duration']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/366", "question": "Question: The packages on the **conveyor belt** must be transported from one port to another within **days**. The weight of the i-th package on the conveyor belt is weights[i]. Every day, we load packages onto the conveyor belt in the order of the given weights. The weight we load will not exceed the maximum carrying weight of the ship. Return the minimum carrying capacity of the ship that can deliver all the packages on the conveyor belt within **days**;\nBased on the above question, please use Python to create a class **MCG** with the attribute **weights**; then create a class **SN_MCG** that inherits from the **MCG** class, and add the attribute **days**, as well as a public function **Minimum_carrying** to return the minimum carrying capacity of the ship that can deliver all the packages on the conveyor belt within **days**.", "test_list": ["assert candidate([1,2,3,4,5,6,7,8,9,10],5)==15", "assert candidate([3,2,2,4,1,4],3)==6", "assert candidate([1,2,3,1,1],4)==3"], "test_function": "def test_run(content1,content2):\n    return SN_MCG(content1,content2).Minimum_carrying()", "entry_point": "test_run", "test_matching": "assert candidate([['class MCG', 'class SN_MCG(MCG)', 'super().__init__(weights)', 'def Minimum_carrying']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/367", "question": "Question: Given a positive integer **n**, return the number of positive integers within the range [1, n] that have at least one repeating digit;\nBased on the above question, please create a class called **RNS** in Python, with an attribute **n**. Then create another class **SN_RNS** that inherits from the **RNS** class, and add a public function **Repeating_numbers** that returns the result of the above question.", "test_list": ["assert candidate(20)==1", "assert candidate(100)==10", "assert candidate(1000)==262"], "test_function": "def test_run(content1):\n    return SN_RNS(content1).Repeating_numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class RNS', 'class SN_RNS(RNS)', 'super().__init__(n)', 'def Repeating_numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/368", "question": "Question: Given a positive integer array **values**, where values[i] represents the rating of the i-th sightseeing spot, and the distance between two spots i and j is j-i. The score of a sightseeing combination of a pair of spots (i<j) is values[i]+values[j]+i-j, which is the sum of the ratings of the spots minus the distance between them. Return the highest score that a pair of sightseeing spots can achieve;\nBased on the above question, please create a class **SCT** in Python language with the attribute **values**; then create a class **SN_SCT** that inherits the **SCT** class, and add a public function **Sightseeing_combination** that returns the highest score that a pair of sightseeing spots can achieve.", "test_list": ["assert candidate([8,1,5,2,6])==11", "assert candidate([1,2])==2"], "test_function": "def test_run(content1):\n    return SN_SCT(content1).Sightseeing_combination()", "entry_point": "test_run", "test_matching": "assert candidate([['class SCT', 'class SN_SCT(SCT)', 'super().__init__(values)', 'def Sightseeing_combination']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/369", "question": "Question: Given a positive integer **k**, you need to find the length of the smallest positive integer **n** that can be divided by **k** and only contains the digit 1. Return the length of **n**. If there is no such **n**, return -1;\nBased on the above question, please create a class **MIR** in Python with the attribute **k**; then create a class **SN_MIR** that inherits the **MIR** class, and add a public function **Minimum_integer** to return the result of the above question.", "test_list": ["assert candidate(1)==1", "assert candidate(2)==-1", "assert candidate(3)==3"], "test_function": "def test_run(content1):\n    return SN_MIR(content1).Minimum_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class MIR', 'class SN_MIR(MIR)', 'super().__init__(k)', 'def Minimum_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/370", "question": "Question: Given a binary string **s** and a positive integer **n**, return True if the binary representation of every integer in the range [1, n] is a substring of **s**, otherwise return False;\nPlease create a class **ETG** in Python language based on the above question, with the attribute **s**. Then create a class **SN_ETG** that inherits from the **ETG** class, add the attribute **n**, and a public function **Each_integer** that returns the result of the above question.", "test_list": ["assert candidate(\"0110\",3)==True", "assert candidate(\"0110\",4)==False"], "test_function": "def test_run(content1,content2):\n    return SN_ETG(content1,content2).Each_integer()", "entry_point": "test_run", "test_matching": "assert candidate([['class ETG', 'class SN_ETG(ETG)', 'super().__init__(s)', 'def Each_integer']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/371", "question": "Question: Given an integer **n**, return its negative binary (base-2) representation in the form of a binary string;\nBased on the above question, create a class **NGY** in Python language with the attribute **n**; then create a class **SN_NGY** that inherits from the **NGY** class, and add a public function **negabinary** to return the negative binary (base-2) representation of the integer **n** in the form of a binary string.", "test_list": ["assert candidate(2)==\"110\"", "assert candidate(3)==\"111\"", "assert candidate(4)==\"100\""], "test_function": "def test_run(content1):\n    return SN_NGY(content1).negabinary()", "entry_point": "test_run", "test_matching": "assert candidate([['class NGY', 'class SN_NGY(NGY)', 'super().__init__(n)', 'def negabinary']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/372", "question": "Question: Given a linked list of length **n**, **head**. For each node in the list, find the value of the next larger node. That is, for each node, find the value of the first node next to it, the value of this node is strictly greater than its value. Return an integer array **answer**, where answer[i] is the value of the next larger node of the i-th node (starting from 1). If the i-th node does not have a next larger node, set answer[i]=0;\nBased on the above question, please create a class **LNS** in Python, with the attribute **head**; then create a class **SN_LNS** that inherits the **LNS** class, and add a public function **Larger_nodes** to return the result of the above question.", "test_list": ["assert candidate([2,1,5])==[5,5,0]", "assert candidate([2,7,4,3,5])==[7,0,5,5,0]"], "test_function": "def test_run(content1):\n    return SN_LNS(content1).Larger_nodes()", "entry_point": "test_run", "test_matching": "assert candidate([['class LNS', 'class SN_LNS(LNS)', 'super().__init__(head)', 'def Larger_nodes']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/373", "question": "Question: Given a binary matrix grid of size m x n, where 0 represents an ocean cell and 1 represents a land cell. A move is defined as moving from one land cell to another adjacent (up, down, left, right) land cell or crossing the border of the **grid**. Return the number of land cells in the grid that cannot leave the grid border in any number of moves;\nPlease create a class **LCL** in Python based on the above question, with the attribute **grid**. Then create a class **SN_LCL** that inherits from the **LCL** class, and add a public function **Land_Cell** to return the number of land cells in the grid that cannot leave the grid border in any number of moves.", "test_list": ["assert candidate([[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]])==3", "assert candidate([[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]])==0"], "test_function": "def test_run(content1):\n    return SN_LCL(content1).Land_Cell()", "entry_point": "test_run", "test_matching": "assert candidate([['class LCL', 'class SN_LCL(LCL)', 'super().__init__(grid)', 'def Land_Cell']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/374", "question": "Question: Given a string array **queries** and a string representing a **pattern**, return a boolean array **answer**. Only when the query item queries[i] matches the pattern string pattern, answer[i] is True, otherwise it is False;\nBased on the above question, please create a class **BAY** in Python with the property **queries**; then create a class **SN_BAY** that inherits from the **BAY** class, and add the property **pattern**, as well as a public function **boolean_array** that returns the above results.", "test_list": ["assert candidate([\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"],\"FB\")==[True,False,True,True,False]", "assert candidate([\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"],\"FoBa\")==[True,False,True,False,False]", "assert candidate([\"FooBar\",\"FooBarTest\",\"FootBall\",\"FrameBuffer\",\"ForceFeedBack\"],\"FoBaT\")==[False,True,False,False,False]"], "test_function": "def test_run(content1,content2):\n    return SN_BAY(content1,content2).boolean_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class BAY', 'class SN_BAY(BAY)', 'super().__init__(queries)', 'def boolean_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/375", "question": "Question: Given an integer array **nums**, return the length of the longest arithmetic subsequence in **nums**;\nBased on the above question, create a class **LSQ** using Python language, with the attribute **nums**. Then create another class **SN_LSQ**, inheriting from the **LSQ** class, and add a public function **Longest_subsequence** to return the length of the longest arithmetic subsequence in the integer array **nums**.", "test_list": ["assert candidate([3,6,9,12])==4", "assert candidate([9,4,7,2,10])==3", "assert candidate([20,1,15,3,10,5,8])==4"], "test_function": "def test_run(content1):\n    return SN_LSQ(content1).Longest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class LSQ', 'class SN_LSQ(LSQ)', 'super().__init__(nums)', 'def Longest_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/376", "question": "Question: The company plans to interview 2n people. Given an array **costs**, where costs[i]=[aCosti,bCosti]. The cost for the i-th person to fly to city **a** is **aCost_i**, and the cost to fly to city **b** is **bCost_i**. Return the minimum cost to fly each person to either city **a** or **b**, with the requirement that **n** people must arrive in each city;\nBased on the above question, create a class **MCT** in Python language with the attribute **costs**; then create a class **SN_MCT** that inherits from the **MCT** class, and add a public function **Minimum_cost** to return the result of the above question.", "test_list": ["assert candidate([[10,20],[30,200],[400,50],[30,20]])==110", "assert candidate([[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]])==1859", "assert candidate([[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]])==3086"], "test_function": "def test_run(content1):\n    return SN_MCT(content1).Minimum_cost()", "entry_point": "test_run", "test_matching": "assert candidate([['class MCT', 'class SN_MCT(MCT)', 'super().__init__(costs)', 'def Minimum_cost']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/377", "question": "Question: Given an integer array **nums** and two integers **firstLen** and **secondLen**, you are to find and return the maximum sum of elements in two non-overlapping subarrays, with lengths respectively as **firstLen** and **secondLen**;\nBased on the above question, create a class **OSR** in Python with the attribute **nums**; then create another class **SN_OSR** that inherits from the **OSR** class, and add two attributes **firstLen** and **secondLen**, as well as a public function **overlapping_subarray** that returns the result of the above question.", "test_list": ["assert candidate([0,6,5,2,2,5,1,9,4],1,2)==20", "assert candidate([3,8,1,3,2,1,8,9,0],3,2)==29", "assert candidate([2,1,5,6,0,9,5,0,3,8],4,3)==31"], "test_function": "def test_run(content1,content2,content3):\n    return SN_OSR(content1,content2,content3).overlapping_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class OSR', 'class SN_OSR(OSR)', 'super().__init__(nums)', 'def overlapping_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/378", "question": "Question: Three stones are placed on the number line at positions **a**, **b**, and **c**. In each round, you can pick up a stone from one of the ends (either the largest or smallest position) and place it in any free position between the two ends. Formally, suppose the three stones are currently at positions **x**, **y**, and **z** with x<y<z. Then you can pick up a stone from position **x** or **z** and move it to an integer position **k**, where x<k<z and k!=y. The game ends when you can't make any more moves, i.e., when the positions of the stones are consecutive. What are the minimum and maximum number of moves you can make to end the game? Return the answer in the form of a 2-length array: answer=[minimum_moves,maximum_moves];\nBased on the above question, please create a class **SMT** in Python with an attribute **a**; then create a class **SN_SMT** that inherits from the **SMT** class, and add two attributes **b** and **c**, as well as a public function **Stone_movement** that returns the result of the above question.", "test_list": ["assert candidate(1,2,5)==[1, 2]", "assert candidate(4,3,2)==[0, 0]"], "test_function": "def test_run(content1,content2,content3):\n    return SN_SMT(content1,content2,content3).Stone_movement()", "entry_point": "test_run", "test_matching": "assert candidate([['class SMT', 'class SN_SMT(SMT)', 'super().__init__(a)', 'def Stone_movement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/379", "question": "Question: Write down the integers in **nums1** and **nums2** in the given order on two independent horizontal lines. Now, some lines can be drawn connecting the two numbers nums1[i] and nums2[j]. These lines need to satisfy the following conditions:\n1. nums1[i] == nums2[j]; \n2. The drawn line does not intersect with any other lines (non-horizontal lines). Please note that the lines cannot intersect even at the endpoints: each number can only belong to one line. Draw lines in this way and return the maximum number of lines that can be drawn.\nPlease create a class called **MCT** in Python, which has the attribute **nums1**. Then create another class called **SN_MCT** that inherits from the **MCT** class, and add the attribute **nums2**, as well as a public function **max_connections** that returns the maximum number of lines that can be drawn.", "test_list": ["assert candidate([1,4,2],[1,2,4])==2", "assert candidate([2,5,1,2,5],[10,5,2,1,5,2])==3", "assert candidate([1,3,7,1,7,5],[1,9,2,5,1])==2"], "test_function": "def test_run(content1,content2):\n    return SN_MCT(content1,content2).max_connections()", "entry_point": "test_run", "test_matching": "assert candidate([['class MCT', 'class SN_MCT(MCT)', 'super().__init__(nums1)', 'def max_connections']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/380", "question": "Question: In a 10^6x10^6 grid, the coordinates of each cell are (x,y). Now, starting from the source cell source=[sx,sy], the intention is to rush to the target cell target=[tx,ty]. The array blocked is a list of blocked cells, where each blocked[i]=[xi,yi] indicates that the cell with coordinates (xi,yi) is forbidden to pass. Each move can go to the cell adjacent in the four directions in the grid, as long as the cell is not on the given **blocked** list. Also, it is not allowed to go out of the grid. Only when it is possible to reach the target cell target from the source cell source through a series of moves, return True. Otherwise, return False;\nBased on the above question, please create a class **SGD** in Python language with the attribute **blocked**; then create a class **SN_SGD**, inherit the **SGD** class, and add two attributes **source** and **target**, and a public function **Source_grid** to return the result of the above question.", "test_list": ["assert candidate([[0,1],[1,0]],[0,0],[0,2])==False", "assert candidate([],[0,0],[999999,999999])==True"], "test_function": "def test_run(content1,content2,content3):\n    return SN_SGD(content1,content2,content3).Source_grid()", "entry_point": "test_run", "test_matching": "assert candidate([['class SGD', 'class SN_SGD(SGD)', 'super().__init__(blocked)', 'def Source_grid']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/381", "question": "Question: You have a convex n-polygon, each vertex of which has an integer value. Given an integer array **values**, where values[i] is the value of the i-th vertex (i.e., in clockwise order). Assume the polygon is divided into n-2 triangles. For each triangle, the value of the triangle is the product of the vertex labels, and the score of the triangulation is the sum of the values of all n-2 triangles after the triangulation. Return the lowest score that can be obtained after the polygon is triangulated;\nBased on the above question, please create a class **TGT** in Python, with the attribute **values**; then create a class **SN_TGT** that inherits from the **TGT** class, and add a public function **triangulation** that returns the lowest score that can be obtained after the polygon is triangulated.", "test_list": ["assert candidate([1,2,3])==6", "assert candidate([3,7,4,5])==144", "assert candidate([1,3,1,4,1,5])==13"], "test_function": "def test_run(content1):\n    return SN_TGT(content1).triangulation()", "entry_point": "test_run", "test_matching": "assert candidate([['class TGT', 'class SN_TGT(TGT)', 'super().__init__(values)', 'def triangulation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/382", "question": "Question: On an infinite plane, the robot initially stands at the point (0,0), facing north. Note:\n1. North is the positive direction of the y-axis. 2. South is the negative direction of the y-axis. 3. East is the positive direction of the x-axis. 4. West is the negative direction of the x-axis. The robot can accept one of the following three instructions:\n1. **G**: Go straight for 1 unit. 2. **L**: Turn left by 90 degrees. 3. **R**: Turn right by 90 degrees. The robot executes the **instructions** in order and repeats them indefinitely. Only when there is a loop in the plane that the robot can never leave, return True. Otherwise, return False;\nPlease create a class **EIT** in Python based on the above problem, with the property **instructions**; Then create a class **SN_EIT**, inheriting from the **EIT** class, and add a public function **Execute_instructions** to return the result of the above problem.", "test_list": ["assert candidate(\"GGLLGG\")==True", "assert candidate(\"GG\")==False", "assert candidate(\"GL\")==True"], "test_function": "def test_run(content1):\n    return SN_EIT(content1).Execute_instructions()", "entry_point": "test_run", "test_matching": "assert candidate([['class EIT', 'class SN_EIT(EIT)', 'super().__init__(instructions)', 'def Execute_instructions']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/383", "question": "Question: There are **n** gardens, labeled from 1 to **n**. There is also an array **paths**, where paths[i] = [x_i, y_i] describes the bidirectional path from garden **x_i** to garden **y_i**. In each garden, you plan to plant one of four types of flowers. Moreover, each garden can have at most three paths leading in or out. You need to choose a type of flower for each garden so that the types of flowers in any two gardens connected by a path are different. Return any feasible solution as the answer **answer** in the form of an array, where answer[i] represents the type of flower planted in the (i+1)th garden. The types of flowers are represented by 1, 2, 3, and 4;\nBased on the above question, create a class **PFS** in Python with the attribute **n**; then create a class **SN_PFS** that inherits from the **PFS** class, and add the attribute **paths**, as well as a public function **Planted_flowers** that returns the result of the above question.", "test_list": ["assert candidate(3,[[1,2],[2,3],[3,1]])==[1,2,3]", "assert candidate(4,[[1,2],[3,4]])==[1,2,1,2]", "assert candidate(4,[[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]])==[1,2,3,4]"], "test_function": "def test_run(content1,content2):\n    return SN_PFS(content1,content2).Planted_flowers()", "entry_point": "test_run", "test_matching": "assert candidate([['class PFS', 'class SN_PFS(PFS)', 'super().__init__(n)', 'def Planted_flowers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/384", "question": "Question: Given an integer array **arr**, please divide this array into some (continuous) sub-arrays with a maximum length of **k**. After the division, all values in each sub-array will become the maximum value in that sub-array. Return the maximum sum of elements that can be obtained after the array is divided and transformed;\nBased on the above question, create a class **STF** in Python language with the attribute **arr**; then create a class **SN_STF** that inherits the **STF** class, and add the attribute **k**, as well as a public function **Separation_transformation** that returns the maximum sum of elements that can be obtained after the array is divided and transformed.", "test_list": ["assert candidate([1,15,7,9,2,5,10],3)==84", "assert candidate([1,4,1,5,7,3,6,1,9,9,3],4)==83", "assert candidate([1],1)==4"], "test_function": "def test_run(content1,content2):\n    return SN_STF(content1,content2).Separation_transformation()", "entry_point": "test_run", "test_matching": "assert candidate([['class STF', 'class SN_STF(STF)', 'super().__init__(arr)', 'def Separation_transformation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/385", "question": "Question: Given a string **s**, consider all its repeated substrings: that is, the (continuous) substrings of **s** that appear 2 or more times in **s**. These appearances may overlap. Return any one of the possible longest repeated substrings. If **s** does not contain repeated substrings, then the answer is \"\";\nPlease create a class **RST** in Python language based on the above question, with the attribute **s**; then create another class **SN_RST** that inherits from the **RST** class, and add a public function **Repeated_substring** that returns the possible longest repeated substring.", "test_list": ["assert candidate(\"banana\")==\"ana\"", "assert candidate(\"abcd\")==\"\""], "test_function": "def test_run(content1):\n    return SN_RST(content1).Repeated_substring()", "entry_point": "test_run", "test_matching": "assert candidate([['class RST', 'class SN_RST(RST)', 'super().__init__(s)', 'def Repeated_substring']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/386", "question": "Question: Given a word array **words**, each word is composed of lowercase English letters. If we can add exactly one letter anywhere in **wordA** without changing the order of other characters to make it become **wordB**, then we consider **wordA** to be the predecessor of **wordB**. For example, **abc** is the predecessor of **abac**, while **cba** is not the predecessor of **bcad**. A word chain is a sequence composed of words [word_1, word_2, ..., word_k], k>=1, where **word1** is the predecessor of **word2**, **word2** is the predecessor of **word3**, and so on. A word is usually a word chain where k==1. Choose words from the given word list **words** to form a word chain, and return the longest possible length of the word chain;\nBased on the above question, please create a class **FCA** in Python with the attribute **words**; then create another class **SN_FCA** that inherits from the **FCA** class, and add a public function **Form_chain** that returns the longest possible length of the word chain.", "test_list": ["assert candidate([\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"])==4", "assert candidate([\"xbc\",\"pcxbcf\",\"xb\",\"cxbc\",\"pcxbc\"])==5", "assert candidate([\"abcd\",\"dbqca\"])==1"], "test_function": "def test_run(content1):\n    return SN_FCA(content1).Form_chain()", "entry_point": "test_run", "test_matching": "assert candidate([['class FCA', 'class SN_FCA(FCA)', 'super().__init__(words)', 'def Form_chain']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/387", "question": "Question: There is a pile of stones, represented by an integer array **stones**. Where stones[i] represents the weight of the i-th stone. Each round, select any two stones from it and crush them together. Suppose the weights of the stones are **x** and **y**, and x <= y. Then the possible results of crushing are as follows:\n1. If x == y, then both stones will be completely crushed; 2. If x != y, then the stone with weight **x** will be completely crushed, and the new weight of the stone with weight **y** is y-x. In the end, at most one stone will be left. Return the minimum possible weight of this stone. If no stones are left, return 0;\nBased on the above question, please create a class **MWG** in Python, with the property **stones**; then create a class **SN_MWG** that inherits from the **MWG** class, and add a public function **Minimum_weight** to return the result of the above question.", "test_list": ["assert candidate([2,7,4,1,8,1])==1", "assert candidate([31,26,33,21,40])==5"], "test_function": "def test_run(content1):\n    return SN_MWG(content1).Minimum_weight()", "entry_point": "test_run", "test_matching": "assert candidate([['class MWG', 'class SN_MWG(MWG)', 'super().__init__(stones)', 'def Minimum_weight']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/388", "question": "Question: Given a positive integer array **arr** (which may contain duplicate elements), please return the maximum arrangement that is lexicographically smaller than **arr** and can be obtained by one swap (swapping the positions of two numbers arr[i] and arr[j]). If such operation is not possible, please return the original array;\nBased on the above question, create a class **OEH** in Python with the attribute **arr**. Then create another class **SN_OEH** that inherits from the **OEH** class, and add a public function **One_exchange** that returns the result of the above question.", "test_list": ["assert candidate([3,2,1])==[3,1,2]", "assert candidate([1,1,5])==[1,1,5]", "assert candidate([1,9,4,6,7])==[1,7,4,6,9]"], "test_function": "def test_run(content1):\n    return SN_OEH(content1).One_exchange()", "entry_point": "test_run", "test_matching": "assert candidate([['class OEH', 'class SN_OEH(OEH)', 'super().__init__(arr)', 'def One_exchange']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/389", "question": "Question: In a warehouse, there is a row of barcodes, where the i-th barcode is barcodes[i]. Please rearrange these barcodes so that no two adjacent barcodes are the same. You can return any answer that meets this requirement, and it is guaranteed that an answer exists;\nPlease create a class **ABD** in Python based on the above question, with the property **barcodes**; then create a class **SN_ABD** that inherits from the **ABD** class, and add a public function **Adjacent_barcodes** that returns the result of the above question.", "test_list": ["assert candidate([1,1,1,2,2,2])==[2,1,2,1,2,1]", "assert candidate([1,1,1,1,2,2,3,3])==[1,3,1,3,2,1,2,1]"], "test_function": "def test_run(content1):\n    return SN_ABD(content1).Adjacent_barcodes()", "entry_point": "test_run", "test_matching": "assert candidate([['class ABD', 'class SN_ABD(ABD)', 'super().__init__(barcodes)', 'def Adjacent_barcodes']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/390", "question": "Question: Given two strings of equal length, **s1** and **s2**, and another string, baseStr, where s1[i] and s2[i] are a pair of equivalent characters. For example, if s1 = **abc** and s2 = **cde**, then 'a' == 'c', 'b' == 'd', and 'c' == 'e'. Equivalent characters follow the general rules of any equivalence relation:\n1. Reflexivity: 'a' == 'a'; 2. Symmetry: if 'a' == 'b', then 'b' == 'a'; 3. Transitivity: if 'a' == 'b' and 'b' == 'c', then 'a' == 'c'. Using the equivalence information of **s1** and **s2**, find and return the lexicographically smallest equivalent string of baseStr;\nBased on the above question, please create a class **EST** in Python, with the attribute **s1**; then create another class **SN_EST**, inheriting from the **EST** class, and add two attributes **s2** and **baseStr**, as well as a public function **Equivalent_String** that returns the lexicographically smallest equivalent string of **baseStr**.", "test_list": ["assert candidate(\"parker\",\"morris\",\"parser\")==\"makkek\"", "assert candidate(\"hello\",\"world\",\"hold\")==\"hdld\"", "assert candidate(\"leetcode\",\"programs\",\"sourcecode\")==\"aauaaaaada\""], "test_function": "def test_run(content1,content2,content3):\n    return SN_EST(content1,content2,content3).Equivalent_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class EST', 'class SN_EST(EST)', 'super().__init__(s1)', 'def Equivalent_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/391", "question": "Question: Given an m x n matrix **matrix**, you can select any number of columns from it and flip each cell on it. (That is, after flipping, the value of the cell changes from 0 to 1, or from 1 to 0.) Return the maximum number of rows where all values in the row are equal after some flips;\nPlease create a class **MRW** with the property **matrix** in Python based on the above question; then create a class **SN_MRW** that inherits the **MRW** class, and add a public function **Maximum_rows** to return the result of the above question.", "test_list": ["assert candidate([[0,1],[1,1]])==1", "assert candidate([[0,1],[1,0]])==2", "assert candidate([[0,0,0],[0,0,1],[1,1,0]])==2"], "test_function": "def test_run(content1):\n    return SN_MRW(content1).Maximum_rows()", "entry_point": "test_run", "test_matching": "assert candidate([['class MRW', 'class SN_MRW(MRW)', 'super().__init__(matrix)', 'def Maximum_rows']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/392", "question": "Question: Given two numbers **arr1** and **arr2** in base -2, return the result of their addition;\nPlease create a class named **ANS** in Python based on the above question, with the attribute **arr1**. Then create another class named **SN_ANS**, which inherits from the **ANS** class, and adds the attribute **arr2**, as well as a public function **Adding_Numbers** to return the result of adding the two numbers.", "test_list": ["assert candidate([1,1,1,1,1],[1,0,1])==[1,0,0,0,0]", "assert candidate([0],[0])==[0]", "assert candidate([0],[1])==[1]"], "test_function": "def test_run(content1,content2):\n    return SN_ANS(content1,content2).Adding_Numbers()", "entry_point": "test_run", "test_matching": "assert candidate([['class ANS', 'class SN_ANS(ANS)', 'super().__init__(arr1)', 'def Adding_Numbers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/393", "question": "Question: Given a **matrix** and a **target** value, return the number of non-empty submatrices whose sum of elements equals the target value;\nPlease create a class **ESI** in Python language based on the above question, with the attribute **matrix**; then create another class **SN_ESI**, inheriting from the **ESI** class, and add the attribute **target**, as well as a public function **empty_submatrix** to return the number of non-empty submatrices whose sum of elements equals the **target** value.", "test_list": ["assert candidate([[0,1,0],[1,1,1],[0,1,0]],0)==4", "assert candidate([[1,-1],[-1,1]],0)==5", "assert candidate([[904]],0)==0"], "test_function": "def test_run(content1,content2):\n    return SN_ESI(content1,content2).empty_submatrix()", "entry_point": "test_run", "test_matching": "assert candidate([['class ESI', 'class SN_ESI(ESI)', 'super().__init__(matrix)', 'def empty_submatrix']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/394", "question": "Question: You have a set of movable type **tiles**, each of which is engraved with a letter tiles[i]. Return the number of non-empty letter sequences you can print;\nPlease create a class **LSQ** based on the above question, with the attribute **tiles** using Python language; then create another class **SN_LSQ**, inheriting from the **LSQ** class, and add a public function **letter_sequence** that returns the number of non-empty letter sequences that can be printed.", "test_list": ["assert candidate(\"AAB\")==8", "assert candidate(\"AAABBC\")==188", "assert candidate(\"V\")==1"], "test_function": "def test_run(content1):\n    return SN_LSQ(content1).letter_sequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class LSQ', 'class SN_LSQ(LSQ)', 'super().__init__(tiles)', 'def letter_sequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/395", "question": "Question: Return the subsequence of **s** with the smallest lexicographical order, which contains all distinct characters of **s** and only contains them once;\nBased on the above question, create a class **SSU** in Python language with the attribute **s**. Then create another class **SN_SSU**, which inherits from the **SSU** class, and add a public function **smallest_subsequence** to return the result of the above question.", "test_list": ["assert candidate(\"bcabc\")==\"abc\"", "assert candidate(\"cbacdcbc\")==\"acdb\""], "test_function": "def test_run(content1):\n    return SN_SSU(content1).smallest_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSU', 'class SN_SSU(SSU)', 'super().__init__(s)', 'def smallest_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/396", "question": "Question: We have a set of **n** items. Two integer arrays, **values** and **labels**, are given, where the value and label of the i-th element are values[i] and labels[i] respectively. Two more integers, **numWanted** and **useLimit**, are also given. We are to select a subset **s** from the **n** elements such that:\n1. The size of subset **s** is less than or equal to numWanted. 2. There are at most useLimit items with the same label in **s**. The score of a subset is the sum of the values of the subset. The task is to return the maximum score of subset **s**;\nBased on the above question, please create a class named **MSR** in Python, which has the attribute **values**. Then create another class **SN_MSR**, which inherits from the **MSR** class, and adds three attributes: **labels**, **numWanted**, and **useLimit**, as well as a public function **Maximum_score** that returns the maximum score of subset **s**.", "test_list": ["assert candidate([5,4,3,2,1],[1,1,2,2,3],3,1)==9", "assert candidate([5,4,3,2,1],[1,3,3,3,2],3,2)==12", "assert candidate([9,8,8,7,6],[0,0,0,1,1],3,1)==16"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_MSR(content1,content2,content3,content4).Maximum_score()", "entry_point": "test_run", "test_matching": "assert candidate([['class MSR', 'class SN_MSR(MSR)', 'super().__init__(values)', 'def Maximum_score']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/397", "question": "Question: Given an n x n binary matrix **grid**, return the length of the shortest unobstructed path in the matrix. If such a path does not exist, return -1;\nBased on the above question, please create a **UPT** class in Python with a **grid** attribute; then create a **SN_UPT** class that inherits the **UPT** class, and add a public **Unobstructed_path** function to return the result of the above question.", "test_list": ["assert candidate([[0,1],[1,0]])==2", "assert candidate([[0,0,0],[1,1,0],[1,1,0]])==4", "assert candidate([[1,0,0],[1,1,0],[1,1,0]])==-1"], "test_function": "def test_run(content1):\n    return SN_UPT(content1).Unobstructed_path()", "entry_point": "test_run", "test_matching": "assert candidate([['class UPT', 'class SN_UPT(UPT)', 'super().__init__(grid)', 'def Unobstructed_path']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/398", "question": "Question: Given two strings **str1** and **str2**, return the shortest string that has both **str1** and **str2** as subsequences;\nPlease create a class **SSI** in Python, which has the attribute **str1**. Then create another class **SN_SSI** that inherits from the **SSI** class, and add the attribute **str2**, as well as a public function **Shortest_string** to return the shortest string that has both **str1** and **str2** as subsequences.", "test_list": ["assert candidate(\"abac\",\"cab\")==\"cabac\"", "assert candidate(\"aaaaaaaa\",\"aaaaaaaa\")==\"aaaaaaaa\""], "test_function": "def test_run(content1,content2):\n    return SN_SSI(content1,content2).Shortest_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSI', 'class SN_SSI(SSI)', 'super().__init__(str1)', 'def Shortest_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/399", "question": "Question: Initially, there are **capacity** empty seats on the bus. The bus can only travel in one direction (that is, it is not allowed to turn around or change direction). Given the integer **capacity** and an array **trips**, trip[i] = [numPassengers_i, from_i, to_i] indicates that there are **numPassengers_i** passengers in the i-th trip, and their pick-up and drop-off locations are **from_i** and **to_i** respectively. These locations are the kilometers from the initial position of the car to the east. Return True only and only when you can pick up and drop off all passengers in all given trips, otherwise please return False;\nBased on the above question, please create a class **PPG** using Python language, with the attribute **trips**; then create a class **SN_PPG** that inherits the **PPG** class, and add the attribute **capacity**, and a public function **Pick_passengers** that returns the result of the above question.", "test_list": ["assert candidate([[2,1,5],[3,3,7]],4)==False", "assert candidate([[2,1,5],[3,3,7]],5)==True"], "test_function": "def test_run(content1,content2):\n    return SN_PPG(content1,content2).Pick_passengers()", "entry_point": "test_run", "test_matching": "assert candidate([['class PPG', 'class SN_PPG(PPG)', 'super().__init__(trips)', 'def Pick_passengers']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/400", "question": "Question: Given a mountain array **mountainArr**, please return the smallest index **index** that makes mountainArr.get(index) equal to **target**. If there is no such index **index**, please return -1. What is a mountain array? If array **A** is a mountain array, then it satisfies the following conditions:\n1. A.length>=3; 2. Under the condition of 0<i<A.length-1, there exists i such that: A[0]<A[1]<...A[i-1]<A[i]; A[i]>A[i+1]>...>A[A.length-1];\nBased on the above question, please use Python language to create a class **MAR** with the property **array**; then create a class **SN_MAR** that inherits the **MAR** class, and add the property **target**, as well as a public function **Mountain_array** that returns the result of the above question.", "test_list": ["assert candidate([1,2,3,4,5,3,1],3)==2", "assert candidate([0,1,2,4,2,1],3)==-1"], "test_function": "def test_run(content1,content2):\n    return SN_MAR(content1,content2).Mountain_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class MAR', 'class SN_MAR(MAR)', 'super().__init__(array)', 'def Mountain_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/401", "question": "Question: Given a boolean expression **expression** in string form, return the result of the operation. A boolean expression is an expression whose result is either True or False. Valid expressions must follow the following conventions:\n1. 't', the operation result is True; 2. 'f', the operation result is False; 3. '!(subExpr)', the operation process is to perform logical NOT operation on the internal expression subExpr; 4. '&(subExpr1,subExpr2,...,subExprn)', the operation process is to perform logical AND operation on two or more internal expressions subExpr1, subExpr2,...,subExprn; 5. '|(subExpr1,subExpr2,...,subExprn)', the operation process is to perform logical OR operation on two or more internal expressions subExpr1, subExpr2,...,subExprn;\nBased on the above question, please create a class **BLS** in Python with the attribute **expression**. Then create another class **SN_BLS** that inherits from the **BLS** class, and add a public function **Booleans** to return the result of the above question.", "test_list": ["assert candidate(\"&(|(f))\")==False", "assert candidate(\"|(f,f,f,t)\")==True", "assert candidate(\"!(&(f,t))\")==True"], "test_function": "def test_run(content1):\n    return SN_BLS(content1).Booleans()", "entry_point": "test_run", "test_matching": "assert candidate([['class BLS', 'class SN_BLS(BLS)', 'super().__init__(expression)', 'def Booleans']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/402", "question": "Question: Here we have **n** flights, numbered from 1 to **n**. There is a flight booking sheet **bookings**. The i-th booking record in the sheet, bookings[i]=[firsti,lasti,seatsi], means that **seatsi** seats have been booked on each flight from **firsti** to **lasti** (including **firsti** and **lasti**). Please return an array **answer** of length **n**, where each element is the total number of seats booked for each flight;\nBased on the above question, please create a class **RSA** in Python language with the attribute **bookings**; then create a class **SN_RSA** that inherits from the **RSA** class, and add the attribute **n**, as well as a public function **Reserved_seats** that returns the result of the above question.", "test_list": ["assert candidate([[1,2,10],[2,3,20],[2,5,25]],5)==[10,55,45,25,25]", "assert candidate([[1,2,10],[2,2,15]],2)==[10,25]"], "test_function": "def test_run(content1,content2):\n    return SN_RSA(content1,content2).Reserved_seats()", "entry_point": "test_run", "test_matching": "assert candidate([['class RSA', 'class SN_RSA(RSA)', 'super().__init__(expression)', 'def Reserved_seats']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/403", "question": "Question: Given a work schedule **hours**, which records the daily working hours of an employee. We consider that if the working hours of an employee in a day exceed 8 hours, then this day is a tiring day. The so-called good performance period means that during this period, the number of tiring days is strictly greater than the number of non-tiring days. Please return the maximum length of the good performance period;\nPlease create a **PWL** class in Python based on the above question, with the attribute **hours**; then create a **SN_PWL** class that inherits the **PWL** class, and add a public **Performing_well** function to return the maximum length of the good performance period.", "test_list": ["assert candidate([9,9,6,0,6,6,9])==3", "assert candidate([6,6,6])==0"], "test_function": "def test_run(content1):\n    return SN_PWL(content1).Performing_well()", "entry_point": "test_run", "test_matching": "assert candidate([['class PWL', 'class SN_PWL(PWL)', 'super().__init__(hours)', 'def Performing_well']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/404", "question": "Question: As a project manager, you have planned a list of required skills **req_skills**, and intend to select some people from the list of alternative personnel **people** to form a **necessary team** (the alternative personnel numbered **i**, people[i], has a list of skills that this alternative personnel masters). The so-called necessary team is a team in which, for each skill listed in the required skill list **req_skills**, at least one member of the team has already mastered it. The team members can be represented by the numbers of each person: please return any necessary team of the smallest scale, with the team members represented by the personnel numbers. You can return the answer in any order, and the question data guarantees that the answer exists;\nPlease create a class **NTM** in Python based on the above question, with the attribute **req_skills**; then create a class **SN_NTM** that inherits the **NTM** class, and add the attribute **people**, as well as a public function **Necessary_team** that returns the result of the above question.", "test_list": ["assert candidate([\"java\",\"nodejs\",\"reactjs\"],[[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]])==[0,2]", "assert candidate([\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"],[[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]])==[1,2]"], "test_function": "def test_run(content1,content2):\n    return SN_NTM(content1,content2).Necessary_team()", "entry_point": "test_run", "test_matching": "assert candidate([['class NTM', 'class SN_NTM(NTM)', 'super().__init__(req_skills)', 'def Necessary_team']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/405", "question": "Question: Given an integer **n**, which is the number of nodes in a directed graph, where the nodes are labeled from 0 to n-1. Each edge in the graph is either red or blue, and there may be self-loops or parallel edges. Given two arrays **redEdges** and **blueEdges**, where:\n1. redEdges[i]=[a_i,b_i] represents that there is a red directed edge from node **a_i** to node **b_i** in the graph, 2. **blueEdges[j]=[u_j,v_j]** represents that there is a blue directed edge from node **u_j** to node **v_j** in the graph. Return an array **answer** of length **n**, where answer[X] is the length of the shortest path from node 0 to node **X** with alternating appearances of red and blue edges. If such a path does not exist, then answer[x]=-1;\nPlease create a class **AAR** with the attribute **n** using Python based on the above question; then create a class **SN_AAR** that inherits the **AAR** class, and add two attributes **red_edges** and **blue_edges**, as well as a public function **Alternating_appearance** that returns the result of the above question.", "test_list": ["assert candidate(3,[[0,1],[1,2]],[])==[0,1,-1]", "assert candidate(3,[[0,1]],[[2,1]])==[0,1,-1]"], "test_function": "def test_run(content1,content2,content3):\n    return SN_AAR(content1,content2,content3).Alternating_appearance()", "entry_point": "test_run", "test_matching": "assert candidate([['class AAR', 'class SN_AAR(AAR)', 'super().__init__(n)', 'def Alternating_appearance']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/406", "question": "Question: Given two integer arrays of equal length, return the maximum value of the following expression: |arr1[i]-arr1[j]|+|arr2[i]-arr2[j]|+|i-j| where the indices **i**, **j** satisfy 0<=i,j<arr1.length;\nBased on the above question, please create a class **MES** in Python, which has the attribute **arr1**. Then create another class **SN_MES**, inheriting from the **MES** class, and add the attribute **arr2**, as well as a public function **Maximum_expression** to return the result of the above question.", "test_list": ["assert candidate([1,2,3,4],[-1,4,5,6])==13", "assert candidate([1,-2,-5,0,10],[0,-2,-1,-7,-4])==20"], "test_function": "def test_run(content1,content2):\n    return SN_MES(content1,content2).Maximum_expression()", "entry_point": "test_run", "test_matching": "assert candidate([['class MES', 'class SN_MES(MES)', 'super().__init__(arr1)', 'def Maximum_expression']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/407", "question": "Question: Given a two-dimensional **grid** composed of several 0s and 1s, please find the largest square sub-grid whose boundaries are all composed of 1s, and return the number of elements in the sub-grid. If it does not exist, return 0;\nPlease create a class **SSR** with the property **grid** in Python based on the above question; then create a class **SN_GGG** that inherits from the **GGG** class, and add a public function **Square_subgrid** to return the result of the above question.", "test_list": ["assert candidate([[1,1,1],[1,0,1],[1,1,1]])==9", "assert candidate([[1,1,0,0]])==1"], "test_function": "def test_run(content1):\n    return SN_GGG(content1).Square_subgrid()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSR', 'class SN_GGG(GGG)', 'super().__init__(grid)', 'def Square_subgrid']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/408", "question": "Question: Alice and Bob continue their stone game. Many piles of stones are lined up, each pile has a positive integer number of stones piles[i]. The game is decided by who has the most stones in their hands. Alice and Bob take turns, with Alice starting first. Initially, M=1. In each player's turn, the player can take all the stones from the remaining first **X** piles, where 1<=X<=2M. Then, let M=max(M,X). The game continues until all the stones are taken. Assuming Alice and Bob both play at their best, return the maximum number of stones Alice can get;\nBased on the above question, please create a class **SGA** using Python language, with the attribute **piles**; then create a class **SN_SGA** that inherits the **SGA** class, and add a public function **Stone_Game** to return the maximum number of stones Alice can get.", "test_list": ["assert candidate([2,7,9,4,4])==10", "assert candidate([1,2,3,4,5,100])==104"], "test_function": "def test_run(content1):\n    return SN_SGA(content1).Stone_Game()", "entry_point": "test_run", "test_matching": "assert candidate([['class SGA', 'class SN_SGA(SGA)', 'super().__init__(piles)', 'def Stone_Game']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/409", "question": "Question: Given two strings **text1** and **text2**, return the length of the longest common subsequence of these two strings. If there is no common subsequence, return 0. A subsequence of a string is a new string that is formed by deleting some characters (or no characters) from the original string without changing the relative order of the characters. The common subsequence of two strings is a subsequence that the two strings both have;\nBased on the above question, please create a class **SSN** in Python, with the attribute **text1**; then create another class **SN_SSN** that inherits from the **SSN** class, and add the attribute **text2**, as well as a public function **Shared_subsequences** to return the result of the above question.", "test_list": ["assert candidate(\"abcde\",\"ace\")==3", "assert candidate(\"abc\",\"abc\")==3", "assert candidate(\"abc\",\"def\")==0"], "test_function": "def test_run(content1,content2):\n    return SN_SSN(content1,content2).Shared_subsequences()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSN', 'class SN_SSN(SSN)', 'super().__init__(text1)', 'def Shared_subsequences']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/410", "question": "Question: Given an integer array **nums**, each operation will select an element and decrease its value by 1. If one of the following conditions is met, then array **A** is a zigzag array:\n1. Each element corresponding to an even index is greater than its adjacent elements, i.e., A[0]>A[1]<A[2]>A[3]<A[4]>...; \n2. Or, each element corresponding to an odd index is greater than its adjacent elements, i.e., A[0]<A[1]>A[2]<A[3]>A[4]<...; \nReturn the minimum number of operations required to convert the array **nums** into a zigzag array.\n\nBased on the above question, please create a class **JAR** in Python language, which has the attribute **nums**. Then create a class **SN_JAR** that inherits from the **JAR** class, and add a public function **Jagged_array** to return the minimum number of operations required to convert the integer array **nums** into a zigzag array.", "test_list": ["assert candidate([1,2,3])==2", "assert candidate([9,6,1,6,2])==4"], "test_function": "def test_run(content1):\n    return SN_JAR(content1).Jagged_array()", "entry_point": "test_run", "test_matching": "assert candidate([['class JAR', 'class SN_JAR(JAR)', 'super().__init__(nums)', 'def Jagged_array']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/411", "question": "Question: You will be given a string **text**, which should be divided into **k** substrings (subtext1, subtext2,â€¦,subtextk), with the following requirements:\n1. Each **subtexti** is a non-empty string; \n2. The concatenation of all substrings equals to **text** (i.e., subtext1+subtext2+...+subtextk==text); \n3. For all valid values of **i** (i.e., 1<=i<=k), subtexti==subtextk-i+1 should hold True; \nThe task is to return the maximum possible value of **k**.\nPlease create a class **ESI** in Python, which has the attribute **text**. Then create another class **SN_ESI**, which inherits from the **ESI** class, and add a public function **empty_string** that returns the maximum possible value of **k**.", "test_list": ["assert candidate(\"ghiabcdefhelloadamhelloabcdefghi\")==7", "assert candidate(\"merchant\")==1", "assert candidate(\"antaprezatepzapreanta\")==11"], "test_function": "def test_run(content1):\n    return SN_ESI(content1).empty_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class ESI', 'class SN_ESI(ESI)', 'super().__init__(text)', 'def empty_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/412", "question": "Question: Here we have **n** identical dice, each with **k** faces, numbered from 1 to **k**. Given three integers **n**, **k**, and **target**, return the number of possible ways (out of a total of k^n ways) to roll the dice so that the sum of the numbers facing up equals **target**;\nBased on the above question, please create a class **FUP** in Python, with the attribute **n**; then create another class **SN_FUP**, inheriting from the **FUP** class, and add two attributes **k** and **target**, as well as a public function **face_up** that returns the result of the above question.", "test_list": ["assert candidate(1,6,3)==1", "assert candidate(2,6,7)==6", "assert candidate(30,30,500)==222616187"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FUP(content1,content2,content3).face_up()", "entry_point": "test_run", "test_matching": "assert candidate([['class FUP', 'class SN_FUP(FUP)', 'super().__init__(n)', 'def face_up']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/413", "question": "Question: If all characters in a string are the same, then the string is a single-character repeated string. Given a string **text**, you can only swap two characters once or do nothing, and then get some single-character repeated substrings. Return the length of the longest substring;\nPlease create a **DSN** class in Python based on the above question, with the attribute **text**. Then create a class **SN_DSN** that inherits from the **DSN** class, and add a public function **Duplicate_string** that returns the length of the longest substring.", "test_list": ["assert candidate(\"ababa\")==3", "assert candidate(\"aaabaaa\")==6", "assert candidate(\"aaabbaaa\")==4", "assert candidate(\"aaaaa\")==5", "assert candidate(\"abcdef\")==1"], "test_function": "def test_run(content1):\n    return SN_DSN(content1).Duplicate_string()", "entry_point": "test_run", "test_matching": "assert candidate([['class DSN', 'class SN_DSN(DSN)', 'super().__init__(text)', 'def Duplicate_string']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/414", "question": "Question: You currently have a **grid** of size n x n in your hand, with each cell marked with 0 and 1. Here, 0 represents the ocean, and 1 represents the **land**. Please find an ocean cell where the distance to the nearest land cell is the maximum, and return this distance. If the grid only contains land or ocean, please return -1;\nBased on the above question, create an **OCL** class in Python language with the **grid** attribute; then create a **SN_OCL** class that inherits the **OCL** class, and add a public **Ocean_Cell** function to return the result of the above question.", "test_list": ["assert candidate([[1,0,1],[0,0,0],[1,0,1]])==2", "assert candidate([[1,0,0],[0,0,0],[0,0,0]])==4"], "test_function": "def test_run(content1):\n    return SN_OCL(content1).Ocean_Cell()", "entry_point": "test_run", "test_matching": "assert candidate([['class OCL', 'class SN_OCL(OCL)', 'super().__init__(grid)', 'def Ocean_Cell']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/415", "question": "Question: Given a string **s**, find all its substrings and sort them in lexicographical order, return the last substring;\nBased on the above question, create a class **LAM** in Python language with the attribute **s**; then create another class **SN_LAM**, inheriting from the **LAM** class, and add a public function **Lexicographic_arrangement** to return the last substring.", "test_list": ["assert candidate(\"abab\")==\"bab\"", "assert candidate(\"leetcode\")==\"tcode\""], "test_function": "def test_run(content1):\n    return SN_LAM(content1).Lexicographic_arrangement()", "entry_point": "test_run", "test_matching": "assert candidate([['class LAM', 'class SN_LAM(LAM)', 'super().__init__(s)', 'def Lexicographic_arrangement']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/416", "question": "Question: A transaction may be invalid under the following two circumstances:\n1. The transaction amount exceeds $1000; 2. Or, it is not more than 60 minutes (including 60 minutes) apart from another transaction with the same name in another city; Given the string array transaction list **transactions**. Each transaction string transactions[i] is composed of some values separated by commas, which represent the name, time (in minutes), amount, and city of the transaction. Return **transactions**, return the list of possible invalid transactions;\nPlease create a class **TLI** in Python language based on the above question, with the attribute **transactions**; then create another class **SN_TLI** that inherits from the **TLI** class, and add a public function **Transaction_List** that returns the result of the above question.", "test_list": ["assert candidate([\"alice,20,800,mtv\",\"alice,50,100,beijing\"])==[\"alice,20,800,mtv\",\"alice,50,100,beijing\"]", "assert candidate([\"alice,20,800,mtv\",\"alice,50,1200,mtv\"])==[\"alice,50,1200,mtv\"]", "assert candidate([\"alice,20,800,mtv\",\"bob,50,1200,mtv\"])==[\"bob,50,1200,mtv\"]"], "test_function": "def test_run(content1):\n    return SN_TLI(content1).Transaction_List()", "entry_point": "test_run", "test_matching": "assert candidate([['class TLI', 'class SN_TLI(TLI)', 'super().__init__(transactions)', 'def Transaction_List']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/417", "question": "Question: Given two integer arrays **arr1** and **arr2**, return the minimum number of operations required to make **arr1** strictly increasing (possibly 0). In each operation, you can select an index from both **arr1** and **arr2**, respectively **i** and **j**, where 0<=i<arr1.length and 0<=j<arr2.length, and then perform the assignment operation arr1[i]=arr2[j]. If it is impossible to make **arr1** strictly increasing, please return -1;\nBased on the above question, please create a class **SII** in Python language with the property **arr1**; then create another class **SN_SII** that inherits the **SII** class, and add the property **arr2**, as well as a public function **Strictly_Increasing** that returns the result of the above question.", "test_list": ["assert candidate([1,5,3,6,7],[1,3,2,4])==1", "assert candidate([1,5,3,6,7],[4,3,1])==2", "assert candidate([1,5,3,6,7],[1,6,3,3])==-1"], "test_function": "def test_run(content1,content2):\n    return SN_SII(content1,content2).Strictly_Increasing()", "entry_point": "test_run", "test_matching": "assert candidate([['class SII', 'class SN_SII(SII)', 'super().__init__(arr1)', 'def Strictly_Increasing']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/418", "question": "Question: Given a string **s** (containing only lowercase English letters and parentheses), please reverse the string in each pair of matching parentheses from the inside out in order, and return the final result;\nBased on the above question, please create a class **MBC** in Python language with the attribute **s**. Then create another class **SN_MBC** that inherits from the **MBC** class, and add a public function **Match_Brace** to return the final result.", "test_list": ["assert candidate(\"(abcd)\")==\"dcba\"", "assert candidate(\"(u(love)i)\")==\"iloveu\"", "assert candidate(\"(ed(et(oc))el)\")==\"leetcode\"", "assert candidate(\"a(bcdefghijkl(mno)p)q\")==\"apmnolkjihgfedcbq\""], "test_function": "def test_run(content1):\n    return SN_MBC(content1).Match_Brace()", "entry_point": "test_run", "test_matching": "assert candidate([['class MBC', 'class SN_MBC(MBC)', 'super().__init__(s)', 'def Match_Brace']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/419", "question": "Question: Given an integer array **arr** and an integer **k**, modify the array by repeating **k** times. Return the sum of the largest subarray in the modified array;\nPlease create a class **SSA** in Python based on the above question, with the attribute **arr**. Then create a class **SN_SSA** that inherits from the **SSA** class, and add the attribute **k**, as well as a public function **Sum_subarrays** that returns the sum of the largest subarray in the modified array.", "test_list": ["assert candidate([1,2],3)==9", "assert candidate([1,-2,1],5)==2", "assert candidate([-1,-2],7)==0"], "test_function": "def test_run(content1,content2):\n    return SN_SSA(content1,content2).Sum_subarrays()", "entry_point": "test_run", "test_matching": "assert candidate([['class SSA', 'class SN_SSA(SSA)', 'super().__init__(k)', 'def Sum_subarrays']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/420", "question": "Question: Given four integers: **n**, **a**, **b**, **c**, please design an algorithm to find the n-th ugly number;\nBased on the above question, create a class **UNB** in Python, with the attribute **n**; then create another class **SN_UNB**, inheriting from the **UNB** class, and add three attributes **a**, **b** and **c**, as well as a public function **Ugly_number** to return the n-th ugly number.", "test_list": ["assert candidate(3,2,3,5)==4", "assert candidate(4,2,3,4)==6", "assert candidate(5,2,11,13)==10", "assert candidate(1000000000,2,217983653,336916467)==1999999984"], "test_function": "def test_run(content1,content2,content3,content4):\n    return SN_UNB(content1,content2,content3,content4).Ugly_number()", "entry_point": "test_run", "test_matching": "assert candidate([['class UNB', 'class SN_UNB(UNB)', 'super().__init__(n)', 'def Ugly_number']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/421", "question": "Question: Given a string **s** and some index pairs array **pairs** in the string, where pairs[i]=[a,b] represents two indexes in the string (numbered from 0). You can swap the characters at any pair of indexes in pairs any number of times. Return the lexicographically smallest string that **s** can become after several swaps;\nBased on the above question, please create a class **DMM** in Python with the attribute **s**; then create a class **SN_DMM** that inherits the **DMM** class, and add the attribute **pairs**, as well as a public function **Dictionary_minimum** to return the result of the above question.", "test_list": ["assert candidate(\"dcab\",[[0,3],[1,2]])==\"bacd\"", "assert candidate(\"dcab\",[[0,3],[1,2],[0,2]])==\"abcd\"", "assert candidate(\"cba\",[[0,1],[1,2]])==\"abc\""], "test_function": "def test_run(content1,content2):\n    return SN_DMM(content1,content2).Dictionary_minimum()", "entry_point": "test_run", "test_matching": "assert candidate([['class DMM', 'class SN_DMM(DMM)', 'super().__init__(s)', 'def Dictionary_minimum']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/422", "question": "Question: Given two strings of equal length, **s** and **t**. Changing the i-th character in **s** to the i-th character in **t** requires a cost of |s[i]-t[i]| (the cost could be 0), which is the absolute difference of the ASCII values of the two characters. The maximum budget for changing the string is **maxCost**. During the string transformation, the total cost should be less than or equal to this budget, which also means that the string transformation may be incomplete. If you can transform a substring of **s** into its corresponding substring in **t**, then return the maximum length that can be transformed. If there is no substring in **s** that can be transformed into a corresponding substring in **t**, then return 0;\nBased on the above question, please create a class named **MBG** in Python, which has an attribute **s**. Then create a class named **SN_MBG**, which inherits from the **MBG** class, and adds two attributes **t** and **maxCost**, as well as a public function **Maximum_budget** to return the result of the above question.", "test_list": ["assert candidate(\"abcd\",\"bcdf\",3)==3", "assert candidate(\"abcd\",\"cdef\",3)==1", "assert candidate(\"abcd\",\"acde\",0)==1"], "test_function": "def test_run(content1,content2,content3):\n    return SN_MBG(content1,content2,content3).Maximum_budget()", "entry_point": "test_run", "test_matching": "assert candidate([['class MBG', 'class SN_MBG(MBG)', 'super().__init__(s)', 'def Maximum_budget']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/423", "question": "Question: Given a string **s**, the **k** times repeated item deletion operation will select **k** adjacent and equal letters from **s** and delete them, connecting the left and right sides of the deleted string. You need to repeatedly perform such deletion operations on **s** indefinitely until it can no longer continue. After all deletion operations are completed, return the final obtained string;\nBased on the above question, please create a class **DOT** in Python language with the attribute **s**; then create a class **SN_DOT**, inherit the **DOT** class, and add the attribute **k**, as well as a public **Delete_Operation** function to return the final obtained string.", "test_list": ["assert candidate(\"abcd\",2)==\"abcd\"", "assert candidate(\"deeedbbcccbdaa\",3)==\"aa\"", "assert candidate(\"pbbcggttciiippooaais\",2)==\"ps\""], "test_function": "def test_run(content1,content2):\n    return SN_DOT(content1,content2).Delete_Operation()", "entry_point": "test_run", "test_matching": "assert candidate([['class DOT', 'class SN_DOT(DOT)', 'super().__init__(s)', 'def Delete_Operation']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/424", "question": "Question: Given an integer array **arr** and an integer **difference**, please find and return the length of the longest arithmetic subsequence in **arr**, where the difference between adjacent elements equals **difference**;\nBased on the above question, please create a class **ESQ** in Python, which has the attribute **arr**. Then create another class **SN_ESQ**, inheriting from the **ESQ** class, and add the attribute **difference**, as well as a public function **Equidistant_subsequence** to return the length of the longest arithmetic subsequence in the integer array **arr**.", "test_list": ["assert candidate([1,2,3,4],1)==4", "assert candidate([1,3,5,7],1)==1", "assert candidate([1,5,7,8,5,3,4,2,1],-2)==4"], "test_function": "def test_run(content1,content2):\n    return SN_ESQ(content1,content2).Equidistant_subsequence()", "entry_point": "test_run", "test_matching": "assert candidate([['class ESQ', 'class SN_ESQ(ESQ)', 'super().__init__(arr)', 'def Equidistant_subsequence']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/425", "question": "Question: You are to develop a gold mine. Geological surveyors have determined the resource distribution in the mine and marked it with an m*n grid. Each integer in a cell represents the amount of gold in that cell; if the cell is empty, it is 0. To maximize profits, miners need to mine gold according to the following rules:\n1. Whenever a miner enters a cell, he collects all the gold in that cell. 2. Miners can move up, down, left, and right from their current position. 3. Each cell can only be mined (entered) once. 4. Cells with zero gold cannot be mined (entered). 5. Miners can start or stop from any cell with gold in the grid;\nBased on the above question, please use Python to create a class **RDB** with the attribute **grid**. Then create a class **SN_RDB** that inherits from the **RDB** class and add a public function **resource_distribution** that returns the result of the above question.", "test_list": ["assert candidate([[0,6,0],[5,8,7],[0,9,0]])==24", "assert candidate([[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]])==28"], "test_function": "def test_run(content1):\n    return SN_RDB(content1).resource_distribution()", "entry_point": "test_run", "test_matching": "assert candidate([['class RDB', 'class SN_RDB(RDB)', 'super().__init__(grid)', 'def resource_distribution']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/426", "question": "Question: Given an integer **n**, please help to count how many strings of length **n** can be formed according to the following rules:\n1. Each character in the string should be a lowercase vowel ('a', 'e', 'i', 'o', 'u'); 2. Each vowel 'a' can only be followed by 'e'; 3. Each vowel 'e' can only be followed by 'a' or 'i'; 4. Each vowel 'i' cannot be followed by another 'i'; 5. Each vowel 'o' can only be followed by 'i' or 'u'; 6. Each vowel 'u' can only be followed by 'a';\nPlease create a class named **FSG** in Python, with an attribute **n**; then create another class **SN_FSG** that inherits from the **FSG** class, and add a public method **Forming_String** that returns the result of the above question.", "test_list": ["assert candidate(1)==5", "assert candidate(2)==10", "assert candidate(5)==68"], "test_function": "def test_run(content1):\n    return SN_FSG(content1).Forming_String()", "entry_point": "test_run", "test_matching": "assert candidate([['class FSG', 'class SN_FSG(FSG)', 'super().__init__(n)', 'def Forming_String']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/427", "question": "Question: On an 8x8 chessboard, there are several black queens and one white king. Given an array of integer coordinates **queens**, representing the positions of the black queens; and a pair of coordinates **king**, representing the position of the white king, return the coordinates of all queens that can attack the king (in any order);\nBased on the above question, please use python language to create a class **CKB** with the property **queens**; then create a class **SN_CKB**, inheriting from the **CKB** class, and add the property **king**, as well as a public **checkerboard** function to return the coordinates of all queens that can attack the king.", "test_list": ["assert candidate([[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]],[0,0])==[[0,1],[1,0],[3,3]]", "assert candidate([[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]],[3,3])==[[2,2],[3,4],[4,4]]", "assert candidate([[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]],[3,4])==[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]"], "test_function": "def test_run(content1,content2):\n    return SN_CKB(content1,content2).checkerboard()", "entry_point": "test_run", "test_matching": "assert candidate([['class CKB', 'class SN_CKB(CKB)', 'super().__init__(queens)', 'def checkerboard']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/428", "question": "Create a class named **SBFD** in Python, with properties **nums**, **left**, and **right**, as well as a public function named **find_subarray**. In the public function **find_subarray**, identify and return the count of contiguous, non-empty subarrays within **nums** where the maximum element falls within the range **[left, right]**. Next, create a class named **SN_FDSB** that inherits from the **SBFD** class and add a public function named **find_subarray**. This method should return the count of elements in **nums** within the range **[left, right]**, inclusive of both **left** and **right**. If the range is empty, the function should return 0.", "test_list": ["assert candidate([2,1,4,3],2,3,1,2)==True", "assert candidate([2,9,2,5,6],2,8,1,4)==True"], "test_function": "def test_run(content1, content2, content3, res1, res2):\n    if SBFD(content1, content2, content3).find_subarray()==res1 and SN_FDSB(content1, content2, content3).find_subarray() == res2\n        return True\n    else:\n        return False", "entry_point": "test_run", "test_matching": "assert candidate([[\"class SBFD\", \"def __init__(self, nums, left, right)\", \"class SN_FDSB\", \"def find_subarray\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/429", "question": "First, write a class named **STR** in Python, which has an instance attribute, **s**, and a public function named **without_duplicates**. In the public function **without_duplicates**, based on the instance attribute **s**, find the length of the longest substring without duplicate characters. Next, create a class named **SUB_STR** that inherits from the **STR** class and add a public function named **without_duplicates**. In the public function **without_duplicates** of the **SUB_STR** class, find the maximum distance between repeated characters in the instance attribute **s**.", "test_list": ["assert candidate(\"abcabcbb\", 3, 3)==True", "assert candidate(\"abcabcccbb\", 3, 4)==True", "assert candidate(\"pwwkeyow\", 5, 5)==True"], "test_function": "def test_run(content1, res1, res2):\n    if STR(content1).without_duplicates()==res1 and SUB_STR(content1).without_duplicates() == res2\n        return True\n    else:\n        return False", "entry_point": "test_run", "test_matching": "assert candidate([[\"class STR\", \"def __init__(self, s)\", \"class SUB_STR\", \"def without_duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/430", "question": "Using the Python language, start by creating a class named **PLDR** with an instance attribute **number** and a public function **PLind**. Within the **PLind** function, check if a given number is a palindrome; return **True** if it is, otherwise return **False**. Next, create a subclass named **SUBPLDR** that inherits from the **PLDR** class, and introduce a public function **PLind**. In the **PLind** function of the **SUBPLDR** class, assess whether a given number is a palindrome string; return **True** if it is, otherwise return **False**.", "test_list": ["assert candidate(1211, \"abcabcbb\", False, False)==True", "assert candidate(121, \"abcabcccbb\", True, False)==True", "assert candidate(4576, \"level\", False, True)==True"], "test_function": "def test_run(content1, content2, res1, res2):\n    if PLDR(content1).PLind()==res1 and SUBPLDR(content2).PLind() == res2\n        return True\n    else:\n        return False", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PLDR\", \"def __init__(self, number)\", \"class SUBPLDR\", \"def PLind\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
