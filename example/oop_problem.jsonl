{"task_id": "OOP/0", "question": "First, write a **WDS** class using the Python language. Then, within the WDS class, create a public function called **without_duplicates** to implement finding the length of the longest substring in a given string **s** that does not contain any duplicate characters.", "test_list": ["assert candidate(\"abcabcbb\")==3", "assert candidate(\"bbbbb\")==1", "assert candidate(\"pwwkew\")==3"], "test_function": "def test_run(content1):\n    return WDS().without_duplicates(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class WDS\", \"def without_duplicates\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/1", "question": "First, design a class called **MNS** in Python, which has an instance attribute called **machines**, a private function called **private_Ministeps**, and a public function called **public_Ministeps**. Then, implement the following problem in the private function **private_Ministeps**. Finally, call the private function private_Ministeps in the public function **public_Ministeps** and return the result.\nProblem: There are **n** super washing machines placed in a row, and it is unknown whether there are clothes inside each machine. You can choose any **m** machines and move one piece of clothing from each selected machine to an adjacent machine. Return the minimum number of steps required to make the number of clothes remaining in each machine equal.", "test_list": ["assert candidate([1,0,5])==3", "assert candidate([0,3,0])==2", "assert candidate([0,2,0])==-1"], "test_function": "def test_run(content1):\n    return MNS(content1).public_Minimum_number_steps()", "entry_point": "test_run", "test_matching": "assert candidate([[\"class MNS\", \"def public_Ministeps\", \"def __private_Ministeps\"],[\"class MNS\", \"def public_Ministeps\", \"def _private_Ministeps\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/2", "question": "Question: Given an integer array **nums** and two integers **left** and **right**. Find the number of subarrays in **nums** that are continuous, non-empty, and have the maximum element within the range [left, right].\n Please create a class called FDSB in Python based on the above problem, with the **nums** attribute. Then create a class called **SN_FDSB** that inherits from the **FDSB** class, and add two attributes **left** and **right**, as well as a public function called **find_subarray** that checks and returns the number of subarrays in **nums** that are continuous, non-empty, and have the maximum element within the range [left, right].", "test_list": ["assert candidate([2,1,4,3],2,3)==3", "assert candidate([2,9,2,5,6],2,8)==7"], "test_function": "def test_run(content1,content2,content3):\n    return SN_FDSB(content1,content2,content3).find_subarray()", "entry_point": "test_run", "test_matching": "assert candidate([['class FDSB', 'def find_subarray', 'super().__init__(nums)', 'def find_subarray']]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/3", "question": "First, write a class called **FTM** using the Python language. Then, within the **FTM** class, create a public function called **find_the_median** that returns the median of two sorted arrays, **nums1** and **nums2**.", "test_list": ["assert candidate([1,3], [2])==2.00000", "assert candidate([1,2], [3,4])==2.50000"], "test_function": "def test_run(content1,content2):\n    return FTM().find_the_median(content1,content2)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class FTM\", \"def find_the_median\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
{"task_id": "OOP/4", "question": "First, write a **PDSB** class using the Python language. Then, within the **PDSB** class, implement a public **pa_substring** function to find the longest palindrome substring in string **s**.", "test_list": ["assert candidate(\"babad\")==\"bab\"", "assert candidate(\"cbbd\")==\"bb\""], "test_function": "def test_run(content1):\n    return PDSB().pa_substring(content1)", "entry_point": "test_run", "test_matching": "assert candidate([[\"class PDSB\", \"def pa_substring\"]]) == True", "test_match_function": "def matching_function(content):\n    def run_match(text):\n        for task in text:\n            if task not in str_content:\n                return False\n        return True\n    len_cont = len(content)\n    if len_cont==1 and run_match(content[0]) == True:\n        return True\n    elif (len_cont==2 and run_match(content[0]) == True) or (len_cont==2 and run_match(content[1]) == True):\n        return True\n    else:\n        return False"}
